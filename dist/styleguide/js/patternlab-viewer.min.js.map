{"version":3,"file":"patternlab-viewer.min.js","sources":["webpack:///webpack/bootstrap d87317bf2d20ce41250d","webpack:///./src/scripts/url-handler/index.js","webpack:///./src/scripts/panels-util/index.js","webpack:///./src/scripts/postmessage/index.js","webpack:///./src/scripts/data-saver/index.js","webpack:///./node_modules/path-browserify/index.js","webpack:///./src/scripts/panels-viewer/index.js","webpack:///./src/scripts/panels/index.js","webpack:///./src/scripts/prism/prism-languages.js","webpack:///./src/scripts/pattern-finder/index.js","webpack:///./src/scripts/styleguide/index.js","webpack:///./src/scripts/patternlab-viewer.js","webpack:///./src/scripts/layout/index.js","webpack:///./node_modules/twig/twig.js","webpack:///./node_modules/process/browser.js","webpack:///./src/scripts/modal-viewer/index.js","webpack:///./src/scripts/plugin-loader/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d87317bf2d20ce41250d","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * URL Handler\n *\n * Copyright (c) 2013-2014 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * Helps handle the initial iFrame source. Parses a string to see if it matches\n * an expected pattern in Pattern Lab. Supports Pattern Labs fuzzy pattern partial\n * matching style.\n *\n */\n\nconst urlHandler = exports.urlHandler = {\n  // \n  // var urlHandler = {\n\n  // set-up some default vars\n  skipBack: false,\n  targetOrigin: window.location.protocol == \"file:\" ? \"*\" : window.location.protocol + \"//\" + window.location.host,\n\n  /**\n  * get the real file name for a given pattern name\n  * @param  {String}       the shorthand partials syntax for a given pattern\n  * @param  {Boolean}      with the file name should be returned with the full rendered suffix or not\n  *\n  * @return {String}       the real file path\n  */\n  getFileName: function (name, withRenderedSuffix) {\n\n    var baseDir = \"patterns\";\n    var fileName = \"\";\n\n    if (name === undefined) {\n      return fileName;\n    }\n\n    if (withRenderedSuffix === undefined) {\n      withRenderedSuffix = true;\n    }\n\n    if (name == \"all\") {\n      return \"styleguide/html/styleguide.html\";\n    } else if (name == \"snapshots\") {\n      return \"snapshots/index.html\";\n    }\n\n    var paths = name.indexOf(\"viewall-\") != -1 ? viewAllPaths : patternPaths;\n    var nameClean = name.replace(\"viewall-\", \"\");\n\n    // look at this as a regular pattern\n    var bits = this.getPatternInfo(nameClean, paths);\n    var patternType = bits[0];\n    var pattern = bits[1];\n\n    if (paths[patternType] !== undefined && paths[patternType][pattern] !== undefined) {\n\n      fileName = paths[patternType][pattern];\n    } else if (paths[patternType] !== undefined) {\n\n      for (var patternMatchKey in paths[patternType]) {\n        if (patternMatchKey.indexOf(pattern) != -1) {\n          fileName = paths[patternType][patternMatchKey];\n          break;\n        }\n      }\n    }\n\n    if (fileName === \"\") {\n      return fileName;\n    }\n\n    var regex = /\\//g;\n    if (name.indexOf(\"viewall-\") !== -1 && name.indexOf(\"viewall-\") === 0 && fileName !== \"\") {\n      fileName = baseDir + \"/\" + fileName.replace(regex, \"-\") + \"/index.html\";\n    } else if (fileName !== \"\") {\n      fileName = baseDir + \"/\" + fileName.replace(regex, \"-\") + \"/\" + fileName.replace(regex, \"-\");\n      if (withRenderedSuffix) {\n        var fileSuffixRendered = config.outputFileSuffixes !== undefined && config.outputFileSuffixes.rendered !== undefined ? config.outputFileSuffixes.rendered : '';\n        fileName = fileName + fileSuffixRendered + \".html\";\n      }\n    }\n\n    return fileName;\n  },\n\n  /**\n  * break up a pattern into its parts, pattern type and pattern name\n  * @param  {String}       the shorthand partials syntax for a given pattern\n  * @param  {Object}       the paths to be compared\n  *\n  * @return {Array}        the pattern type and pattern name\n  */\n  getPatternInfo: function (name, paths) {\n\n    var patternBits = name.split(\"-\");\n\n    var i = 1;\n    var c = patternBits.length;\n\n    var patternType = patternBits[0];\n    while (paths[patternType] === undefined && i < c) {\n      patternType += \"-\" + patternBits[i];\n      i++;\n    }\n\n    var pattern = name.slice(patternType.length + 1, name.length);\n\n    return [patternType, pattern];\n  },\n\n  /**\n  * search the request vars for a particular item\n  *\n  * @return {Object}       a search of the window.location.search vars\n  */\n  getRequestVars: function () {\n\n    // the following is taken from https://developer.mozilla.org/en-US/docs/Web/API/window.location\n    var oGetVars = new function (sSearch) {\n      if (sSearch.length > 1) {\n        for (var aItKey, nKeyId = 0, aCouples = sSearch.substr(1).split(\"&\"); nKeyId < aCouples.length; nKeyId++) {\n          aItKey = aCouples[nKeyId].split(\"=\");\n          this[unescape(aItKey[0])] = aItKey.length > 1 ? unescape(aItKey[1]) : \"\";\n        }\n      }\n    }(window.location.search);\n\n    return oGetVars;\n  },\n\n  /**\n  * push a pattern onto the current history based on a click\n  * @param  {String}       the shorthand partials syntax for a given pattern\n  * @param  {String}       the path given by the loaded iframe\n  */\n  pushPattern: function (pattern, givenPath) {\n    var data = { \"pattern\": pattern };\n    var fileName = urlHandler.getFileName(pattern);\n    var path = window.location.pathname;\n    path = window.location.protocol === \"file\" ? path.replace(\"/public/index.html\", \"public/\") : path.replace(/\\/index\\.html/, \"/\");\n    var expectedPath = window.location.protocol + \"//\" + window.location.host + path + fileName;\n    if (givenPath != expectedPath) {\n      // make sure to update the iframe because there was a click\n      var obj = JSON.stringify({ \"event\": \"patternLab.updatePath\", \"path\": fileName });\n      document.getElementById(\"sg-viewport\").contentWindow.postMessage(obj, urlHandler.targetOrigin);\n    } else {\n      // add to the history\n      var addressReplacement = window.location.protocol == \"file:\" ? null : window.location.protocol + \"//\" + window.location.host + window.location.pathname.replace(\"index.html\", \"\") + \"?p=\" + pattern;\n      if (history.pushState !== undefined) {\n        history.pushState(data, null, addressReplacement);\n      }\n      document.getElementById(\"title\").innerHTML = \"Pattern Lab - \" + pattern;\n      if (document.getElementById(\"sg-raw\") !== null) {\n        document.getElementById(\"sg-raw\").setAttribute(\"href\", urlHandler.getFileName(pattern));\n      }\n    }\n  },\n\n  /**\n  * based on a click forward or backward modify the url and iframe source\n  * @param  {Object}      event info like state and properties set in pushState()\n  */\n  popPattern: function (e) {\n\n    var patternName;\n    var state = e.state;\n\n    if (state === null) {\n      this.skipBack = false;\n      return;\n    } else if (state !== null) {\n      patternName = state.pattern;\n    }\n\n    var iFramePath = \"\";\n    iFramePath = this.getFileName(patternName);\n    if (iFramePath === \"\") {\n      iFramePath = \"styleguide/html/styleguide.html\";\n    }\n\n    var obj = JSON.stringify({ \"event\": \"patternLab.updatePath\", \"path\": iFramePath });\n    document.getElementById(\"sg-viewport\").contentWindow.postMessage(obj, urlHandler.targetOrigin);\n    document.getElementById(\"title\").innerHTML = \"Pattern Lab - \" + patternName;\n    if (document.getElementById(\"sg-raw\") !== null) {\n      document.getElementById(\"sg-raw\").setAttribute(\"href\", urlHandler.getFileName(patternName));\n    }\n\n    /*\n    if (wsnConnected !== undefined) {\n      wsn.send( '{\"url\": \"'+iFramePath+'\", \"patternpartial\": \"'+patternName+'\" }' );\n    }\n    */\n  }\n\n};\n\n/**\n* handle the onpopstate event\n*/\nwindow.onpopstate = function (event) {\n  urlHandler.skipBack = true;\n  urlHandler.popPattern(event);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/url-handler/index.js\n// module id = 0\n// module chunks = 0 1","'use strict';\n\n/*!\n * Panels Util\n * For both styleguide and viewer\n *\n * Copyright (c) 2013-16 Brad Frost, http://bradfrostweb.com & Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * @requires url-handler.js\n *\n */\n\nrequire('url-handler');\n\nvar panelsUtil = {\n\n  /**\n  * Add click events to the template that was rendered\n  * @param  {String}      the rendered template for the modal\n  * @param  {String}      the pattern partial for the modal\n  */\n  addClickEvents: function (templateRendered, patternPartial) {\n\n    var els = templateRendered.querySelectorAll('#sg-' + patternPartial + '-tabs li');\n    for (var i = 0; i < els.length; ++i) {\n      els[i].onclick = function (e) {\n        e.preventDefault();\n        var patternPartial = this.getAttribute('data-patternpartial');\n        var panelID = this.getAttribute('data-panelid');\n        panelsUtil.show(patternPartial, panelID);\n      };\n    }\n\n    return templateRendered;\n  },\n\n  /**\n  * Show a specific modal\n  * @param  {String}      the pattern partial for the modal\n  * @param  {String}      the ID of the panel to be shown\n  */\n  show: function (patternPartial, panelID) {\n\n    var els;\n\n    // turn off all of the active tabs\n    els = document.querySelectorAll('#sg-' + patternPartial + '-tabs li');\n    for (var i = 0; i < els.length; ++i) {\n      els[i].classList.remove('sg-tab-title-active');\n    }\n\n    // hide all of the panels\n    els = document.querySelectorAll('#sg-' + patternPartial + '-panels div.sg-tabs-panel');\n    for (var i = 0; i < els.length; ++i) {\n      els[i].style.display = 'none';\n    }\n\n    // add active tab class\n    document.getElementById('sg-' + patternPartial + '-' + panelID + '-tab').classList.add('sg-tab-title-active');\n\n    // show the panel\n    document.getElementById('sg-' + patternPartial + '-' + panelID + '-panel').style.display = 'flex';\n  }\n\n};\n\nmodule.exports = panelsUtil;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/panels-util/index.js\n// module id = 1\n// module chunks = 0 1","\"use strict\";\n\n/*!\n * Basic postMessage Support\n *\n * Copyright (c) 2013-2016 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * Handles the postMessage stuff in the pattern, view-all, and style guide templates.\n *\n */\n\n// alert the iframe parent that the pattern has loaded assuming this view was loaded in an iframe\nif (self != top) {\n\n  // handle the options that could be sent to the parent window\n  //   - all get path\n  //   - pattern & view all get a pattern partial, styleguide gets all\n  //   - pattern shares lineage\n  var path = window.location.toString();\n  var parts = path.split(\"?\");\n  var options = { \"event\": \"patternLab.pageLoad\", \"path\": parts[0] };\n\n  var patternData = document.getElementById('sg-pattern-data-footer').innerHTML;\n  patternData = JSON.parse(patternData);\n  options.patternpartial = patternData.patternPartial !== undefined ? patternData.patternPartial : \"all\";\n  if (patternData.lineage !== \"\") {\n    options.lineage = patternData.lineage;\n  }\n\n  var targetOrigin = window.location.protocol == \"file:\" ? \"*\" : window.location.protocol + \"//\" + window.location.host;\n  parent.postMessage(options, targetOrigin);\n\n  // find all links and add an onclick handler for replacing the iframe address so the history works\n  var aTags = document.getElementsByTagName('a');\n  for (var i = 0; i < aTags.length; i++) {\n    aTags[i].onclick = function (e) {\n      var href = this.getAttribute(\"href\");\n      var target = this.getAttribute(\"target\");\n      if (target !== undefined && (target == \"_parent\" || target == \"_blank\")) {\n        // just do normal stuff\n      } else if (href && href !== \"#\") {\n        e.preventDefault();\n        window.location.replace(href);\n      } else {\n        e.preventDefault();\n        return false;\n      }\n    };\n  }\n}\n\n// watch the iframe source so that it can be sent back to everyone else.\nfunction receiveIframeMessage(event) {\n\n  // does the origin sending the message match the current host? if not dev/null the request\n  if (window.location.protocol != \"file:\" && event.origin !== window.location.protocol + \"//\" + window.location.host) {\n    return;\n  }\n\n  var path;\n  var data = {};\n  try {\n    data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n  } catch (e) {}\n\n  if (data.event !== undefined && data.event == \"patternLab.updatePath\") {\n\n    if (patternData.patternPartial !== undefined) {\n\n      // handle patterns and the view all page\n      var re = /(patterns|snapshots)\\/(.*)$/;\n      path = window.location.protocol + \"//\" + window.location.host + window.location.pathname.replace(re, '') + data.path + '?' + Date.now();\n      window.location.replace(path);\n    } else {\n\n      // handle the style guide\n      path = window.location.protocol + \"//\" + window.location.host + window.location.pathname.replace(\"styleguide\\/html\\/styleguide.html\", \"\") + data.path + '?' + Date.now();\n      window.location.replace(path);\n    }\n  } else if (data.event !== undefined && data.event == \"patternLab.reload\") {\n\n    // reload the location if there was a message to do so\n    window.location.reload();\n  }\n}\nwindow.addEventListener(\"message\", receiveIframeMessage, false);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/postmessage/index.js\n// module id = 2\n// module chunks = 0 1","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * jQuery Cookie Plugin v1.3\n * https://github.com/carhartl/jquery-cookie\n *\n * Copyright 2011, Klaus Hartl\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://www.opensource.org/licenses/mit-license.php\n * http://www.opensource.org/licenses/GPL-2.0\n */\n\n(function ($, document, undefined) {\n\n  var pluses = /\\+/g;\n\n  function raw(s) {\n    return s;\n  }\n\n  function decoded(s) {\n    return decodeURIComponent(s.replace(pluses, ' '));\n  }\n\n  var config = $.cookie = function (key, value, options) {\n\n    // write\n    if (value !== undefined) {\n      options = $.extend({}, config.defaults, options);\n\n      if (value === null) {\n        options.expires = -1;\n      }\n\n      if (typeof options.expires === 'number') {\n        var days = options.expires,\n            t = options.expires = new Date();\n        t.setDate(t.getDate() + days);\n      }\n\n      value = config.json ? JSON.stringify(value) : String(value);\n\n      return document.cookie = [encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE\n      options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join('');\n    }\n\n    // read\n    var decode = config.raw ? raw : decoded;\n    var cookies = document.cookie.split('; ');\n    for (var i = 0, l = cookies.length; i < l; i++) {\n      var parts = cookies[i].split('=');\n      if (decode(parts.shift()) === key) {\n        var cookie = decode(parts.join('='));\n        return config.json ? JSON.parse(cookie) : cookie;\n      }\n    }\n\n    return null;\n  };\n\n  config.defaults = {};\n\n  $.removeCookie = function (key, options) {\n    if ($.cookie(key) !== null) {\n      $.cookie(key, null, options);\n      return true;\n    }\n    return false;\n  };\n})(jQuery, document);\n\n/*!\n * Data Saver\n *\n * Copyright (c) 2013-2014 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n */\n\nconst DataSaver = exports.DataSaver = {\n\n  // the name of the cookie to store the data in\n  cookieName: \"patternlab\",\n\n  /**\n  * Add a given value to the cookie\n  * @param  {String}       the name of the key\n  * @param  {String}       the value\n  */\n  addValue: function (name, val) {\n    var cookieVal = $.cookie(this.cookieName);\n    cookieVal = cookieVal === null || cookieVal === \"\" ? name + \"~\" + val : cookieVal + \"|\" + name + \"~\" + val;\n    $.cookie(this.cookieName, cookieVal);\n  },\n\n  /**\n  * Update a value found in the cookie. If the key doesn't exist add the value\n  * @param  {String}       the name of the key\n  * @param  {String}       the value\n  */\n  updateValue: function (name, val) {\n    if (this.findValue(name)) {\n      var updateCookieVals = \"\";\n      var cookieVals = $.cookie(this.cookieName).split(\"|\");\n      for (var i = 0; i < cookieVals.length; i++) {\n        var fieldVals = cookieVals[i].split(\"~\");\n        if (fieldVals[0] == name) {\n          fieldVals[1] = val;\n        }\n        updateCookieVals += i > 0 ? \"|\" + fieldVals[0] + \"~\" + fieldVals[1] : fieldVals[0] + \"~\" + fieldVals[1];\n      }\n      $.cookie(this.cookieName, updateCookieVals);\n    } else {\n      this.addValue(name, val);\n    }\n  },\n\n  /**\n  * Remove the given key\n  * @param  {String}       the name of the key\n  */\n  removeValue: function (name) {\n    var updateCookieVals = \"\";\n    var cookieVals = $.cookie(this.cookieName).split(\"|\");\n    var k = 0;\n    for (var i = 0; i < cookieVals.length; i++) {\n      var fieldVals = cookieVals[i].split(\"~\");\n      if (fieldVals[0] != name) {\n        updateCookieVals += k === 0 ? fieldVals[0] + \"~\" + fieldVals[1] : \"|\" + fieldVals[0] + \"~\" + fieldVals[1];\n        k++;\n      }\n    }\n    $.cookie(this.cookieName, updateCookieVals);\n  },\n\n  /**\n  * Find the value using the given key\n  * @param  {String}       the name of the key\n  *\n  * @return {String}       the value of the key or false if the value isn't found\n  */\n  findValue: function (name) {\n    if ($.cookie(this.cookieName)) {\n      var cookieVals = $.cookie(this.cookieName).split(\"|\");\n      for (var i = 0; i < cookieVals.length; i++) {\n        var fieldVals = cookieVals[i].split(\"~\");\n        if (fieldVals[0] == name) {\n          return fieldVals[1];\n        }\n      }\n    }\n    return false;\n  }\n\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/data-saver/index.js\n// module id = 3\n// module chunks = 0","'use strict';\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function (filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n// path.relative(from, to)\n// posix version\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nexports.basename = function (path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  return splitPath(path)[3];\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/path-browserify/index.js\n// module id = 5\n// module chunks = 0","'use strict';\n\n/*!\n * Panel Builder. Supports building the panels to be included in the modal or styleguide\n *\n * Copyright (c) 2013-16 Brad Frost, http://bradfrostweb.com & Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * @requires panels.js\n * @requires url-handler.js\n */\n\nconst Panels = require('panels');\nconst panelsUtil = require('panels-util');\nconst urlHandler = require('url-handler').urlHandler;\n\nvar panelsViewer = {\n\n  // set up some defaults\n  targetOrigin: window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host,\n  initCopy: false,\n  initMoveTo: 0,\n\n  /**\n  * Check to see if all of the panels have been collected before rendering\n  * @param  {String}      the collected panels\n  * @param  {String}      the data from the pattern\n  * @param  {Boolean}     if this is going to be passed back to the styleguide\n  */\n  checkPanels: function (panels, patternData, iframePassback, switchText) {\n\n    // count how many panels have rendered content\n    var panelContentCount = 0;\n    for (var i = 0; i < panels.length; ++i) {\n      if (panels[i].content !== undefined) {\n        panelContentCount++;\n      }\n    }\n\n    // see if the count of panels with content matches number of panels\n    if (panelContentCount === Panels.count()) {\n      panelsViewer.renderPanels(panels, patternData, iframePassback, switchText);\n    }\n  },\n\n  /**\n  * Gather the panels related to the modal\n  * @param  {String}      the data from the pattern\n  * @param  {Boolean}     if this is going to be passed back to the styleguide\n  */\n  gatherPanels: function (patternData, iframePassback, switchText) {\n\n    Dispatcher.addListener('checkPanels', panelsViewer.checkPanels);\n\n    // set-up defaults\n    var template, templateCompiled, templateRendered, panel;\n\n    // get the base panels\n    var panels = Panels.get();\n\n    // evaluate panels array and create content\n    for (var i = 0; i < panels.length; ++i) {\n\n      var panel = panels[i];\n\n      // catch pattern panel since it doesn't have a name defined by default\n      if (panel.name === undefined) {\n        panel.name = patternData.patternEngineName || patternData.patternExtension;\n        panel.httpRequestReplace = panel.httpRequestReplace + '.' + patternData.patternExtension;\n        panel.language = patternData.patternExtension;\n      }\n\n      if (panel.templateID !== undefined && panel.templateID) {\n\n        if (panel.httpRequest !== undefined && panel.httpRequest) {\n\n          // need a file and then render\n          var fileBase = urlHandler.getFileName(patternData.patternPartial, false);\n          var e = new XMLHttpRequest();\n          e.onload = function (i, panels, patternData, iframeRequest) {\n            return function () {\n              var prismedContent = Prism.highlight(this.responseText, Prism.languages['html']);\n              template = document.getElementById(panels[i].templateID);\n              templateCompiled = Hogan.compile(template.innerHTML);\n              templateRendered = templateCompiled.render({ 'language': 'html', 'code': prismedContent });\n              panels[i].content = templateRendered;\n              Dispatcher.trigger('checkPanels', [panels, patternData, iframePassback, switchText]);\n            };\n          }(i, panels, patternData, iframePassback);\n\n          e.open('GET', fileBase + panel.httpRequestReplace + '?' + new Date().getTime(), true);\n          e.send();\n        } else {\n\n          // vanilla render of pattern data\n          template = document.getElementById(panel.templateID);\n          templateCompiled = Hogan.compile(template.innerHTML);\n          templateRendered = templateCompiled.render(patternData);\n          panels[i].content = templateRendered;\n          Dispatcher.trigger('checkPanels', [panels, patternData, iframePassback, switchText]);\n        }\n      }\n    }\n  },\n\n  /**\n  * Render the panels that have been collected\n  * @param  {String}      the collected panels\n  * @param  {String}      the data from the pattern\n  * @param  {Boolean}     if this is going to be passed back to the styleguide\n  */\n  renderPanels: function (panels, patternData, iframePassback, switchText) {\n\n    // set-up defaults\n    var template, templateCompiled, templateRendered;\n    var annotation, comment, count, div, els, item, markup, i;\n    var patternPartial = patternData.patternPartial;\n    patternData.panels = panels;\n\n    // set a default pattern description for modal pop-up\n    if (!iframePassback && patternData.patternDesc.length === 0) {\n      patternData.patternDesc = \"This pattern doesn't have a description.\";\n    }\n\n    // capitilize the pattern name\n    patternData.patternNameCaps = patternData.patternName.toUpperCase();\n\n    // check for annotations in the given mark-up\n    markup = document.createElement('div');\n    markup.innerHTML = patternData.patternMarkup;\n\n    count = 1;\n    patternData.annotations = [];\n    delete patternData['patternMarkup'];\n\n    for (i = 0; i < comments.comments.length; ++i) {\n\n      item = comments.comments[i];\n      els = markup.querySelectorAll(item.el);\n\n      if (els.length > 0) {\n        annotation = { 'displayNumber': count, 'el': item.el, 'title': item.title, 'comment': item.comment };\n        patternData.annotations.push(annotation);\n        count++;\n      }\n    }\n\n    // alert the pattern that annotations should be highlighted\n    if (patternData.annotations.length > 0) {\n      var obj = JSON.stringify({ 'event': 'patternLab.annotationsHighlightShow', 'annotations': patternData.annotations });\n      document.getElementById('sg-viewport').contentWindow.postMessage(obj, panelsViewer.targetOrigin);\n    }\n\n    // add hasComma property to lineage\n    if (patternData.lineage.length > 0) {\n      for (i = 0; i < patternData.lineage.length; ++i) {\n        if (i < patternData.lineage.length - 1) {\n          patternData.lineage[i].hasComma = true;\n        }\n      }\n    }\n\n    // add hasComma property to lineageR\n    if (patternData.lineageR.length > 0) {\n      for (i = 0; i < patternData.lineageR.length; ++i) {\n        if (i < patternData.lineageR.length - 1) {\n          patternData.lineageR[i].hasComma = true;\n        }\n      }\n    }\n\n    // add *Exists attributes for Hogan templates\n    // figure out if the description exists\n    patternData.patternDescExists = patternData.patternDesc.length > 0 || patternData.patternDescAdditions !== undefined && patternData.patternDescAdditions.length > 0;\n\n    // figure out if lineage should be drawn\n    patternData.lineageExists = patternData.lineage.length !== 0;\n\n    // figure out if reverse lineage should be drawn\n    patternData.lineageRExists = patternData.lineageR.length !== 0;\n\n    // figure out if pattern state should be drawn\n    patternData.patternStateExists = patternData.patternState.length > 0;\n\n    // figure if annotations should be drawn\n    patternData.annotationExists = patternData.annotations.length > 0;\n\n    // figure if the entire desc block should be drawn\n    patternData.descBlockExists = patternData.patternDescExists || patternData.lineageExists || patternData.lineageRExists || patternData.patternStateExists || patternData.annotationExists;\n\n    // set isPatternView based on if we have to pass it back to the styleguide level\n    patternData.isPatternView = iframePassback === false;\n\n    // render all of the panels in the base panel template\n    template = document.getElementById('pl-panel-template-base');\n    templateCompiled = Hogan.compile(template.innerHTML);\n    templateRendered = templateCompiled.render(patternData);\n\n    // make sure templateRendered is modified to be an HTML element\n    div = document.createElement('div');\n    div.className = 'sg-modal-content-inner';\n    div.innerHTML = templateRendered;\n    templateRendered = div;\n\n    // add click events\n    templateRendered = panelsUtil.addClickEvents(templateRendered, patternPartial);\n\n    // add onclick events to the tabs in the rendered content\n    for (i = 0; i < panels.length; ++i) {\n\n      var panel = panels[i];\n\n      // default IDs\n      var panelTab = '#sg-' + patternPartial + '-' + panel.id + '-tab';\n      var panelBlock = '#sg-' + patternPartial + '-' + panel.id + '-panel';\n\n      // show default options\n      if (templateRendered.querySelector(panelTab) !== null && panel.default) {\n        templateRendered.querySelector(panelTab).classList.add('sg-tab-title-active');\n        templateRendered.querySelector(panelBlock).style.display = 'block';\n      }\n    }\n\n    // find lineage links in the rendered content and add postmessage handlers in case it's in the modal\n    $('#sg-code-lineage-fill a, #sg-code-lineager-fill a', templateRendered).on('click', function (e) {\n      e.preventDefault();\n      var obj = JSON.stringify({ 'event': 'patternLab.updatePath', 'path': urlHandler.getFileName($(this).attr('data-patternpartial')) });\n      document.getElementById('sg-viewport').contentWindow.postMessage(obj, panelsViewer.targetOrigin);\n    });\n\n    // gather panels from plugins\n    Dispatcher.trigger('insertPanels', [templateRendered, patternPartial, iframePassback, switchText]);\n  }\n\n};\n\nmodule.exports = panelsViewer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/panels-viewer/index.js\n// module id = 6\n// module chunks = 0","'use strict';\n\n/*!\n * Default Panels for Pattern Lab plus Panel related events\n *\n * Copyright (c) 2016 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * config is coming from the default viewer and is passed through from PL's config\n *\n * @requires prism-languages.js\n */\n\nrequire('prism/prism-languages');\n\nvar Panels = {\n\n  panels: [],\n\n  count: function () {\n    return this.panels.length;\n  },\n\n  get: function () {\n    return JSON.parse(JSON.stringify(this.panels));\n  },\n\n  add: function (panel) {\n\n    // if ID already exists in panels array ignore the add()\n    for (var i = 0; i < this.panels.length; ++i) {\n      if (panel.id === this.panels[i].id) {\n        return;\n      }\n    }\n\n    // it wasn't found so push the tab onto the tabs\n    this.panels.push(panel);\n  }\n\n};\n\n// set-up the base file extensions to fetch\nvar fileSuffixPattern = config.outputFileSuffixes !== undefined && config.outputFileSuffixes.rawTemplate !== undefined ? config.outputFileSuffixes.rawTemplate : '';\nvar fileSuffixMarkup = config.outputFileSuffixes !== undefined && config.outputFileSuffixes.markupOnly !== undefined ? config.outputFileSuffixes.markupOnly : '.markup-only';\n\n// add the default panels\nPanels.add({ 'id': 'sg-panel-pattern', 'default': true, 'templateID': 'pl-panel-template-code', 'httpRequest': true, 'httpRequestReplace': fileSuffixPattern, 'httpRequestCompleted': false, 'prismHighlight': true, 'keyCombo': 'ctrl+shift+u' });\nPanels.add({ 'id': 'sg-panel-html', 'name': 'HTML', 'default': false, 'templateID': 'pl-panel-template-code', 'httpRequest': true, 'httpRequestReplace': fileSuffixMarkup + '.html', 'httpRequestCompleted': false, 'prismHighlight': true, 'language': 'markup', 'keyCombo': 'ctrl+shift+y' });\n\nmodule.exports = Panels;\n\n// gather panels from plugins\nDispatcher.trigger('setupPanels');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/panels/index.js\n// module id = 7\n// module chunks = 0","'use strict';\n\n/*!\n * Default languages for Prism to match rendering capability\n *\n * Copyright (c) 2016 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n */\nvar PrismLanguages = {\n\n  languages: [],\n\n  get: function (key) {\n\n    var language;\n\n    for (var i = 0; i < this.languages.length; ++i) {\n      language = this.languages[i];\n      if (language[key] !== undefined) {\n        return language[key];\n      }\n    }\n\n    return 'markup';\n  },\n\n  add: function (language) {\n\n    // see if the language already exists, overwrite if it does\n    for (var key in language) {\n      if (language.hasOwnProperty(key)) {\n        for (var i = 0; i < this.languages.length; ++i) {\n          if (this.languages[i][key] !== undefined) {\n            this.languages[i][key] = language[key];\n            return;\n          }\n        }\n      }\n    }\n\n    this.languages.push(language);\n  }\n\n};\n\n// this shouldn't get hardcoded, also need to think about including Prism's real lang libraries (e.g. handlebars & twig)\nPrismLanguages.add({ 'twig': 'markup' });\nPrismLanguages.add({ 'mustache': 'markup' });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/prism/prism-languages.js\n// module id = 8\n// module chunks = 0","'use strict';\n\n/*!\n * Pattern Finder\n *\n * Copyright (c) 2014 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * @requires url-handler.js\n *\n */\nrequire('url-handler');\n\nvar patternFinder = {\n\n  data: [],\n  active: false,\n\n  init: function () {\n\n    for (var patternType in patternPaths) {\n      if (patternPaths.hasOwnProperty(patternType)) {\n        for (var pattern in patternPaths[patternType]) {\n          var obj = {};\n          obj.patternPartial = patternType + \"-\" + pattern;\n          obj.patternPath = patternPaths[patternType][pattern];\n          this.data.push(obj);\n        }\n      }\n    }\n\n    // instantiate the bloodhound suggestion engine\n    var patterns = new Bloodhound({\n      datumTokenizer: function (d) {\n        return Bloodhound.tokenizers.nonword(d.patternPartial);\n      },\n      queryTokenizer: Bloodhound.tokenizers.nonword,\n      limit: 10,\n      local: this.data\n    });\n\n    // initialize the bloodhound suggestion engine\n    patterns.initialize();\n\n    $('#sg-find .typeahead').typeahead({ highlight: true }, {\n      displayKey: 'patternPartial',\n      source: patterns.ttAdapter()\n    }).on('typeahead:selected', patternFinder.onSelected).on('typeahead:autocompleted', patternFinder.onAutocompleted);\n  },\n\n  passPath: function (item) {\n    // update the iframe via the history api handler\n    patternFinder.closeFinder();\n    var obj = JSON.stringify({ \"event\": \"patternLab.updatePath\", \"path\": urlHandler.getFileName(item.patternPartial) });\n    document.getElementById(\"sg-viewport\").contentWindow.postMessage(obj, urlHandler.targetOrigin);\n  },\n\n  onSelected: function (e, item) {\n    patternFinder.passPath(item);\n  },\n\n  onAutocompleted: function (e, item) {\n    patternFinder.passPath(item);\n  },\n\n  toggleFinder: function () {\n    if (!patternFinder.active) {\n      patternFinder.openFinder();\n    } else {\n      patternFinder.closeFinder();\n    }\n  },\n\n  openFinder: function () {\n    patternFinder.active = true;\n    $('#sg-find .typeahead').val(\"\");\n    $(\"#sg-find\").addClass('show-overflow');\n  },\n\n  closeFinder: function () {\n    patternFinder.active = false;\n    document.activeElement.blur();\n    $(\"#sg-find\").removeClass('show-overflow');\n    $('#sg-find .typeahead').val(\"\");\n  },\n\n  receiveIframeMessage: function (event) {\n\n    // does the origin sending the message match the current host? if not dev/null the request\n    if (window.location.protocol !== \"file:\" && event.origin !== window.location.protocol + \"//\" + window.location.host) {\n      return;\n    }\n\n    var data = {};\n    try {\n      data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n    } catch (e) {}\n\n    if (data.event !== undefined && data.event == \"patternLab.keyPress\") {\n\n      if (data.keyPress == 'ctrl+shift+f') {\n        patternFinder.toggleFinder();\n        return false;\n      }\n    }\n  }\n\n};\n\npatternFinder.init();\n\nwindow.addEventListener(\"message\", patternFinder.receiveIframeMessage, false);\n\n$('#sg-find .typeahead').focus(function () {\n  if (!patternFinder.active) {\n    patternFinder.openFinder();\n  }\n});\n\n$('#sg-find .typeahead').blur(function () {\n  patternFinder.closeFinder();\n});\n\nmodule.exports = patternFinder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/pattern-finder/index.js\n// module id = 9\n// module chunks = 0","'use strict';\n\n/**\n * @requires data-saver.js\n * @requires url-handler.js\n * @requires postmessage.js\n */\n\nconst DataSaver = require('data-saver').DataSaver;\nconst urlHandler = require('url-handler').urlHandler;\nconst patternFinder = require('pattern-finder');\nrequire('postmessage');\n\n// (function (w) {\n\nvar sw = document.body.clientWidth,\n    //Viewport Width\nsh = $(document).height(),\n    //Viewport Height\nminViewportWidth = parseInt(config.ishMinimum),\n    //Minimum Size for Viewport\nmaxViewportWidth = parseInt(config.ishMaximum),\n    //Maxiumum Size for Viewport\nviewportResizeHandleWidth = 14,\n    //Width of the viewport drag-to-resize handle\n$sgViewport = $('#sg-viewport'),\n    //Viewport element\n$sizePx = $('.sg-size-px'),\n    //Px size input element in toolbar\n$sizeEms = $('.sg-size-em'),\n    //Em size input element in toolbar\n$bodySize = config.ishFontSize !== undefined ? parseInt(config.ishFontSize) : parseInt($('body').css('font-size')),\n    //Body size of the document,\n$headerHeight = $('.sg-header').height(),\n    discoID = false,\n    discoMode = false,\n    fullMode = true,\n    hayMode = false;\n\n//Update dimensions on resize\n$(window).resize(function () {\n  sw = document.body.clientWidth;\n  sh = $(document).height();\n\n  setAccordionHeight();\n\n  if (fullMode === true) {\n    sizeiframe(sw, false);\n  }\n});\n\n// Accordion dropdown\n$('.sg-acc-handle').on(\"click\", function (e) {\n  e.preventDefault();\n\n  var $this = $(this),\n      $panel = $this.next('.sg-acc-panel'),\n      subnav = $this.parent().parent().hasClass('sg-acc-panel');\n\n  //Close other panels if link isn't a subnavigation item\n  if (!subnav) {\n    $('.sg-acc-handle').not($this).removeClass('active');\n    $('.sg-acc-panel').not($panel).removeClass('active');\n  }\n\n  //Activate selected panel\n  $this.toggleClass('active');\n  $panel.toggleClass('active');\n  setAccordionHeight();\n});\n\n//Accordion Height\nfunction setAccordionHeight() {\n  var $activeAccordion = $('.sg-acc-panel.active').first(),\n      accordionHeight = $activeAccordion.height(),\n      availableHeight = sh - $headerHeight; //Screen height minus the height of the header\n\n  $activeAccordion.height(availableHeight); //Set height of accordion to the available height\n}\n\n$('.sg-nav-toggle').on(\"click\", function (e) {\n  e.preventDefault();\n  $('.sg-nav-container').toggleClass('active');\n});\n\n// \"View (containing clean, code, raw, etc options) Trigger\n$('#sg-t-toggle').on(\"click\", function (e) {\n  e.preventDefault();\n  $(this).parents('ul').toggleClass('active');\n});\n\n//Size Trigger\n$('#sg-size-toggle').on(\"click\", function (e) {\n  e.preventDefault();\n  $(this).parents('ul').toggleClass('active');\n});\n\n//Phase View Events\n$('.sg-size[data-size]').on(\"click\", function (e) {\n  e.preventDefault();\n  killDisco();\n  killHay();\n  fullMode = false;\n\n  var val = $(this).attr('data-size');\n\n  if (val.indexOf('px') > -1) {\n    $bodySize = 1;\n  }\n\n  val = val.replace(/[^\\d.-]/g, '');\n  sizeiframe(Math.floor(val * $bodySize));\n});\n\n//Size View Events\n\n// handle small button\nfunction goSmall() {\n  killDisco();\n  killHay();\n  fullMode = false;\n  sizeiframe(getRandom(minViewportWidth, 500));\n}\n\n$('#sg-size-s').on(\"click\", function (e) {\n  e.preventDefault();\n  goSmall();\n});\n\njwerty.key('ctrl+shift+s', function (e) {\n  goSmall();\n  return false;\n});\n\n// handle medium button\nfunction goMedium() {\n  killDisco();\n  killHay();\n  fullMode = false;\n  sizeiframe(getRandom(500, 800));\n}\n\n$('#sg-size-m').on(\"click\", function (e) {\n  e.preventDefault();\n  goMedium();\n});\n\njwerty.key('ctrl+shift+m', function (e) {\n  goLarge();\n  return false;\n});\n\n// handle large button\nfunction goLarge() {\n  killDisco();\n  killHay();\n  fullMode = false;\n  sizeiframe(getRandom(800, 1200));\n}\n\n$('#sg-size-l').on(\"click\", function (e) {\n  e.preventDefault();\n  goLarge();\n});\n\njwerty.key('ctrl+shift+l', function (e) {\n  goLarge();\n  return false;\n});\n\n//Click Full Width Button\n$('#sg-size-full').on(\"click\", function (e) {\n  //Resets\n  e.preventDefault();\n  killDisco();\n  killHay();\n  fullMode = true;\n  sizeiframe(sw);\n});\n\n//Click Random Size Button\n$('#sg-size-random').on(\"click\", function (e) {\n  e.preventDefault();\n  killDisco();\n  killHay();\n  fullMode = false;\n  sizeiframe(getRandom(minViewportWidth, sw));\n});\n\n//Click for Disco Mode, which resizes the viewport randomly\n$('#sg-size-disco').on(\"click\", function (e) {\n  e.preventDefault();\n  killHay();\n  fullMode = false;\n\n  if (discoMode) {\n    killDisco();\n  } else {\n    startDisco();\n  }\n});\n\n/* Disco Mode */\nfunction disco() {\n  sizeiframe(getRandom(minViewportWidth, sw));\n}\n\nfunction killDisco() {\n  discoMode = false;\n  clearInterval(discoID);\n  discoID = false;\n}\n\nfunction startDisco() {\n  discoMode = true;\n  discoID = setInterval(disco, 800);\n}\n\njwerty.key('ctrl+shift+d', function (e) {\n  if (!discoMode) {\n    startDisco();\n  } else {\n    killDisco();\n  }\n  return false;\n});\n\n//Stephen Hay Mode - \"Start with the small screen first, then expand until it looks like shit. Time for a breakpoint!\"\n$('#sg-size-hay').on(\"click\", function (e) {\n  e.preventDefault();\n  killDisco();\n  if (hayMode) {\n    killHay();\n  } else {\n    startHay();\n  }\n});\n\n//Stop Hay! Mode\nfunction killHay() {\n  var currentWidth = $sgViewport.width();\n  hayMode = false;\n  $sgViewport.removeClass('hay-mode');\n  $('#sg-gen-container').removeClass('hay-mode');\n  sizeiframe(Math.floor(currentWidth));\n}\n\n// start Hay! mode\nfunction startHay() {\n  hayMode = true;\n  $('#sg-gen-container').removeClass(\"vp-animate\").width(minViewportWidth + viewportResizeHandleWidth);\n  $sgViewport.removeClass(\"vp-animate\").width(minViewportWidth);\n\n  var timeoutID = window.setTimeout(function () {\n    $('#sg-gen-container').addClass('hay-mode').width(maxViewportWidth + viewportResizeHandleWidth);\n    $sgViewport.addClass('hay-mode').width(maxViewportWidth);\n\n    setInterval(function () {\n      var vpSize = $sgViewport.width();updateSizeReading(vpSize);\n    }, 100);\n  }, 200);\n}\n\n// start hay from a keyboard shortcut\njwerty.key('ctrl+shift+h', function (e) {\n  if (!hayMode) {\n    startHay();\n  } else {\n    killHay();\n  }\n});\n\n//Pixel input\n$sizePx.on('keydown', function (e) {\n  var val = Math.floor($(this).val());\n\n  if (e.keyCode === 38) {\n    //If the up arrow key is hit\n    val++;\n    sizeiframe(val, false);\n  } else if (e.keyCode === 40) {\n    //If the down arrow key is hit\n    val--;\n    sizeiframe(val, false);\n  } else if (e.keyCode === 13) {\n    //If the Enter key is hit\n    e.preventDefault();\n    sizeiframe(val); //Size Iframe to value of text box\n    $(this).blur();\n  }\n});\n\n$sizePx.on('keyup', function () {\n  var val = Math.floor($(this).val());\n  updateSizeReading(val, 'px', 'updateEmInput');\n});\n\n//Em input\n$sizeEms.on('keydown', function (e) {\n  var val = parseFloat($(this).val());\n\n  if (e.keyCode === 38) {\n    //If the up arrow key is hit\n    val++;\n    sizeiframe(Math.floor(val * $bodySize), false);\n  } else if (e.keyCode === 40) {\n    //If the down arrow key is hit\n    val--;\n    sizeiframe(Math.floor(val * $bodySize), false);\n  } else if (e.keyCode === 13) {\n    //If the Enter key is hit\n    e.preventDefault();\n    sizeiframe(Math.floor(val * $bodySize)); //Size Iframe to value of text box\n  }\n});\n\n$sizeEms.on('keyup', function () {\n  var val = parseFloat($(this).val());\n  updateSizeReading(val, 'em', 'updatePxInput');\n});\n\n// set 0 to 320px as a default\njwerty.key('ctrl+shift+0', function (e) {\n  e.preventDefault();\n  sizeiframe(320, true);\n  return false;\n});\n\n// handle the MQ click\nvar mqs = [];\n$('#sg-mq a').each(function (i) {\n\n  mqs.push($(this).html());\n\n  // bind the click\n  $(this).on(\"click\", function (i, k) {\n    return function (e) {\n      e.preventDefault();\n      var val = $(k).html();\n      var type = val.indexOf(\"px\") !== -1 ? \"px\" : \"em\";\n      val = val.replace(type, \"\");\n      var width = type === \"px\" ? val * 1 : val * $bodySize;\n      sizeiframe(width, true);\n    };\n  }(i, this));\n\n  // bind the keyboard shortcut. can't use cmd on a mac because 3 & 4 are for screenshots\n  jwerty.key('ctrl+shift+' + (i + 1), function (k) {\n    return function (e) {\n      var val = $(k).html();\n      var type = val.indexOf(\"px\") !== -1 ? \"px\" : \"em\";\n      val = val.replace(type, \"\");\n      var width = type === \"px\" ? val * 1 : val * $bodySize;\n      sizeiframe(width, true);\n      return false;\n    };\n  }(this));\n});\n\n//Resize the viewport\n//'size' is the target size of the viewport\n//'animate' is a boolean for switching the CSS animation on or off. 'animate' is true by default, but can be set to false for things like nudging and dragging\nfunction sizeiframe(size, animate) {\n  var theSize;\n\n  if (size > maxViewportWidth) {\n    //If the entered size is larger than the max allowed viewport size, cap value at max vp size\n    theSize = maxViewportWidth;\n  } else if (size < minViewportWidth) {\n    //If the entered size is less than the minimum allowed viewport size, cap value at min vp size\n    theSize = minViewportWidth;\n  } else {\n    theSize = size;\n  }\n\n  //Conditionally remove CSS animation class from viewport\n  if (animate === false) {\n    $('#sg-gen-container,#sg-viewport').removeClass(\"vp-animate\"); //If aninate is set to false, remove animate class from viewport\n  } else {\n    $('#sg-gen-container,#sg-viewport').addClass(\"vp-animate\");\n  }\n\n  $('#sg-gen-container').width(theSize + viewportResizeHandleWidth); //Resize viewport wrapper to desired size + size of drag resize handler\n  $sgViewport.width(theSize); //Resize viewport to desired size\n\n  var targetOrigin = window.location.protocol === \"file:\" ? \"*\" : window.location.protocol + \"//\" + window.location.host;\n  var obj = JSON.stringify({ \"event\": \"patternLab.resize\", \"resize\": \"true\" });\n  document.getElementById('sg-viewport').contentWindow.postMessage(obj, targetOrigin);\n\n  updateSizeReading(theSize); //Update values in toolbar\n  saveSize(theSize); //Save current viewport to cookie\n}\n\n$(\"#sg-gen-container\").on('transitionend webkitTransitionEnd', function (e) {\n  var targetOrigin = window.location.protocol === \"file:\" ? \"*\" : window.location.protocol + \"//\" + window.location.host;\n  var obj = JSON.stringify({ \"event\": \"patternLab.resize\", \"resize\": \"true\" });\n  document.getElementById('sg-viewport').contentWindow.postMessage(obj, targetOrigin);\n});\n\nfunction saveSize(size) {\n  if (!DataSaver.findValue('vpWidth')) {\n    DataSaver.addValue(\"vpWidth\", size);\n  } else {\n    DataSaver.updateValue(\"vpWidth\", size);\n  }\n}\n\n//Update Pixel and Em inputs\n//'size' is the input number\n//'unit' is the type of unit: either px or em. Default is px. Accepted values are 'px' and 'em'\n//'target' is what inputs to update. Defaults to both\nfunction updateSizeReading(size, unit, target) {\n  var emSize, pxSize;\n\n  if (unit === 'em') {\n    //If size value is in em units\n    emSize = size;\n    pxSize = Math.floor(size * $bodySize);\n  } else {\n    //If value is px or absent\n    pxSize = size;\n    emSize = size / $bodySize;\n  }\n\n  if (target === 'updatePxInput') {\n    $sizePx.val(pxSize);\n  } else if (target === 'updateEmInput') {\n    $sizeEms.val(emSize.toFixed(2));\n  } else {\n    $sizeEms.val(emSize.toFixed(2));\n    $sizePx.val(pxSize);\n  }\n}\n\n/* Returns a random number between min and max */\nfunction getRandom(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\n//Update The viewport size\nfunction updateViewportWidth(size) {\n  $(\"#sg-viewport\").width(size);\n  $(\"#sg-gen-container\").width(size * 1 + 14);\n\n  updateSizeReading(size);\n}\n\n$('#sg-gen-container').on('touchstart', function (event) {});\n\n// handles widening the \"viewport\"\n//   1. on \"mousedown\" store the click location\n//   2. make a hidden div visible so that it can track mouse movements and make sure the pointer doesn't get lost in the iframe\n//   3. on \"mousemove\" calculate the math, save the results to a cookie, and update the viewport\n$('#sg-rightpull').mousedown(function (event) {\n\n  // capture default data\n  var origClientX = event.clientX;\n  var origViewportWidth = $sgViewport.width();\n\n  fullMode = false;\n\n  // show the cover\n  $(\"#sg-cover\").css(\"display\", \"block\");\n\n  // add the mouse move event and capture data. also update the viewport width\n  $('#sg-cover').mousemove(function (event) {\n    var viewportWidth;\n\n    viewportWidth = origViewportWidth + 2 * (event.clientX - origClientX);\n\n    if (viewportWidth > minViewportWidth) {\n\n      if (!DataSaver.findValue('vpWidth')) {\n        DataSaver.addValue(\"vpWidth\", viewportWidth);\n      } else {\n        DataSaver.updateValue(\"vpWidth\", viewportWidth);\n      }\n\n      sizeiframe(viewportWidth, false);\n    }\n  });\n\n  return false;\n});\n\n// on \"mouseup\" we unbind the \"mousemove\" event and hide the cover again\n$('body').mouseup(function () {\n  $('#sg-cover').unbind('mousemove');\n  $('#sg-cover').css(\"display\", \"none\");\n});\n\n// capture the viewport width that was loaded and modify it so it fits with the pull bar\nvar origViewportWidth = $(\"#sg-viewport\").width();\n$(\"#sg-gen-container\").width(origViewportWidth);\n\nvar testWidth = screen.width;\nif (window.orientation !== undefined) {\n  testWidth = window.orientation === 0 ? screen.width : screen.height;\n}\nif ($(window).width() == testWidth && 'ontouchstart' in document.documentElement && $(window).width() <= 1024) {\n  $(\"#sg-rightpull-container\").width(0);\n} else {\n  $(\"#sg-viewport\").width(origViewportWidth - 14);\n}\nupdateSizeReading($(\"#sg-viewport\").width());\n\n// get the request vars\nvar oGetVars = urlHandler.getRequestVars();\n\n// pre-load the viewport width\nvar vpWidth = 0;\nvar trackViewportWidth = true; // can toggle this feature on & off\n\nif (oGetVars.h !== undefined || oGetVars.hay !== undefined) {\n  startHay();\n} else if (oGetVars.d !== undefined || oGetVars.disco !== undefined) {\n  startDisco();\n} else if (oGetVars.w !== undefined || oGetVars.width !== undefined) {\n  vpWidth = oGetVars.w !== undefined ? oGetVars.w : oGetVars.width;\n  vpWidth = vpWidth.indexOf(\"em\") !== -1 ? Math.floor(Math.floor(vpWidth.replace(\"em\", \"\")) * $bodySize) : Math.floor(vpWidth.replace(\"px\", \"\"));\n  DataSaver.updateValue(\"vpWidth\", vpWidth);\n  updateViewportWidth(vpWidth);\n} else if (trackViewportWidth && (vpWidth = DataSaver.findValue(\"vpWidth\"))) {\n  updateViewportWidth(vpWidth);\n}\n\n// set up the defaults for the\nvar baseIframePath = window.location.protocol + \"//\" + window.location.host + window.location.pathname.replace(\"index.html\", \"\");\nvar patternName = config.defaultPattern !== undefined && typeof config.defaultPattern === 'string' && config.defaultPattern.trim().length > 0 ? config.defaultPattern : 'all';\nvar iFramePath = baseIframePath + \"styleguide/html/styleguide.html?\" + Date.now();\nif (oGetVars.p !== undefined || oGetVars.pattern !== undefined) {\n  patternName = oGetVars.p !== undefined ? oGetVars.p : oGetVars.pattern;\n}\n\nif (patternName !== \"all\") {\n  var patternPath = urlHandler.getFileName(patternName);\n  iFramePath = patternPath !== \"\" ? baseIframePath + patternPath + \"?\" + Date.now() : iFramePath;\n  document.getElementById(\"title\").innerHTML = \"Pattern Lab - \" + patternName;\n  history.replaceState({ \"pattern\": patternName }, null, null);\n}\n\nif (document.getElementById(\"sg-raw\") !== null) {\n  document.getElementById(\"sg-raw\").setAttribute(\"href\", urlHandler.getFileName(patternName));\n}\n\nurlHandler.skipBack = true;\ndocument.getElementById(\"sg-viewport\").contentWindow.location.replace(iFramePath);\n\n//Close all dropdowns and navigation\nfunction closePanels() {\n  $('.sg-nav-container, .sg-nav-toggle, .sg-acc-handle, .sg-acc-panel').removeClass('active');\n  patternFinder.closeFinder();\n}\n\n// update the iframe with the source from clicked element in pull down menu. also close the menu\n// having it outside fixes an auto-close bug i ran into\n$('a[data-patternpartial]').on(\"click\", function (e) {\n  e.preventDefault();\n  // update the iframe via the history api handler\n  var obj = JSON.stringify({ \"event\": \"patternLab.updatePath\", \"path\": urlHandler.getFileName($(this).attr(\"data-patternpartial\")) });\n  document.getElementById(\"sg-viewport\").contentWindow.postMessage(obj, urlHandler.targetOrigin);\n  closePanels();\n});\n\n// handle when someone clicks on the grey area of the viewport so it auto-closes the nav\n$('#sg-vp-wrap').click(function () {\n  closePanels();\n});\n\n// Listen for resize changes\nif (window.orientation !== undefined) {\n  var origOrientation = window.orientation;\n  window.addEventListener(\"orientationchange\", function () {\n    if (window.orientation != origOrientation) {\n      $(\"#sg-gen-container\").width($(window).width());\n      $(\"#sg-viewport\").width($(window).width());\n      updateSizeReading($(window).width());\n      origOrientation = window.orientation;\n    }\n  }, false);\n}\n\n// watch the iframe source so that it can be sent back to everyone else.\n// based on the great MDN docs at https://developer.mozilla.org/en-US/docs/Web/API/window.postMessage\nfunction receiveIframeMessage(event) {\n\n  // does the origin sending the message match the current host? if not dev/null the request\n  if (window.location.protocol !== \"file:\" && event.origin !== window.location.protocol + \"//\" + window.location.host) {\n    return;\n  }\n\n  var data = {};\n  try {\n    data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n  } catch (e) {}\n\n  if (data.event !== undefined) {\n\n    if (data.event == \"patternLab.pageLoad\") {\n\n      if (!urlHandler.skipBack) {\n\n        if (history.state === undefined || history.state === null || history.state.pattern !== data.patternpartial) {\n          urlHandler.pushPattern(data.patternpartial, data.path);\n        }\n\n        /*\n        if (wsnConnected) {\n          var iFramePath = urlHandler.getFileName(data.patternpartial);\n          wsn.send( '{\"url\": \"'+iFramePath+'\", \"patternpartial\": \"'+event.data.patternpartial+'\" }' );\n        }\n        */\n      }\n\n      // reset the defaults\n      urlHandler.skipBack = false;\n    } else if (data.event == \"patternLab.keyPress\") {\n      if (data.keyPress == 'ctrl+shift+s') {\n        goSmall();\n      } else if (data.keyPress == 'ctrl+shift+m') {\n        goMedium();\n      } else if (data.keyPress == 'ctrl+shift+l') {\n        goLarge();\n      } else if (data.keyPress == 'ctrl+shift+d') {\n        if (!discoMode) {\n          startDisco();\n        } else {\n          killDisco();\n        }\n      } else if (data.keyPress == 'ctrl+shift+h') {\n        if (!hayMode) {\n          startHay();\n        } else {\n          killHay();\n        }\n      } else if (data.keyPress == 'ctrl+shift+0') {\n        sizeiframe(320, true);\n      } else if (found == data.keyPress.match(/ctrl\\+shift\\+([1-9])/)) {\n        var val = mqs[found[1] - 1];\n        var type = val.indexOf(\"px\") !== -1 ? \"px\" : \"em\";\n        val = val.replace(type, \"\");\n        var width = type === \"px\" ? val * 1 : val * $bodySize;\n        sizeiframe(width, true);\n      }\n      return false;\n    }\n  }\n}\nwindow.addEventListener(\"message\", receiveIframeMessage, false);\n\n// })(this);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/styleguide/index.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nrequire('data-saver');\nrequire('layout');\nrequire('modal-viewer');\nrequire('panels');\nrequire('panels-util');\nrequire('panels-viewer');\nrequire('pattern-finder');\nrequire('plugin-loader');\nrequire('postmessage');\nrequire('prism/prism-languages');\nrequire('styleguide');\nrequire('url-handler');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/patternlab-viewer.js\n// module id = 13\n// module chunks = 0","\"use strict\";\n\n/*!\n * Simple Layout Rendering for Pattern Lab\n *\n * Copyright (c) 2014 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * @requires ../../node_modules/twig/twig.js\n */\n\nvar Twig = require('twig');\n\ntry {\n  // Prep Twig for rendering.\n  var twig = Twig.twig;\n\n  // load the inlined Pattern Nav and ish controls templates\n  var patternNavTemplate = document.getElementById(\"pl-pattern-nav-template\").innerHTML,\n      ishControlsTemplate = document.getElementById(\"pl-ish-controls-template\").innerHTML;\n\n  // Grab the two targets for injecting the rendered templates back onto the page.\n  var patternLabNavTarget = document.getElementById(\"pl-pattern-nav-target\"),\n      sgControlsTarget = document.getElementById(\"sg-controls\");\n\n  var patternNavRendered, patternNavTwigTemplate, ishTemplateCompiled, ishTemplateRendered;\n\n  // Assign the Pattern Nav template code to a Twig instance.\n  patternNavTwigTemplate = twig({\n    data: patternNavTemplate\n  });\n\n  // Render the twig template with the global navItems data available on the window. TODO: make sure this exists before assuming Twig can render something.\n  patternNavRendered = patternNavTwigTemplate.render(navItems);\n\n  // load the inlined ish Controls template\n  // var ishTemplate         = ishControlsTemplate.innerHTML;\n  ishTemplateCompiled = Hogan.compile(ishControlsTemplate);\n  ishTemplateRendered = ishTemplateCompiled.render(ishControls);\n\n  // Inject the rendered Twig templates back onto the page\n  patternLabNavTarget.innerHTML = patternNavRendered, sgControlsTarget.innerHTML = ishTemplateRendered;\n} catch (e) {\n\n  var message = \"<h1>Nothing Here Yet</h1><p>Please generate your site before trying to view it.</p>\";\n  document.getElementById(\"pl-pattern-nav-target\").innerHTML = message;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/layout/index.js\n// module id = 14\n// module chunks = 0","'use strict';\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif (typeof exports === 'object' && typeof module === 'object') module.exports = factory(function webpackLoadOptionalExternalModule() {\n\t\ttry {\n\t\t\treturn require(\"fs\");\n\t\t} catch (e) {}\n\t}(), require(\"path\"));else if (typeof define === 'function' && define.amd) define([\"fs\", \"path\"], factory);else if (typeof exports === 'object') exports[\"Twig\"] = factory(function webpackLoadOptionalExternalModule() {\n\t\ttry {\n\t\t\treturn require(\"fs\");\n\t\t} catch (e) {}\n\t}(), require(\"path\"));else root[\"Twig\"] = factory(root[\"fs\"], root[\"path\"]);\n})(undefined, function (__WEBPACK_EXTERNAL_MODULE_19__, __WEBPACK_EXTERNAL_MODULE_20__) {\n\treturn (/******/function (modules) {\n\t\t\t// webpackBootstrap\n\t\t\t/******/ // The module cache\n\t\t\t/******/var installedModules = {};\n\n\t\t\t/******/ // The require function\n\t\t\t/******/function __webpack_require__(moduleId) {\n\n\t\t\t\t/******/ // Check if module is in cache\n\t\t\t\t/******/if (installedModules[moduleId])\n\t\t\t\t\t/******/return installedModules[moduleId].exports;\n\n\t\t\t\t/******/ // Create a new module (and put it into the cache)\n\t\t\t\t/******/var module = installedModules[moduleId] = {\n\t\t\t\t\t/******/exports: {},\n\t\t\t\t\t/******/id: moduleId,\n\t\t\t\t\t/******/loaded: false\n\t\t\t\t\t/******/ };\n\n\t\t\t\t/******/ // Execute the module function\n\t\t\t\t/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t\t\t\t/******/ // Flag the module as loaded\n\t\t\t\t/******/module.loaded = true;\n\n\t\t\t\t/******/ // Return the exports of the module\n\t\t\t\t/******/return module.exports;\n\t\t\t\t/******/\n\t\t\t}\n\n\t\t\t/******/ // expose the modules object (__webpack_modules__)\n\t\t\t/******/__webpack_require__.m = modules;\n\n\t\t\t/******/ // expose the module cache\n\t\t\t/******/__webpack_require__.c = installedModules;\n\n\t\t\t/******/ // __webpack_public_path__\n\t\t\t/******/__webpack_require__.p = \"\";\n\n\t\t\t/******/ // Load entry module and return exports\n\t\t\t/******/return __webpack_require__(0);\n\t\t\t/******/\n\t\t}(\n\t\t/************************************************************************/\n\t\t/******/[\n\t\t/* 0 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t/**\n    * Twig.js\n    *\n    * @copyright 2011-2016 John Roepke and the Twig.js Contributors\n    * @license   Available under the BSD 2-Clause License\n    * @link      https://github.com/twigjs/twig.js\n    */\n\n\t\t\tvar Twig = {\n\t\t\t\tVERSION: '0.10.2'\n\t\t\t};\n\n\t\t\t__webpack_require__(1)(Twig);\n\t\t\t__webpack_require__(2)(Twig);\n\t\t\t__webpack_require__(3)(Twig);\n\t\t\t__webpack_require__(5)(Twig);\n\t\t\t__webpack_require__(6)(Twig);\n\t\t\t__webpack_require__(7)(Twig);\n\t\t\t__webpack_require__(17)(Twig);\n\t\t\t__webpack_require__(18)(Twig);\n\t\t\t__webpack_require__(21)(Twig);\n\t\t\t__webpack_require__(22)(Twig);\n\t\t\t__webpack_require__(23)(Twig);\n\t\t\t__webpack_require__(24)(Twig);\n\t\t\t__webpack_require__(25)(Twig);\n\t\t\t__webpack_require__(26)(Twig);\n\t\t\t__webpack_require__(27)(Twig);\n\n\t\t\tmodule.exports = Twig.exports;\n\n\t\t\t/***/\n\t\t},\n\t\t/* 1 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.core.js\n\t\t\t//\n\t\t\t// This file handles template level tokenizing, compiling and parsing.\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\tTwig.trace = false;\n\t\t\t\tTwig.debug = false;\n\n\t\t\t\t// Default caching to true for the improved performance it offers\n\t\t\t\tTwig.cache = true;\n\n\t\t\t\tTwig.noop = function () {};\n\n\t\t\t\tTwig.placeholders = {\n\t\t\t\t\tparent: \"{{|PARENT|}}\"\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Fallback for Array.indexOf for IE8 et al\n     */\n\t\t\t\tTwig.indexOf = function (arr, searchElement /*, fromIndex */) {\n\t\t\t\t\tif (Array.prototype.hasOwnProperty(\"indexOf\")) {\n\t\t\t\t\t\treturn arr.indexOf(searchElement);\n\t\t\t\t\t}\n\t\t\t\t\tif (arr === void 0 || arr === null) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t\tvar t = Object(arr);\n\t\t\t\t\tvar len = t.length >>> 0;\n\t\t\t\t\tif (len === 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tvar n = 0;\n\t\t\t\t\tif (arguments.length > 0) {\n\t\t\t\t\t\tn = Number(arguments[1]);\n\t\t\t\t\t\tif (n !== n) {\n\t\t\t\t\t\t\t// shortcut for verifying if it's NaN\n\t\t\t\t\t\t\tn = 0;\n\t\t\t\t\t\t} else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n\t\t\t\t\t\t\tn = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (n >= len) {\n\t\t\t\t\t\t// console.log(\"indexOf not found1 \", JSON.stringify(searchElement), JSON.stringify(arr));\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tvar k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\t\t\t\t\tfor (; k < len; k++) {\n\t\t\t\t\t\tif (k in t && t[k] === searchElement) {\n\t\t\t\t\t\t\treturn k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (arr == searchElement) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(\"indexOf not found2 \", JSON.stringify(searchElement), JSON.stringify(arr));\n\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\n\t\t\t\tTwig.forEach = function (arr, callback, thisArg) {\n\t\t\t\t\tif (Array.prototype.forEach) {\n\t\t\t\t\t\treturn arr.forEach(callback, thisArg);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar T, k;\n\n\t\t\t\t\tif (arr == null) {\n\t\t\t\t\t\tthrow new TypeError(\" this is null or not defined\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// 1. Let O be the result of calling ToObject passing the |this| value as the argument.\n\t\t\t\t\tvar O = Object(arr);\n\n\t\t\t\t\t// 2. Let lenValue be the result of calling the Get internal method of O with the argument \"length\".\n\t\t\t\t\t// 3. Let len be ToUint32(lenValue).\n\t\t\t\t\tvar len = O.length >>> 0; // Hack to convert O.length to a UInt32\n\n\t\t\t\t\t// 4. If IsCallable(callback) is false, throw a TypeError exception.\n\t\t\t\t\t// See: http://es5.github.com/#x9.11\n\t\t\t\t\tif ({}.toString.call(callback) != \"[object Function]\") {\n\t\t\t\t\t\tthrow new TypeError(callback + \" is not a function\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n\t\t\t\t\tif (thisArg) {\n\t\t\t\t\t\tT = thisArg;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6. Let k be 0\n\t\t\t\t\tk = 0;\n\n\t\t\t\t\t// 7. Repeat, while k < len\n\t\t\t\t\twhile (k < len) {\n\n\t\t\t\t\t\tvar kValue;\n\n\t\t\t\t\t\t// a. Let Pk be ToString(k).\n\t\t\t\t\t\t//   This is implicit for LHS operands of the in operator\n\t\t\t\t\t\t// b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.\n\t\t\t\t\t\t//   This step can be combined with c\n\t\t\t\t\t\t// c. If kPresent is true, then\n\t\t\t\t\t\tif (k in O) {\n\n\t\t\t\t\t\t\t// i. Let kValue be the result of calling the Get internal method of O with argument Pk.\n\t\t\t\t\t\t\tkValue = O[k];\n\n\t\t\t\t\t\t\t// ii. Call the Call internal method of callback with T as the this value and\n\t\t\t\t\t\t\t// argument list containing kValue, k, and O.\n\t\t\t\t\t\t\tcallback.call(T, kValue, k, O);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// d. Increase k by 1.\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\t// 8. return undefined\n\t\t\t\t};\n\n\t\t\t\tTwig.merge = function (target, source, onlyChanged) {\n\t\t\t\t\tTwig.forEach(Object.keys(source), function (key) {\n\t\t\t\t\t\tif (onlyChanged && !(key in target)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget[key] = source[key];\n\t\t\t\t\t});\n\n\t\t\t\t\treturn target;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Exception thrown by twig.js.\n     */\n\t\t\t\tTwig.Error = function (message, file) {\n\t\t\t\t\tthis.message = message;\n\t\t\t\t\tthis.name = \"TwigException\";\n\t\t\t\t\tthis.type = \"TwigException\";\n\t\t\t\t\tthis.file = file;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Get the string representation of a Twig error.\n     */\n\t\t\t\tTwig.Error.prototype.toString = function () {\n\t\t\t\t\tvar output = this.name + \": \" + this.message;\n\n\t\t\t\t\treturn output;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Wrapper for logging to the console.\n     */\n\t\t\t\tTwig.log = {\n\t\t\t\t\ttrace: function () {\n\t\t\t\t\t\tif (Twig.trace && console) {\n\t\t\t\t\t\t\tconsole.log(Array.prototype.slice.call(arguments));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdebug: function () {\n\t\t\t\t\t\tif (Twig.debug && console) {\n\t\t\t\t\t\t\tconsole.log(Array.prototype.slice.call(arguments));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (typeof console !== \"undefined\") {\n\t\t\t\t\tif (typeof console.error !== \"undefined\") {\n\t\t\t\t\t\tTwig.log.error = function () {\n\t\t\t\t\t\t\tconsole.error.apply(console, arguments);\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (typeof console.log !== \"undefined\") {\n\t\t\t\t\t\tTwig.log.error = function () {\n\t\t\t\t\t\t\tconsole.log.apply(console, arguments);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tTwig.log.error = function () {};\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Wrapper for child context objects in Twig.\n     *\n     * @param {Object} context Values to initialize the context with.\n     */\n\t\t\t\tTwig.ChildContext = function (context) {\n\t\t\t\t\tvar ChildContext = function ChildContext() {};\n\t\t\t\t\tChildContext.prototype = context;\n\t\t\t\t\treturn new ChildContext();\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Container for methods related to handling high level template tokens\n     *      (for example: {{ expression }}, {% logic %}, {# comment #}, raw data)\n     */\n\t\t\t\tTwig.token = {};\n\n\t\t\t\t/**\n     * Token types.\n     */\n\t\t\t\tTwig.token.type = {\n\t\t\t\t\toutput: 'output',\n\t\t\t\t\tlogic: 'logic',\n\t\t\t\t\tcomment: 'comment',\n\t\t\t\t\traw: 'raw',\n\t\t\t\t\toutput_whitespace_pre: 'output_whitespace_pre',\n\t\t\t\t\toutput_whitespace_post: 'output_whitespace_post',\n\t\t\t\t\toutput_whitespace_both: 'output_whitespace_both',\n\t\t\t\t\tlogic_whitespace_pre: 'logic_whitespace_pre',\n\t\t\t\t\tlogic_whitespace_post: 'logic_whitespace_post',\n\t\t\t\t\tlogic_whitespace_both: 'logic_whitespace_both'\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Token syntax definitions.\n     */\n\t\t\t\tTwig.token.definitions = [{\n\t\t\t\t\ttype: Twig.token.type.raw,\n\t\t\t\t\topen: '{% raw %}',\n\t\t\t\t\tclose: '{% endraw %}'\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.token.type.raw,\n\t\t\t\t\topen: '{% verbatim %}',\n\t\t\t\t\tclose: '{% endverbatim %}'\n\t\t\t\t},\n\t\t\t\t// *Whitespace type tokens*\n\t\t\t\t//\n\t\t\t\t// These typically take the form `{{- expression -}}` or `{{- expression }}` or `{{ expression -}}`.\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.token.type.output_whitespace_pre,\n\t\t\t\t\topen: '{{-',\n\t\t\t\t\tclose: '}}'\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.token.type.output_whitespace_post,\n\t\t\t\t\topen: '{{',\n\t\t\t\t\tclose: '-}}'\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.token.type.output_whitespace_both,\n\t\t\t\t\topen: '{{-',\n\t\t\t\t\tclose: '-}}'\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.token.type.logic_whitespace_pre,\n\t\t\t\t\topen: '{%-',\n\t\t\t\t\tclose: '%}'\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.token.type.logic_whitespace_post,\n\t\t\t\t\topen: '{%',\n\t\t\t\t\tclose: '-%}'\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.token.type.logic_whitespace_both,\n\t\t\t\t\topen: '{%-',\n\t\t\t\t\tclose: '-%}'\n\t\t\t\t},\n\t\t\t\t// *Output type tokens*\n\t\t\t\t//\n\t\t\t\t// These typically take the form `{{ expression }}`.\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.token.type.output,\n\t\t\t\t\topen: '{{',\n\t\t\t\t\tclose: '}}'\n\t\t\t\t},\n\t\t\t\t// *Logic type tokens*\n\t\t\t\t//\n\t\t\t\t// These typically take a form like `{% if expression %}` or `{% endif %}`\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.token.type.logic,\n\t\t\t\t\topen: '{%',\n\t\t\t\t\tclose: '%}'\n\t\t\t\t},\n\t\t\t\t// *Comment type tokens*\n\t\t\t\t//\n\t\t\t\t// These take the form `{# anything #}`\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.token.type.comment,\n\t\t\t\t\topen: '{#',\n\t\t\t\t\tclose: '#}'\n\t\t\t\t}];\n\n\t\t\t\t/**\n     * What characters start \"strings\" in token definitions. We need this to ignore token close\n     * strings inside an expression.\n     */\n\t\t\t\tTwig.token.strings = ['\"', \"'\"];\n\n\t\t\t\tTwig.token.findStart = function (template) {\n\t\t\t\t\tvar output = {\n\t\t\t\t\t\tposition: null,\n\t\t\t\t\t\tclose_position: null,\n\t\t\t\t\t\tdef: null\n\t\t\t\t\t},\n\t\t\t\t\t    i,\n\t\t\t\t\t    token_template,\n\t\t\t\t\t    first_key_position,\n\t\t\t\t\t    close_key_position;\n\n\t\t\t\t\tfor (i = 0; i < Twig.token.definitions.length; i++) {\n\t\t\t\t\t\ttoken_template = Twig.token.definitions[i];\n\t\t\t\t\t\tfirst_key_position = template.indexOf(token_template.open);\n\t\t\t\t\t\tclose_key_position = template.indexOf(token_template.close);\n\n\t\t\t\t\t\tTwig.log.trace(\"Twig.token.findStart: \", \"Searching for \", token_template.open, \" found at \", first_key_position);\n\n\t\t\t\t\t\t//Special handling for mismatched tokens\n\t\t\t\t\t\tif (first_key_position >= 0) {\n\t\t\t\t\t\t\t//This token matches the template\n\t\t\t\t\t\t\tif (token_template.open.length !== token_template.close.length) {\n\t\t\t\t\t\t\t\t//This token has mismatched closing and opening tags\n\t\t\t\t\t\t\t\tif (close_key_position < 0) {\n\t\t\t\t\t\t\t\t\t//This token's closing tag does not match the template\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Does this token occur before any other types?\n\t\t\t\t\t\tif (first_key_position >= 0 && (output.position === null || first_key_position < output.position)) {\n\t\t\t\t\t\t\toutput.position = first_key_position;\n\t\t\t\t\t\t\toutput.def = token_template;\n\t\t\t\t\t\t\toutput.close_position = close_key_position;\n\t\t\t\t\t\t} else if (first_key_position >= 0 && output.position !== null && first_key_position === output.position) {\n\t\t\t\t\t\t\t/*This token exactly matches another token,\n       greedily match to check if this token has a greater specificity*/\n\t\t\t\t\t\t\tif (token_template.open.length > output.def.open.length) {\n\t\t\t\t\t\t\t\t//This token's opening tag is more specific than the previous match\n\t\t\t\t\t\t\t\toutput.position = first_key_position;\n\t\t\t\t\t\t\t\toutput.def = token_template;\n\t\t\t\t\t\t\t\toutput.close_position = close_key_position;\n\t\t\t\t\t\t\t} else if (token_template.open.length === output.def.open.length) {\n\t\t\t\t\t\t\t\tif (token_template.close.length > output.def.close.length) {\n\t\t\t\t\t\t\t\t\t//This token's opening tag is as specific as the previous match,\n\t\t\t\t\t\t\t\t\t//but the closing tag has greater specificity\n\t\t\t\t\t\t\t\t\tif (close_key_position >= 0 && close_key_position < output.close_position) {\n\t\t\t\t\t\t\t\t\t\t//This token's closing tag exists in the template,\n\t\t\t\t\t\t\t\t\t\t//and it occurs sooner than the previous match\n\t\t\t\t\t\t\t\t\t\toutput.position = first_key_position;\n\t\t\t\t\t\t\t\t\t\toutput.def = token_template;\n\t\t\t\t\t\t\t\t\t\toutput.close_position = close_key_position;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (close_key_position >= 0 && close_key_position < output.close_position) {\n\t\t\t\t\t\t\t\t\t//This token's closing tag is not more specific than the previous match,\n\t\t\t\t\t\t\t\t\t//but it occurs sooner than the previous match\n\t\t\t\t\t\t\t\t\toutput.position = first_key_position;\n\t\t\t\t\t\t\t\t\toutput.def = token_template;\n\t\t\t\t\t\t\t\t\toutput.close_position = close_key_position;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete output['close_position'];\n\n\t\t\t\t\treturn output;\n\t\t\t\t};\n\n\t\t\t\tTwig.token.findEnd = function (template, token_def, start) {\n\t\t\t\t\tvar end = null,\n\t\t\t\t\t    found = false,\n\t\t\t\t\t    offset = 0,\n\n\n\t\t\t\t\t// String position variables\n\t\t\t\t\tstr_pos = null,\n\t\t\t\t\t    str_found = null,\n\t\t\t\t\t    pos = null,\n\t\t\t\t\t    end_offset = null,\n\t\t\t\t\t    this_str_pos = null,\n\t\t\t\t\t    end_str_pos = null,\n\n\n\t\t\t\t\t// For loop variables\n\t\t\t\t\ti,\n\t\t\t\t\t    l;\n\n\t\t\t\t\twhile (!found) {\n\t\t\t\t\t\tstr_pos = null;\n\t\t\t\t\t\tstr_found = null;\n\t\t\t\t\t\tpos = template.indexOf(token_def.close, offset);\n\n\t\t\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t\t\tend = pos;\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// throw an exception\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Unable to find closing bracket '\" + token_def.close + \"'\" + \" opened near template position \" + start);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore quotes within comments; just look for the next comment close sequence,\n\t\t\t\t\t\t// regardless of what comes before it. https://github.com/justjohn/twig.js/issues/95\n\t\t\t\t\t\tif (token_def.type === Twig.token.type.comment) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Ignore quotes within raw tag\n\t\t\t\t\t\t// Fixes #283\n\t\t\t\t\t\tif (token_def.type === Twig.token.type.raw) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tl = Twig.token.strings.length;\n\t\t\t\t\t\tfor (i = 0; i < l; i += 1) {\n\t\t\t\t\t\t\tthis_str_pos = template.indexOf(Twig.token.strings[i], offset);\n\n\t\t\t\t\t\t\tif (this_str_pos > 0 && this_str_pos < pos && (str_pos === null || this_str_pos < str_pos)) {\n\t\t\t\t\t\t\t\tstr_pos = this_str_pos;\n\t\t\t\t\t\t\t\tstr_found = Twig.token.strings[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We found a string before the end of the token, now find the string's end and set the search offset to it\n\t\t\t\t\t\tif (str_pos !== null) {\n\t\t\t\t\t\t\tend_offset = str_pos + 1;\n\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tend_str_pos = template.indexOf(str_found, end_offset);\n\t\t\t\t\t\t\t\tif (end_str_pos < 0) {\n\t\t\t\t\t\t\t\t\tthrow \"Unclosed string in template\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Ignore escaped quotes\n\t\t\t\t\t\t\t\tif (template.substr(end_str_pos - 1, 1) !== \"\\\\\") {\n\t\t\t\t\t\t\t\t\toffset = end_str_pos + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tend_offset = end_str_pos + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn end;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Convert a template into high-level tokens.\n     */\n\t\t\t\tTwig.tokenize = function (template) {\n\t\t\t\t\tvar tokens = [],\n\n\t\t\t\t\t// An offset for reporting errors locations in the template.\n\t\t\t\t\terror_offset = 0,\n\n\n\t\t\t\t\t// The start and type of the first token found in the template.\n\t\t\t\t\tfound_token = null,\n\n\t\t\t\t\t// The end position of the matched token.\n\t\t\t\t\tend = null;\n\n\t\t\t\t\twhile (template.length > 0) {\n\t\t\t\t\t\t// Find the first occurance of any token type in the template\n\t\t\t\t\t\tfound_token = Twig.token.findStart(template);\n\n\t\t\t\t\t\tTwig.log.trace(\"Twig.tokenize: \", \"Found token: \", found_token);\n\n\t\t\t\t\t\tif (found_token.position !== null) {\n\t\t\t\t\t\t\t// Add a raw type token for anything before the start of the token\n\t\t\t\t\t\t\tif (found_token.position > 0) {\n\t\t\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\t\t\ttype: Twig.token.type.raw,\n\t\t\t\t\t\t\t\t\tvalue: template.substring(0, found_token.position)\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttemplate = template.substr(found_token.position + found_token.def.open.length);\n\t\t\t\t\t\t\terror_offset += found_token.position + found_token.def.open.length;\n\n\t\t\t\t\t\t\t// Find the end of the token\n\t\t\t\t\t\t\tend = Twig.token.findEnd(template, found_token.def, error_offset);\n\n\t\t\t\t\t\t\tTwig.log.trace(\"Twig.tokenize: \", \"Token ends at \", end);\n\n\t\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\t\ttype: found_token.def.type,\n\t\t\t\t\t\t\t\tvalue: template.substring(0, end).trim()\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (template.substr(end + found_token.def.close.length, 1) === \"\\n\") {\n\t\t\t\t\t\t\t\tswitch (found_token.def.type) {\n\t\t\t\t\t\t\t\t\tcase \"logic_whitespace_pre\":\n\t\t\t\t\t\t\t\t\tcase \"logic_whitespace_post\":\n\t\t\t\t\t\t\t\t\tcase \"logic_whitespace_both\":\n\t\t\t\t\t\t\t\t\tcase \"logic\":\n\t\t\t\t\t\t\t\t\t\t// Newlines directly after logic tokens are ignored\n\t\t\t\t\t\t\t\t\t\tend += 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttemplate = template.substr(end + found_token.def.close.length);\n\n\t\t\t\t\t\t\t// Increment the position in the template\n\t\t\t\t\t\t\terror_offset += end + found_token.def.close.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// No more tokens -> add the rest of the template as a raw-type token\n\t\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\t\ttype: Twig.token.type.raw,\n\t\t\t\t\t\t\t\tvalue: template\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\ttemplate = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t};\n\n\t\t\t\tTwig.compile = function (tokens) {\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\t// Output and intermediate stacks\n\t\t\t\t\t\tvar output = [],\n\t\t\t\t\t\t    stack = [],\n\n\t\t\t\t\t\t// The tokens between open and close tags\n\t\t\t\t\t\tintermediate_output = [],\n\t\t\t\t\t\t    token = null,\n\t\t\t\t\t\t    logic_token = null,\n\t\t\t\t\t\t    unclosed_token = null,\n\n\t\t\t\t\t\t// Temporary previous token.\n\t\t\t\t\t\tprev_token = null,\n\n\t\t\t\t\t\t// Temporary previous output.\n\t\t\t\t\t\tprev_output = null,\n\n\t\t\t\t\t\t// Temporary previous intermediate output.\n\t\t\t\t\t\tprev_intermediate_output = null,\n\n\t\t\t\t\t\t// The previous token's template\n\t\t\t\t\t\tprev_template = null,\n\n\t\t\t\t\t\t// Token lookahead\n\t\t\t\t\t\tnext_token = null,\n\n\t\t\t\t\t\t// The output token\n\t\t\t\t\t\ttok_output = null,\n\n\n\t\t\t\t\t\t// Logic Token values\n\t\t\t\t\t\ttype = null,\n\t\t\t\t\t\t    open = null,\n\t\t\t\t\t\t    next = null;\n\n\t\t\t\t\t\tvar compile_output = function (token) {\n\t\t\t\t\t\t\tTwig.expression.compile.apply(this, [token]);\n\t\t\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\t\t\tintermediate_output.push(token);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar compile_logic = function (token) {\n\t\t\t\t\t\t\t// Compile the logic token\n\t\t\t\t\t\t\tlogic_token = Twig.logic.compile.apply(this, [token]);\n\n\t\t\t\t\t\t\ttype = logic_token.type;\n\t\t\t\t\t\t\topen = Twig.logic.handler[type].open;\n\t\t\t\t\t\t\tnext = Twig.logic.handler[type].next;\n\n\t\t\t\t\t\t\tTwig.log.trace(\"Twig.compile: \", \"Compiled logic token to \", logic_token, \" next is: \", next, \" open is : \", open);\n\n\t\t\t\t\t\t\t// Not a standalone token, check logic stack to see if this is expected\n\t\t\t\t\t\t\tif (open !== undefined && !open) {\n\t\t\t\t\t\t\t\tprev_token = stack.pop();\n\t\t\t\t\t\t\t\tprev_template = Twig.logic.handler[prev_token.type];\n\n\t\t\t\t\t\t\t\tif (Twig.indexOf(prev_template.next, type) < 0) {\n\t\t\t\t\t\t\t\t\tthrow new Error(type + \" not expected after a \" + prev_token.type);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tprev_token.output = prev_token.output || [];\n\n\t\t\t\t\t\t\t\tprev_token.output = prev_token.output.concat(intermediate_output);\n\t\t\t\t\t\t\t\tintermediate_output = [];\n\n\t\t\t\t\t\t\t\ttok_output = {\n\t\t\t\t\t\t\t\t\ttype: Twig.token.type.logic,\n\t\t\t\t\t\t\t\t\ttoken: prev_token\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\t\t\t\tintermediate_output.push(tok_output);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\toutput.push(tok_output);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// This token requires additional tokens to complete the logic structure.\n\t\t\t\t\t\t\tif (next !== undefined && next.length > 0) {\n\t\t\t\t\t\t\t\tTwig.log.trace(\"Twig.compile: \", \"Pushing \", logic_token, \" to logic stack.\");\n\n\t\t\t\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\t\t\t\t// Put any currently held output into the output list of the logic operator\n\t\t\t\t\t\t\t\t\t// currently at the head of the stack before we push a new one on.\n\t\t\t\t\t\t\t\t\tprev_token = stack.pop();\n\t\t\t\t\t\t\t\t\tprev_token.output = prev_token.output || [];\n\t\t\t\t\t\t\t\t\tprev_token.output = prev_token.output.concat(intermediate_output);\n\t\t\t\t\t\t\t\t\tstack.push(prev_token);\n\t\t\t\t\t\t\t\t\tintermediate_output = [];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Push the new logic token onto the logic stack\n\t\t\t\t\t\t\t\tstack.push(logic_token);\n\t\t\t\t\t\t\t} else if (open !== undefined && open) {\n\t\t\t\t\t\t\t\ttok_output = {\n\t\t\t\t\t\t\t\t\ttype: Twig.token.type.logic,\n\t\t\t\t\t\t\t\t\ttoken: logic_token\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t// Standalone token (like {% set ... %}\n\t\t\t\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\t\t\t\tintermediate_output.push(tok_output);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\toutput.push(tok_output);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\twhile (tokens.length > 0) {\n\t\t\t\t\t\t\ttoken = tokens.shift();\n\t\t\t\t\t\t\tprev_output = output[output.length - 1];\n\t\t\t\t\t\t\tprev_intermediate_output = intermediate_output[intermediate_output.length - 1];\n\t\t\t\t\t\t\tnext_token = tokens[0];\n\t\t\t\t\t\t\tTwig.log.trace(\"Compiling token \", token);\n\t\t\t\t\t\t\tswitch (token.type) {\n\t\t\t\t\t\t\t\tcase Twig.token.type.raw:\n\t\t\t\t\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\t\t\t\t\tintermediate_output.push(token);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase Twig.token.type.logic:\n\t\t\t\t\t\t\t\t\tcompile_logic.call(this, token);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// Do nothing, comments should be ignored\n\t\t\t\t\t\t\t\tcase Twig.token.type.comment:\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase Twig.token.type.output:\n\t\t\t\t\t\t\t\t\tcompile_output.call(this, token);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t//Kill whitespace ahead and behind this token\n\t\t\t\t\t\t\t\tcase Twig.token.type.logic_whitespace_pre:\n\t\t\t\t\t\t\t\tcase Twig.token.type.logic_whitespace_post:\n\t\t\t\t\t\t\t\tcase Twig.token.type.logic_whitespace_both:\n\t\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_pre:\n\t\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_post:\n\t\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_both:\n\t\t\t\t\t\t\t\t\tif (token.type !== Twig.token.type.output_whitespace_post && token.type !== Twig.token.type.logic_whitespace_post) {\n\t\t\t\t\t\t\t\t\t\tif (prev_output) {\n\t\t\t\t\t\t\t\t\t\t\t//If the previous output is raw, pop it off\n\t\t\t\t\t\t\t\t\t\t\tif (prev_output.type === Twig.token.type.raw) {\n\t\t\t\t\t\t\t\t\t\t\t\toutput.pop();\n\n\t\t\t\t\t\t\t\t\t\t\t\t//If the previous output is not just whitespace, trim it\n\t\t\t\t\t\t\t\t\t\t\t\tif (prev_output.value.match(/^\\s*$/) === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tprev_output.value = prev_output.value.trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t//Repush the previous output\n\t\t\t\t\t\t\t\t\t\t\t\t\toutput.push(prev_output);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (prev_intermediate_output) {\n\t\t\t\t\t\t\t\t\t\t\t//If the previous intermediate output is raw, pop it off\n\t\t\t\t\t\t\t\t\t\t\tif (prev_intermediate_output.type === Twig.token.type.raw) {\n\t\t\t\t\t\t\t\t\t\t\t\tintermediate_output.pop();\n\n\t\t\t\t\t\t\t\t\t\t\t\t//If the previous output is not just whitespace, trim it\n\t\t\t\t\t\t\t\t\t\t\t\tif (prev_intermediate_output.value.match(/^\\s*$/) === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tprev_intermediate_output.value = prev_intermediate_output.value.trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t//Repush the previous intermediate output\n\t\t\t\t\t\t\t\t\t\t\t\t\tintermediate_output.push(prev_intermediate_output);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//Compile this token\n\t\t\t\t\t\t\t\t\tswitch (token.type) {\n\t\t\t\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_pre:\n\t\t\t\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_post:\n\t\t\t\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_both:\n\t\t\t\t\t\t\t\t\t\t\tcompile_output.call(this, token);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase Twig.token.type.logic_whitespace_pre:\n\t\t\t\t\t\t\t\t\t\tcase Twig.token.type.logic_whitespace_post:\n\t\t\t\t\t\t\t\t\t\tcase Twig.token.type.logic_whitespace_both:\n\t\t\t\t\t\t\t\t\t\t\tcompile_logic.call(this, token);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (token.type !== Twig.token.type.output_whitespace_pre && token.type !== Twig.token.type.logic_whitespace_pre) {\n\t\t\t\t\t\t\t\t\t\tif (next_token) {\n\t\t\t\t\t\t\t\t\t\t\t//If the next token is raw, shift it out\n\t\t\t\t\t\t\t\t\t\t\tif (next_token.type === Twig.token.type.raw) {\n\t\t\t\t\t\t\t\t\t\t\t\ttokens.shift();\n\n\t\t\t\t\t\t\t\t\t\t\t\t//If the next token is not just whitespace, trim it\n\t\t\t\t\t\t\t\t\t\t\t\tif (next_token.value.match(/^\\s*$/) === null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnext_token.value = next_token.value.trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t//Unshift the next token\n\t\t\t\t\t\t\t\t\t\t\t\t\ttokens.unshift(next_token);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tTwig.log.trace(\"Twig.compile: \", \" Output: \", output, \" Logic Stack: \", stack, \" Pending Output: \", intermediate_output);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Verify that there are no logic tokens left in the stack.\n\t\t\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\t\t\tunclosed_token = stack.pop();\n\t\t\t\t\t\t\tthrow new Error(\"Unable to find an end tag for \" + unclosed_token.type + \", expecting one of \" + unclosed_token.next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn output;\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tif (this.options.rethrow) {\n\t\t\t\t\t\t\tif (ex.type == 'TwigException' && !ex.file) {\n\t\t\t\t\t\t\t\tex.file = this.id;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tTwig.log.error(\"Error compiling twig template \" + this.id + \": \");\n\t\t\t\t\t\t\tif (ex.stack) {\n\t\t\t\t\t\t\t\tTwig.log.error(ex.stack);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tTwig.log.error(ex.toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Parse a compiled template.\n     *\n     * @param {Array} tokens The compiled tokens.\n     * @param {Object} context The render context.\n     *\n     * @return {string} The parsed template.\n     */\n\t\t\t\tTwig.parse = function (tokens, context, allow_async) {\n\t\t\t\t\tvar that = this,\n\t\t\t\t\t    output = [],\n\n\n\t\t\t\t\t// Store any error that might be thrown by the promise chain.\n\t\t\t\t\terr = null,\n\n\n\t\t\t\t\t// This will be set to is_async if template renders synchronously\n\t\t\t\t\tis_async = true,\n\t\t\t\t\t    promise = null,\n\n\n\t\t\t\t\t// Track logic chains\n\t\t\t\t\tchain = true;\n\n\t\t\t\t\tfunction handleException(ex) {\n\t\t\t\t\t\tif (that.options.rethrow) {\n\t\t\t\t\t\t\tif (typeof ex === 'string') {\n\t\t\t\t\t\t\t\tex = new Twig.Error(ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (ex.type == 'TwigException' && !ex.file) {\n\t\t\t\t\t\t\t\tex.file = that.id;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tTwig.log.error(\"Error parsing twig template \" + that.id + \": \");\n\t\t\t\t\t\t\tif (ex.stack) {\n\t\t\t\t\t\t\t\tTwig.log.error(ex.stack);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tTwig.log.error(ex.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (Twig.debug) {\n\t\t\t\t\t\t\t\treturn ex.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpromise = Twig.async.forEach(tokens, function parseToken(token) {\n\t\t\t\t\t\tTwig.log.debug(\"Twig.parse: \", \"Parsing token: \", token);\n\n\t\t\t\t\t\tswitch (token.type) {\n\t\t\t\t\t\t\tcase Twig.token.type.raw:\n\t\t\t\t\t\t\t\toutput.push(Twig.filters.raw(token.value));\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase Twig.token.type.logic:\n\t\t\t\t\t\t\t\tvar logic_token = token.token;\n\n\t\t\t\t\t\t\t\treturn Twig.logic.parseAsync.apply(that, [logic_token, context, chain]).then(function (logic) {\n\t\t\t\t\t\t\t\t\tif (logic.chain !== undefined) {\n\t\t\t\t\t\t\t\t\t\tchain = logic.chain;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (logic.context !== undefined) {\n\t\t\t\t\t\t\t\t\t\tcontext = logic.context;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (logic.output !== undefined) {\n\t\t\t\t\t\t\t\t\t\toutput.push(logic.output);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase Twig.token.type.comment:\n\t\t\t\t\t\t\t\t// Do nothing, comments should be ignored\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t//Fall through whitespace to output\n\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_pre:\n\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_post:\n\t\t\t\t\t\t\tcase Twig.token.type.output_whitespace_both:\n\t\t\t\t\t\t\tcase Twig.token.type.output:\n\t\t\t\t\t\t\t\tTwig.log.debug(\"Twig.parse: \", \"Output token: \", token.stack);\n\t\t\t\t\t\t\t\t// Parse the given expression in the given context\n\t\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(that, [token.stack, context]).then(function (o) {\n\t\t\t\t\t\t\t\t\toutput.push(o);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}).then(function () {\n\t\t\t\t\t\toutput = Twig.output.apply(that, [output]);\n\t\t\t\t\t\tis_async = false;\n\t\t\t\t\t\treturn output;\n\t\t\t\t\t}).catch(function (e) {\n\t\t\t\t\t\tif (allow_async) handleException(e);\n\n\t\t\t\t\t\terr = e;\n\t\t\t\t\t});\n\n\t\t\t\t\t// If `allow_async` we will always return a promise since we do not\n\t\t\t\t\t// know in advance if we are going to run asynchronously or not.\n\t\t\t\t\tif (allow_async) return promise;\n\n\t\t\t\t\t// Handle errors here if we fail synchronously.\n\t\t\t\t\tif (err !== null) return handleException(err);\n\n\t\t\t\t\t// If `allow_async` is not true we should not allow the user\n\t\t\t\t\t// to use asynchronous functions or filters.\n\t\t\t\t\tif (is_async) throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t\t\t\t\treturn output;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Tokenize and compile a string template.\n     *\n     * @param {string} data The template.\n     *\n     * @return {Array} The compiled tokens.\n     */\n\t\t\t\tTwig.prepare = function (data) {\n\t\t\t\t\tvar tokens, raw_tokens;\n\n\t\t\t\t\t// Tokenize\n\t\t\t\t\tTwig.log.debug(\"Twig.prepare: \", \"Tokenizing \", data);\n\t\t\t\t\traw_tokens = Twig.tokenize.apply(this, [data]);\n\n\t\t\t\t\t// Compile\n\t\t\t\t\tTwig.log.debug(\"Twig.prepare: \", \"Compiling \", raw_tokens);\n\t\t\t\t\ttokens = Twig.compile.apply(this, [raw_tokens]);\n\n\t\t\t\t\tTwig.log.debug(\"Twig.prepare: \", \"Compiled \", tokens);\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Join the output token's stack and escape it if needed\n     *\n     * @param {Array} Output token's stack\n     *\n     * @return {string|String} Autoescaped output\n     */\n\t\t\t\tTwig.output = function (output) {\n\t\t\t\t\tif (!this.options.autoescape) {\n\t\t\t\t\t\treturn output.join(\"\");\n\t\t\t\t\t}\n\n\t\t\t\t\tvar strategy = 'html';\n\t\t\t\t\tif (typeof this.options.autoescape == 'string') strategy = this.options.autoescape;\n\n\t\t\t\t\t// [].map would be better but it's not supported by IE8-\n\t\t\t\t\tvar escaped_output = [];\n\t\t\t\t\tTwig.forEach(output, function (str) {\n\t\t\t\t\t\tif (str && str.twig_markup !== true && str.twig_markup != strategy) {\n\t\t\t\t\t\t\tstr = Twig.filters.escape(str, [strategy]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tescaped_output.push(str);\n\t\t\t\t\t});\n\t\t\t\t\treturn Twig.Markup(escaped_output.join(\"\"));\n\t\t\t\t};\n\n\t\t\t\t// Namespace for template storage and retrieval\n\t\t\t\tTwig.Templates = {\n\t\t\t\t\t/**\n      * Registered template loaders - use Twig.Templates.registerLoader to add supported loaders\n      * @type {Object}\n      */\n\t\t\t\t\tloaders: {},\n\n\t\t\t\t\t/**\n      * Registered template parsers - use Twig.Templates.registerParser to add supported parsers\n      * @type {Object}\n      */\n\t\t\t\t\tparsers: {},\n\n\t\t\t\t\t/**\n      * Cached / loaded templates\n      * @type {Object}\n      */\n\t\t\t\t\tregistry: {}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Is this id valid for a twig template?\n     *\n     * @param {string} id The ID to check.\n     *\n     * @throws {Twig.Error} If the ID is invalid or used.\n     * @return {boolean} True if the ID is valid.\n     */\n\t\t\t\tTwig.validateId = function (id) {\n\t\t\t\t\tif (id === \"prototype\") {\n\t\t\t\t\t\tthrow new Twig.Error(id + \" is not a valid twig identifier\");\n\t\t\t\t\t} else if (Twig.cache && Twig.Templates.registry.hasOwnProperty(id)) {\n\t\t\t\t\t\tthrow new Twig.Error(\"There is already a template with the ID \" + id);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Register a template loader\n     *\n     * @example\n     * Twig.extend(function(Twig) {\n     *    Twig.Templates.registerLoader('custom_loader', function(location, params, callback, error_callback) {\n     *        // ... load the template ...\n     *        params.data = loadedTemplateData;\n     *        // create and return the template\n     *        var template = new Twig.Template(params);\n     *        if (typeof callback === 'function') {\n     *            callback(template);\n     *        }\n     *        return template;\n     *    });\n     * });\n     *\n     * @param {String} method_name The method this loader is intended for (ajax, fs)\n     * @param {Function} func The function to execute when loading the template\n     * @param {Object|undefined} scope Optional scope parameter to bind func to\n     *\n     * @throws Twig.Error\n     *\n     * @return {void}\n     */\n\t\t\t\tTwig.Templates.registerLoader = function (method_name, func, scope) {\n\t\t\t\t\tif (typeof func !== 'function') {\n\t\t\t\t\t\tthrow new Twig.Error('Unable to add loader for ' + method_name + ': Invalid function reference given.');\n\t\t\t\t\t}\n\t\t\t\t\tif (scope) {\n\t\t\t\t\t\tfunc = func.bind(scope);\n\t\t\t\t\t}\n\t\t\t\t\tthis.loaders[method_name] = func;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Remove a registered loader\n     *\n     * @param {String} method_name The method name for the loader you wish to remove\n     *\n     * @return {void}\n     */\n\t\t\t\tTwig.Templates.unRegisterLoader = function (method_name) {\n\t\t\t\t\tif (this.isRegisteredLoader(method_name)) {\n\t\t\t\t\t\tdelete this.loaders[method_name];\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * See if a loader is registered by its method name\n     *\n     * @param {String} method_name The name of the loader you are looking for\n     *\n     * @return {boolean}\n     */\n\t\t\t\tTwig.Templates.isRegisteredLoader = function (method_name) {\n\t\t\t\t\treturn this.loaders.hasOwnProperty(method_name);\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Register a template parser\n     *\n     * @example\n     * Twig.extend(function(Twig) {\n     *    Twig.Templates.registerParser('custom_parser', function(params) {\n     *        // this template source can be accessed in params.data\n     *        var template = params.data\n     *\n     *        // ... custom process that modifies the template\n     *\n     *        // return the parsed template\n     *        return template;\n     *    });\n     * });\n     *\n     * @param {String} method_name The method this parser is intended for (twig, source)\n     * @param {Function} func The function to execute when parsing the template\n     * @param {Object|undefined} scope Optional scope parameter to bind func to\n     *\n     * @throws Twig.Error\n     *\n     * @return {void}\n     */\n\t\t\t\tTwig.Templates.registerParser = function (method_name, func, scope) {\n\t\t\t\t\tif (typeof func !== 'function') {\n\t\t\t\t\t\tthrow new Twig.Error('Unable to add parser for ' + method_name + ': Invalid function regerence given.');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scope) {\n\t\t\t\t\t\tfunc = func.bind(scope);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.parsers[method_name] = func;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Remove a registered parser\n     *\n     * @param {String} method_name The method name for the parser you wish to remove\n     *\n     * @return {void}\n     */\n\t\t\t\tTwig.Templates.unRegisterParser = function (method_name) {\n\t\t\t\t\tif (this.isRegisteredParser(method_name)) {\n\t\t\t\t\t\tdelete this.parsers[method_name];\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * See if a parser is registered by its method name\n     *\n     * @param {String} method_name The name of the parser you are looking for\n     *\n     * @return {boolean}\n     */\n\t\t\t\tTwig.Templates.isRegisteredParser = function (method_name) {\n\t\t\t\t\treturn this.parsers.hasOwnProperty(method_name);\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Save a template object to the store.\n     *\n     * @param {Twig.Template} template   The twig.js template to store.\n     */\n\t\t\t\tTwig.Templates.save = function (template) {\n\t\t\t\t\tif (template.id === undefined) {\n\t\t\t\t\t\tthrow new Twig.Error(\"Unable to save template with no id\");\n\t\t\t\t\t}\n\t\t\t\t\tTwig.Templates.registry[template.id] = template;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Load a previously saved template from the store.\n     *\n     * @param {string} id   The ID of the template to load.\n     *\n     * @return {Twig.Template} A twig.js template stored with the provided ID.\n     */\n\t\t\t\tTwig.Templates.load = function (id) {\n\t\t\t\t\tif (!Twig.Templates.registry.hasOwnProperty(id)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn Twig.Templates.registry[id];\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Load a template from a remote location using AJAX and saves in with the given ID.\n     *\n     * Available parameters:\n     *\n     *      async:       Should the HTTP request be performed asynchronously.\n     *                      Defaults to true.\n     *      method:      What method should be used to load the template\n     *                      (fs or ajax)\n     *      parser:      What method should be used to parse the template\n     *                      (twig or source)\n     *      precompiled: Has the template already been compiled.\n     *\n     * @param {string} location  The remote URL to load as a template.\n     * @param {Object} params The template parameters.\n     * @param {function} callback  A callback triggered when the template finishes loading.\n     * @param {function} error_callback  A callback triggered if an error occurs loading the template.\n     *\n     *\n     */\n\t\t\t\tTwig.Templates.loadRemote = function (location, params, callback, error_callback) {\n\t\t\t\t\tvar loader;\n\n\t\t\t\t\t// Default to async\n\t\t\t\t\tif (params.async === undefined) {\n\t\t\t\t\t\tparams.async = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Default to the URL so the template is cached.\n\t\t\t\t\tif (params.id === undefined) {\n\t\t\t\t\t\tparams.id = location;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check for existing template\n\t\t\t\t\tif (Twig.cache && Twig.Templates.registry.hasOwnProperty(params.id)) {\n\t\t\t\t\t\t// A template is already saved with the given id.\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\tcallback(Twig.Templates.registry[params.id]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: if async, return deferred promise\n\t\t\t\t\t\treturn Twig.Templates.registry[params.id];\n\t\t\t\t\t}\n\n\t\t\t\t\t//if the parser name hasn't been set, default it to twig\n\t\t\t\t\tparams.parser = params.parser || 'twig';\n\n\t\t\t\t\t// Assume 'fs' if the loader is not defined\n\t\t\t\t\tloader = this.loaders[params.method] || this.loaders.fs;\n\t\t\t\t\treturn loader.apply(this, arguments);\n\t\t\t\t};\n\n\t\t\t\t// Determine object type\n\t\t\t\tfunction is(type, obj) {\n\t\t\t\t\tvar clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t\t\t\t\treturn obj !== undefined && obj !== null && clas === type;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Create a new twig.js template.\n     *\n     * Parameters: {\n     *      data:   The template, either pre-compiled tokens or a string template\n     *      id:     The name of this template\n     *      blocks: Any pre-existing block from a child template\n     * }\n     *\n     * @param {Object} params The template parameters.\n     */\n\t\t\t\tTwig.Template = function (params) {\n\t\t\t\t\tvar data = params.data,\n\t\t\t\t\t    id = params.id,\n\t\t\t\t\t    blocks = params.blocks,\n\t\t\t\t\t    macros = params.macros || {},\n\t\t\t\t\t    base = params.base,\n\t\t\t\t\t    path = params.path,\n\t\t\t\t\t    url = params.url,\n\t\t\t\t\t    name = params.name,\n\t\t\t\t\t    method = params.method,\n\n\t\t\t\t\t// parser options\n\t\t\t\t\toptions = params.options;\n\n\t\t\t\t\t// # What is stored in a Twig.Template\n\t\t\t\t\t//\n\t\t\t\t\t// The Twig Template hold several chucks of data.\n\t\t\t\t\t//\n\t\t\t\t\t//     {\n\t\t\t\t\t//          id:     The token ID (if any)\n\t\t\t\t\t//          tokens: The list of tokens that makes up this template.\n\t\t\t\t\t//          blocks: The list of block this template contains.\n\t\t\t\t\t//          base:   The base template (if any)\n\t\t\t\t\t//            options:  {\n\t\t\t\t\t//                Compiler/parser options\n\t\t\t\t\t//\n\t\t\t\t\t//                strict_variables: true/false\n\t\t\t\t\t//                    Should missing variable/keys emit an error message. If false, they default to null.\n\t\t\t\t\t//            }\n\t\t\t\t\t//     }\n\t\t\t\t\t//\n\n\t\t\t\t\tthis.id = id;\n\t\t\t\t\tthis.method = method;\n\t\t\t\t\tthis.base = base;\n\t\t\t\t\tthis.path = path;\n\t\t\t\t\tthis.url = url;\n\t\t\t\t\tthis.name = name;\n\t\t\t\t\tthis.macros = macros;\n\t\t\t\t\tthis.options = options;\n\n\t\t\t\t\tthis.reset(blocks);\n\n\t\t\t\t\tif (is('String', data)) {\n\t\t\t\t\t\tthis.tokens = Twig.prepare.apply(this, [data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.tokens = data;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (id !== undefined) {\n\t\t\t\t\t\tTwig.Templates.save(this);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.reset = function (blocks) {\n\t\t\t\t\tTwig.log.debug(\"Twig.Template.reset\", \"Reseting template \" + this.id);\n\t\t\t\t\tthis.blocks = {};\n\t\t\t\t\tthis.importedBlocks = [];\n\t\t\t\t\tthis.originalBlockTokens = {};\n\t\t\t\t\tthis.child = {\n\t\t\t\t\t\tblocks: blocks || {}\n\t\t\t\t\t};\n\t\t\t\t\tthis.extend = null;\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.render = function (context, params, allow_async) {\n\t\t\t\t\tparams = params || {};\n\n\t\t\t\t\tvar that = this,\n\n\n\t\t\t\t\t// Store any error that might be thrown by the promise chain.\n\t\t\t\t\terr = null,\n\n\n\t\t\t\t\t// This will be set to is_async if template renders synchronously\n\t\t\t\t\tis_async = true,\n\t\t\t\t\t    promise = null,\n\t\t\t\t\t    result,\n\t\t\t\t\t    url;\n\n\t\t\t\t\tthis.context = context || {};\n\n\t\t\t\t\t// Clear any previous state\n\t\t\t\t\tthis.reset();\n\t\t\t\t\tif (params.blocks) {\n\t\t\t\t\t\tthis.blocks = params.blocks;\n\t\t\t\t\t}\n\t\t\t\t\tif (params.macros) {\n\t\t\t\t\t\tthis.macros = params.macros;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar cb = function (output) {\n\t\t\t\t\t\t// Does this template extend another\n\t\t\t\t\t\tif (that.extend) {\n\t\t\t\t\t\t\tvar ext_template;\n\n\t\t\t\t\t\t\t// check if the template is provided inline\n\t\t\t\t\t\t\tif (that.options.allowInlineIncludes) {\n\t\t\t\t\t\t\t\text_template = Twig.Templates.load(that.extend);\n\t\t\t\t\t\t\t\tif (ext_template) {\n\t\t\t\t\t\t\t\t\text_template.options = that.options;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check for the template file via include\n\t\t\t\t\t\t\tif (!ext_template) {\n\t\t\t\t\t\t\t\turl = Twig.path.parsePath(that, that.extend);\n\n\t\t\t\t\t\t\t\text_template = Twig.Templates.loadRemote(url, {\n\t\t\t\t\t\t\t\t\tmethod: that.getLoaderMethod(),\n\t\t\t\t\t\t\t\t\tbase: that.base,\n\t\t\t\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\t\t\t\tid: url,\n\t\t\t\t\t\t\t\t\toptions: that.options\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthat.parent = ext_template;\n\n\t\t\t\t\t\t\treturn that.parent.renderAsync(that.context, {\n\t\t\t\t\t\t\t\tblocks: that.blocks\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (params.output == 'blocks') {\n\t\t\t\t\t\t\treturn that.blocks;\n\t\t\t\t\t\t} else if (params.output == 'macros') {\n\t\t\t\t\t\t\treturn that.macros;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn output;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tpromise = Twig.parseAsync.apply(this, [this.tokens, this.context]).then(cb).then(function (v) {\n\t\t\t\t\t\tis_async = false;\n\t\t\t\t\t\tresult = v;\n\t\t\t\t\t\treturn v;\n\t\t\t\t\t}).catch(function (e) {\n\t\t\t\t\t\tif (allow_async) throw e;\n\n\t\t\t\t\t\terr = e;\n\t\t\t\t\t});\n\n\t\t\t\t\t// If `allow_async` we will always return a promise since we do not\n\t\t\t\t\t// know in advance if we are going to run asynchronously or not.\n\t\t\t\t\tif (allow_async) return promise;\n\n\t\t\t\t\t// Handle errors here if we fail synchronously.\n\t\t\t\t\tif (err !== null) throw err;\n\n\t\t\t\t\t// If `allow_async` is not true we should not allow the user\n\t\t\t\t\t// to use asynchronous functions or filters.\n\t\t\t\t\tif (is_async) throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.importFile = function (file) {\n\t\t\t\t\tvar url, sub_template;\n\t\t\t\t\tif (!this.url && this.options.allowInlineIncludes) {\n\t\t\t\t\t\tfile = this.path ? Twig.path.parsePath(this, file) : file;\n\t\t\t\t\t\tsub_template = Twig.Templates.load(file);\n\n\t\t\t\t\t\tif (!sub_template) {\n\t\t\t\t\t\t\tsub_template = Twig.Templates.loadRemote(url, {\n\t\t\t\t\t\t\t\tid: file,\n\t\t\t\t\t\t\t\tmethod: this.getLoaderMethod(),\n\t\t\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\t\t\tpath: file,\n\t\t\t\t\t\t\t\toptions: this.options\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (!sub_template) {\n\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Unable to find the template \" + file);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsub_template.options = this.options;\n\n\t\t\t\t\t\treturn sub_template;\n\t\t\t\t\t}\n\n\t\t\t\t\turl = Twig.path.parsePath(this, file);\n\n\t\t\t\t\t// Load blocks from an external file\n\t\t\t\t\tsub_template = Twig.Templates.loadRemote(url, {\n\t\t\t\t\t\tmethod: this.getLoaderMethod(),\n\t\t\t\t\t\tbase: this.base,\n\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\toptions: this.options,\n\t\t\t\t\t\tid: url\n\t\t\t\t\t});\n\n\t\t\t\t\treturn sub_template;\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.importBlocks = function (file, override) {\n\t\t\t\t\tvar sub_template = this.importFile(file),\n\t\t\t\t\t    context = this.context,\n\t\t\t\t\t    that = this,\n\t\t\t\t\t    key;\n\n\t\t\t\t\toverride = override || false;\n\n\t\t\t\t\tsub_template.render(context);\n\n\t\t\t\t\t// Mixin blocks\n\t\t\t\t\tTwig.forEach(Object.keys(sub_template.blocks), function (key) {\n\t\t\t\t\t\tif (override || that.blocks[key] === undefined) {\n\t\t\t\t\t\t\tthat.blocks[key] = sub_template.blocks[key];\n\t\t\t\t\t\t\tthat.importedBlocks.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.importMacros = function (file) {\n\t\t\t\t\tvar url = Twig.path.parsePath(this, file);\n\n\t\t\t\t\t// load remote template\n\t\t\t\t\tvar remoteTemplate = Twig.Templates.loadRemote(url, {\n\t\t\t\t\t\tmethod: this.getLoaderMethod(),\n\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\tid: url\n\t\t\t\t\t});\n\n\t\t\t\t\treturn remoteTemplate;\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.getLoaderMethod = function () {\n\t\t\t\t\tif (this.path) {\n\t\t\t\t\t\treturn 'fs';\n\t\t\t\t\t}\n\t\t\t\t\tif (this.url) {\n\t\t\t\t\t\treturn 'ajax';\n\t\t\t\t\t}\n\t\t\t\t\treturn this.method || 'fs';\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.compile = function (options) {\n\t\t\t\t\t// compile the template into raw JS\n\t\t\t\t\treturn Twig.compiler.compile(this, options);\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Create safe output\n     *\n     * @param {string} Content safe to output\n     *\n     * @return {String} Content wrapped into a String\n     */\n\n\t\t\t\tTwig.Markup = function (content, strategy) {\n\t\t\t\t\tif (typeof strategy == 'undefined') {\n\t\t\t\t\t\tstrategy = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof content === 'string' && content.length > 0) {\n\t\t\t\t\t\tcontent = new String(content);\n\t\t\t\t\t\tcontent.twig_markup = strategy;\n\t\t\t\t\t}\n\t\t\t\t\treturn content;\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 2 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.compiler.js\n\t\t\t//\n\t\t\t// This file handles compiling templates into JS\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t/**\n     * Namespace for compilation.\n     */\n\t\t\t\tTwig.compiler = {\n\t\t\t\t\tmodule: {}\n\t\t\t\t};\n\n\t\t\t\t// Compile a Twig Template to output.\n\t\t\t\tTwig.compiler.compile = function (template, options) {\n\t\t\t\t\t// Get tokens\n\t\t\t\t\tvar tokens = JSON.stringify(template.tokens),\n\t\t\t\t\t    id = template.id,\n\t\t\t\t\t    output;\n\n\t\t\t\t\tif (options.module) {\n\t\t\t\t\t\tif (Twig.compiler.module[options.module] === undefined) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Unable to find module type \" + options.module);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput = Twig.compiler.module[options.module](id, tokens, options.twig);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput = Twig.compiler.wrap(id, tokens);\n\t\t\t\t\t}\n\t\t\t\t\treturn output;\n\t\t\t\t};\n\n\t\t\t\tTwig.compiler.module = {\n\t\t\t\t\tamd: function (id, tokens, pathToTwig) {\n\t\t\t\t\t\treturn 'define([\"' + pathToTwig + '\"], function (Twig) {\\n\\tvar twig, templates;\\ntwig = Twig.twig;\\ntemplates = ' + Twig.compiler.wrap(id, tokens) + '\\n\\treturn templates;\\n});';\n\t\t\t\t\t},\n\t\t\t\t\tnode: function (id, tokens) {\n\t\t\t\t\t\treturn 'var twig = require(\"twig\").twig;\\n' + 'exports.template = ' + Twig.compiler.wrap(id, tokens);\n\t\t\t\t\t},\n\t\t\t\t\tcjs2: function (id, tokens, pathToTwig) {\n\t\t\t\t\t\treturn 'module.declare([{ twig: \"' + pathToTwig + '\" }], function (require, exports, module) {\\n' + '\\tvar twig = require(\"twig\").twig;\\n' + '\\texports.template = ' + Twig.compiler.wrap(id, tokens) + '\\n});';\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tTwig.compiler.wrap = function (id, tokens) {\n\t\t\t\t\treturn 'twig({id:\"' + id.replace('\"', '\\\\\"') + '\", data:' + tokens + ', precompiled: true});\\n';\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 3 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t// ## twig.expression.js\n\t\t\t//\n\t\t\t// This file handles tokenizing, compiling and parsing expressions.\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\tfunction parseParams(thisArg, params, context) {\n\t\t\t\t\tif (params) return Twig.expression.parseAsync.apply(thisArg, [params, context]);\n\n\t\t\t\t\treturn Twig.Promise.resolve(false);\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Namespace for expression handling.\n     */\n\t\t\t\tTwig.expression = {};\n\n\t\t\t\t__webpack_require__(4)(Twig);\n\n\t\t\t\t/**\n     * Reserved word that can't be used as variable names.\n     */\n\t\t\t\tTwig.expression.reservedWords = [\"true\", \"false\", \"null\", \"TRUE\", \"FALSE\", \"NULL\", \"_context\", \"and\", \"b-and\", \"or\", \"b-or\", \"b-xor\", \"in\", \"not in\", \"if\"];\n\n\t\t\t\t/**\n     * The type of tokens used in expressions.\n     */\n\t\t\t\tTwig.expression.type = {\n\t\t\t\t\tcomma: 'Twig.expression.type.comma',\n\t\t\t\t\toperator: {\n\t\t\t\t\t\tunary: 'Twig.expression.type.operator.unary',\n\t\t\t\t\t\tbinary: 'Twig.expression.type.operator.binary'\n\t\t\t\t\t},\n\t\t\t\t\tstring: 'Twig.expression.type.string',\n\t\t\t\t\tbool: 'Twig.expression.type.bool',\n\t\t\t\t\tslice: 'Twig.expression.type.slice',\n\t\t\t\t\tarray: {\n\t\t\t\t\t\tstart: 'Twig.expression.type.array.start',\n\t\t\t\t\t\tend: 'Twig.expression.type.array.end'\n\t\t\t\t\t},\n\t\t\t\t\tobject: {\n\t\t\t\t\t\tstart: 'Twig.expression.type.object.start',\n\t\t\t\t\t\tend: 'Twig.expression.type.object.end'\n\t\t\t\t\t},\n\t\t\t\t\tparameter: {\n\t\t\t\t\t\tstart: 'Twig.expression.type.parameter.start',\n\t\t\t\t\t\tend: 'Twig.expression.type.parameter.end'\n\t\t\t\t\t},\n\t\t\t\t\tsubexpression: {\n\t\t\t\t\t\tstart: 'Twig.expression.type.subexpression.start',\n\t\t\t\t\t\tend: 'Twig.expression.type.subexpression.end'\n\t\t\t\t\t},\n\t\t\t\t\tkey: {\n\t\t\t\t\t\tperiod: 'Twig.expression.type.key.period',\n\t\t\t\t\t\tbrackets: 'Twig.expression.type.key.brackets'\n\t\t\t\t\t},\n\t\t\t\t\tfilter: 'Twig.expression.type.filter',\n\t\t\t\t\t_function: 'Twig.expression.type._function',\n\t\t\t\t\tvariable: 'Twig.expression.type.variable',\n\t\t\t\t\tnumber: 'Twig.expression.type.number',\n\t\t\t\t\t_null: 'Twig.expression.type.null',\n\t\t\t\t\tcontext: 'Twig.expression.type.context',\n\t\t\t\t\ttest: 'Twig.expression.type.test'\n\t\t\t\t};\n\n\t\t\t\tTwig.expression.set = {\n\t\t\t\t\t// What can follow an expression (in general)\n\t\t\t\t\toperations: [Twig.expression.type.filter, Twig.expression.type.operator.unary, Twig.expression.type.operator.binary, Twig.expression.type.array.end, Twig.expression.type.object.end, Twig.expression.type.parameter.end, Twig.expression.type.subexpression.end, Twig.expression.type.comma, Twig.expression.type.test],\n\t\t\t\t\texpressions: [Twig.expression.type._function, Twig.expression.type.bool, Twig.expression.type.string, Twig.expression.type.variable, Twig.expression.type.number, Twig.expression.type._null, Twig.expression.type.context, Twig.expression.type.parameter.start, Twig.expression.type.array.start, Twig.expression.type.object.start, Twig.expression.type.subexpression.start, Twig.expression.type.operator.unary]\n\t\t\t\t};\n\n\t\t\t\t// Most expressions allow a '.' or '[' after them, so we provide a convenience set\n\t\t\t\tTwig.expression.set.operations_extended = Twig.expression.set.operations.concat([Twig.expression.type.key.period, Twig.expression.type.key.brackets, Twig.expression.type.slice]);\n\n\t\t\t\t// Some commonly used compile and parse functions.\n\t\t\t\tTwig.expression.fn = {\n\t\t\t\t\tcompile: {\n\t\t\t\t\t\tpush: function (token, stack, output) {\n\t\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpush_both: function (token, stack, output) {\n\t\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tparse: {\n\t\t\t\t\t\tpush: function (token, stack, context) {\n\t\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpush_value: function (token, stack, context) {\n\t\t\t\t\t\t\tstack.push(token.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// The regular expressions and compile/parse logic used to match tokens in expressions.\n\t\t\t\t//\n\t\t\t\t// Properties:\n\t\t\t\t//\n\t\t\t\t//      type:  The type of expression this matches\n\t\t\t\t//\n\t\t\t\t//      regex: One or more regular expressions that matche the format of the token.\n\t\t\t\t//\n\t\t\t\t//      next:  Valid tokens that can occur next in the expression.\n\t\t\t\t//\n\t\t\t\t// Functions:\n\t\t\t\t//\n\t\t\t\t//      compile: A function that compiles the raw regular expression match into a token.\n\t\t\t\t//\n\t\t\t\t//      parse:   A function that parses the compiled token into output.\n\t\t\t\t//\n\t\t\t\tTwig.expression.definitions = [{\n\t\t\t\t\ttype: Twig.expression.type.test,\n\t\t\t\t\tregex: /^is\\s+(not)?\\s*([a-zA-Z_][a-zA-Z0-9_]*(\\s?as)?)/,\n\t\t\t\t\tnext: Twig.expression.set.operations.concat([Twig.expression.type.parameter.start]),\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\ttoken.filter = token.match[2];\n\t\t\t\t\t\ttoken.modifier = token.match[1];\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\tdelete token.value;\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tvar value = stack.pop();\n\n\t\t\t\t\t\treturn parseParams(this, token.params, context).then(function (params) {\n\t\t\t\t\t\t\tvar result = Twig.test(token.filter, value, params);\n\n\t\t\t\t\t\t\tif (token.modifier == 'not') {\n\t\t\t\t\t\t\t\tstack.push(!result);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstack.push(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.expression.type.comma,\n\t\t\t\t\t// Match a comma\n\t\t\t\t\tregex: /^,/,\n\t\t\t\t\tnext: Twig.expression.set.expressions.concat([Twig.expression.type.array.end, Twig.expression.type.object.end]),\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar i = stack.length - 1,\n\t\t\t\t\t\t    stack_token;\n\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\tdelete token.value;\n\n\t\t\t\t\t\t// pop tokens off the stack until the start of the object\n\t\t\t\t\t\tfor (; i >= 0; i--) {\n\t\t\t\t\t\t\tstack_token = stack.pop();\n\t\t\t\t\t\t\tif (stack_token.type === Twig.expression.type.object.start || stack_token.type === Twig.expression.type.parameter.start || stack_token.type === Twig.expression.type.array.start) {\n\t\t\t\t\t\t\t\tstack.push(stack_token);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toutput.push(stack_token);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a number (integer or decimal)\n      */\n\t\t\t\t\ttype: Twig.expression.type.number,\n\t\t\t\t\t// match a number\n\t\t\t\t\tregex: /^\\-?\\d+(\\.\\d+)?/,\n\t\t\t\t\tnext: Twig.expression.set.operations,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\ttoken.value = Number(token.value);\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: Twig.expression.fn.parse.push_value\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.expression.type.operator.binary,\n\t\t\t\t\t// Match any of ?:, +, *, /, -, %, ~, <, <=, >, >=, !=, ==, **, ?, :, and, b-and, or, b-or, b-xor, in, not in\n\t\t\t\t\t// and, or, in, not in can be followed by a space or parenthesis\n\t\t\t\t\tregex: /(^\\?\\:|^(b\\-and)|^(b\\-or)|^(b\\-xor)|^[\\+\\-~%\\?]|^[\\:](?!\\d\\])|^[!=]==?|^[!<>]=?|^\\*\\*?|^\\/\\/?|^(and)[\\(|\\s+]|^(or)[\\(|\\s+]|^(in)[\\(|\\s+]|^(not in)[\\(|\\s+]|^\\.\\.)/,\n\t\t\t\t\tnext: Twig.expression.set.expressions,\n\t\t\t\t\ttransform: function (match, tokens) {\n\t\t\t\t\t\tswitch (match[0]) {\n\t\t\t\t\t\t\tcase 'and(':\n\t\t\t\t\t\t\tcase 'or(':\n\t\t\t\t\t\t\tcase 'in(':\n\t\t\t\t\t\t\tcase 'not in(':\n\t\t\t\t\t\t\t\t//Strip off the ( if it exists\n\t\t\t\t\t\t\t\ttokens[tokens.length - 1].value = match[2];\n\t\t\t\t\t\t\t\treturn match[0];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.value = token.value.trim();\n\t\t\t\t\t\tvar value = token.value,\n\t\t\t\t\t\t    operator = Twig.expression.operator.lookup(value, token);\n\n\t\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"Operator: \", operator, \" from \", value);\n\n\t\t\t\t\t\twhile (stack.length > 0 && (stack[stack.length - 1].type == Twig.expression.type.operator.unary || stack[stack.length - 1].type == Twig.expression.type.operator.binary) && (operator.associativity === Twig.expression.operator.leftToRight && operator.precidence >= stack[stack.length - 1].precidence || operator.associativity === Twig.expression.operator.rightToLeft && operator.precidence > stack[stack.length - 1].precidence)) {\n\t\t\t\t\t\t\tvar temp = stack.pop();\n\t\t\t\t\t\t\toutput.push(temp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (value === \":\") {\n\t\t\t\t\t\t\t// Check if this is a ternary or object key being set\n\t\t\t\t\t\t\tif (stack[stack.length - 1] && stack[stack.length - 1].value === \"?\") {\n\t\t\t\t\t\t\t\t// Continue as normal for a ternary\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// This is not a ternary so we push the token to the output where it can be handled\n\t\t\t\t\t\t\t\t//   when the assocated object is closed.\n\t\t\t\t\t\t\t\tvar key_token = output.pop();\n\n\t\t\t\t\t\t\t\tif (key_token.type === Twig.expression.type.string || key_token.type === Twig.expression.type.variable) {\n\t\t\t\t\t\t\t\t\ttoken.key = key_token.value;\n\t\t\t\t\t\t\t\t} else if (key_token.type === Twig.expression.type.number) {\n\t\t\t\t\t\t\t\t\t// Convert integer keys into string keys\n\t\t\t\t\t\t\t\t\ttoken.key = key_token.value.toString();\n\t\t\t\t\t\t\t\t} else if (key_token.expression && (key_token.type === Twig.expression.type.parameter.end || key_token.type == Twig.expression.type.subexpression.end)) {\n\t\t\t\t\t\t\t\t\ttoken.params = key_token.params;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Unexpected value before ':' of \" + key_token.type + \" = \" + key_token.value);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstack.push(operator);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tif (token.key) {\n\t\t\t\t\t\t\t// handle ternary ':' operator\n\t\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t\t} else if (token.params) {\n\t\t\t\t\t\t\t// handle \"{(expression):value}\"\n\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.params, context]).then(function (key) {\n\t\t\t\t\t\t\t\ttoken.key = key;\n\t\t\t\t\t\t\t\tstack.push(token);\n\n\t\t\t\t\t\t\t\t//If we're in a loop, we might need token.params later, especially in this form of \"(expression):value\"\n\t\t\t\t\t\t\t\tif (!context.loop) {\n\t\t\t\t\t\t\t\t\tdelete token.params;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tTwig.expression.operator.parse(token.value, stack);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.expression.type.operator.unary,\n\t\t\t\t\t// Match any of not\n\t\t\t\t\tregex: /(^not\\s+)/,\n\t\t\t\t\tnext: Twig.expression.set.expressions,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.value = token.value.trim();\n\t\t\t\t\t\tvar value = token.value,\n\t\t\t\t\t\t    operator = Twig.expression.operator.lookup(value, token);\n\n\t\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"Operator: \", operator, \" from \", value);\n\n\t\t\t\t\t\twhile (stack.length > 0 && (stack[stack.length - 1].type == Twig.expression.type.operator.unary || stack[stack.length - 1].type == Twig.expression.type.operator.binary) && (operator.associativity === Twig.expression.operator.leftToRight && operator.precidence >= stack[stack.length - 1].precidence || operator.associativity === Twig.expression.operator.rightToLeft && operator.precidence > stack[stack.length - 1].precidence)) {\n\t\t\t\t\t\t\tvar temp = stack.pop();\n\t\t\t\t\t\t\toutput.push(temp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstack.push(operator);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tTwig.expression.operator.parse(token.value, stack);\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a string. This is anything between a pair of single or double quotes.\n      */\n\t\t\t\t\ttype: Twig.expression.type.string,\n\t\t\t\t\t// See: http://blog.stevenlevithan.com/archives/match-quoted-string\n\t\t\t\t\tregex: /^([\"'])(?:(?=(\\\\?))\\2[\\s\\S])*?\\1/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar value = token.value;\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\t// Remove the quotes from the string\n\t\t\t\t\t\tif (value.substring(0, 1) === '\"') {\n\t\t\t\t\t\t\tvalue = value.replace('\\\\\"', '\"');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = value.replace(\"\\\\'\", \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttoken.value = value.substring(1, value.length - 1).replace(/\\\\n/g, \"\\n\").replace(/\\\\r/g, \"\\r\");\n\t\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"String value: \", token.value);\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: Twig.expression.fn.parse.push_value\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a subexpression set start.\n      */\n\t\t\t\t\ttype: Twig.expression.type.subexpression.start,\n\t\t\t\t\tregex: /^\\(/,\n\t\t\t\t\tnext: Twig.expression.set.expressions.concat([Twig.expression.type.subexpression.end]),\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\ttoken.value = '(';\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: Twig.expression.fn.parse.push\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a subexpression set end.\n      */\n\t\t\t\t\ttype: Twig.expression.type.subexpression.end,\n\t\t\t\t\tregex: /^\\)/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended,\n\t\t\t\t\tvalidate: function (match, tokens) {\n\t\t\t\t\t\t// Iterate back through previous tokens to ensure we follow a subexpression start\n\t\t\t\t\t\tvar i = tokens.length - 1,\n\t\t\t\t\t\t    found_subexpression_start = false,\n\t\t\t\t\t\t    next_subexpression_start_invalid = false,\n\t\t\t\t\t\t    unclosed_parameter_count = 0;\n\n\t\t\t\t\t\twhile (!found_subexpression_start && i >= 0) {\n\t\t\t\t\t\t\tvar token = tokens[i];\n\n\t\t\t\t\t\t\tfound_subexpression_start = token.type === Twig.expression.type.subexpression.start;\n\n\t\t\t\t\t\t\t// If we have previously found a subexpression end, then this subexpression start is the start of\n\t\t\t\t\t\t\t// that subexpression, not the subexpression we are searching for\n\t\t\t\t\t\t\tif (found_subexpression_start && next_subexpression_start_invalid) {\n\t\t\t\t\t\t\t\tnext_subexpression_start_invalid = false;\n\t\t\t\t\t\t\t\tfound_subexpression_start = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Count parameter tokens to ensure we dont return truthy for a parameter opener\n\t\t\t\t\t\t\tif (token.type === Twig.expression.type.parameter.start) {\n\t\t\t\t\t\t\t\tunclosed_parameter_count++;\n\t\t\t\t\t\t\t} else if (token.type === Twig.expression.type.parameter.end) {\n\t\t\t\t\t\t\t\tunclosed_parameter_count--;\n\t\t\t\t\t\t\t} else if (token.type === Twig.expression.type.subexpression.end) {\n\t\t\t\t\t\t\t\tnext_subexpression_start_invalid = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If we found unclosed parameters, return false\n\t\t\t\t\t\t// If we didnt find subexpression start, return false\n\t\t\t\t\t\t// Otherwise return true\n\n\t\t\t\t\t\treturn found_subexpression_start && unclosed_parameter_count === 0;\n\t\t\t\t\t},\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\t// This is basically a copy of parameter end compilation\n\t\t\t\t\t\tvar stack_token,\n\t\t\t\t\t\t    end_token = token;\n\n\t\t\t\t\t\tstack_token = stack.pop();\n\t\t\t\t\t\twhile (stack.length > 0 && stack_token.type != Twig.expression.type.subexpression.start) {\n\t\t\t\t\t\t\toutput.push(stack_token);\n\t\t\t\t\t\t\tstack_token = stack.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move contents of parens into preceding filter\n\t\t\t\t\t\tvar param_stack = [];\n\t\t\t\t\t\twhile (token.type !== Twig.expression.type.subexpression.start) {\n\t\t\t\t\t\t\t// Add token to arguments stack\n\t\t\t\t\t\t\tparam_stack.unshift(token);\n\t\t\t\t\t\t\ttoken = output.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparam_stack.unshift(token);\n\n\t\t\t\t\t\tvar is_expression = false;\n\n\t\t\t\t\t\t//If the token at the top of the *stack* is a function token, pop it onto the output queue.\n\t\t\t\t\t\t// Get the token preceding the parameters\n\t\t\t\t\t\tstack_token = stack[stack.length - 1];\n\n\t\t\t\t\t\tif (stack_token === undefined || stack_token.type !== Twig.expression.type._function && stack_token.type !== Twig.expression.type.filter && stack_token.type !== Twig.expression.type.test && stack_token.type !== Twig.expression.type.key.brackets) {\n\n\t\t\t\t\t\t\tend_token.expression = true;\n\n\t\t\t\t\t\t\t// remove start and end token from stack\n\t\t\t\t\t\t\tparam_stack.pop();\n\t\t\t\t\t\t\tparam_stack.shift();\n\n\t\t\t\t\t\t\tend_token.params = param_stack;\n\n\t\t\t\t\t\t\toutput.push(end_token);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// This should never be hit\n\t\t\t\t\t\t\tend_token.expression = false;\n\t\t\t\t\t\t\tstack_token.params = param_stack;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tvar new_array = [],\n\t\t\t\t\t\t    array_ended = false,\n\t\t\t\t\t\t    value = null;\n\n\t\t\t\t\t\tif (token.expression) {\n\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.params, context]).then(function (value) {\n\t\t\t\t\t\t\t\tstack.push(value);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Unexpected subexpression end when token is not marked as an expression\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a parameter set start.\n      */\n\t\t\t\t\ttype: Twig.expression.type.parameter.start,\n\t\t\t\t\tregex: /^\\(/,\n\t\t\t\t\tnext: Twig.expression.set.expressions.concat([Twig.expression.type.parameter.end]),\n\t\t\t\t\tvalidate: function (match, tokens) {\n\t\t\t\t\t\tvar last_token = tokens[tokens.length - 1];\n\t\t\t\t\t\t// We can't use the regex to test if we follow a space because expression is trimmed\n\t\t\t\t\t\treturn last_token && Twig.indexOf(Twig.expression.reservedWords, last_token.value.trim()) < 0;\n\t\t\t\t\t},\n\t\t\t\t\tcompile: Twig.expression.fn.compile.push_both,\n\t\t\t\t\tparse: Twig.expression.fn.parse.push\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a parameter set end.\n      */\n\t\t\t\t\ttype: Twig.expression.type.parameter.end,\n\t\t\t\t\tregex: /^\\)/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar stack_token,\n\t\t\t\t\t\t    end_token = token;\n\n\t\t\t\t\t\tstack_token = stack.pop();\n\t\t\t\t\t\twhile (stack.length > 0 && stack_token.type != Twig.expression.type.parameter.start) {\n\t\t\t\t\t\t\toutput.push(stack_token);\n\t\t\t\t\t\t\tstack_token = stack.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move contents of parens into preceding filter\n\t\t\t\t\t\tvar param_stack = [];\n\t\t\t\t\t\twhile (token.type !== Twig.expression.type.parameter.start) {\n\t\t\t\t\t\t\t// Add token to arguments stack\n\t\t\t\t\t\t\tparam_stack.unshift(token);\n\t\t\t\t\t\t\ttoken = output.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparam_stack.unshift(token);\n\n\t\t\t\t\t\tvar is_expression = false;\n\n\t\t\t\t\t\t// Get the token preceding the parameters\n\t\t\t\t\t\ttoken = output[output.length - 1];\n\n\t\t\t\t\t\tif (token === undefined || token.type !== Twig.expression.type._function && token.type !== Twig.expression.type.filter && token.type !== Twig.expression.type.test && token.type !== Twig.expression.type.key.brackets) {\n\n\t\t\t\t\t\t\tend_token.expression = true;\n\n\t\t\t\t\t\t\t// remove start and end token from stack\n\t\t\t\t\t\t\tparam_stack.pop();\n\t\t\t\t\t\t\tparam_stack.shift();\n\n\t\t\t\t\t\t\tend_token.params = param_stack;\n\n\t\t\t\t\t\t\toutput.push(end_token);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend_token.expression = false;\n\t\t\t\t\t\t\ttoken.params = param_stack;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tvar new_array = [],\n\t\t\t\t\t\t    array_ended = false,\n\t\t\t\t\t\t    value = null;\n\n\t\t\t\t\t\tif (token.expression) {\n\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.params, context]).then(function (value) {\n\t\t\t\t\t\t\t\tstack.push(value);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\twhile (stack.length > 0) {\n\t\t\t\t\t\t\t\tvalue = stack.pop();\n\t\t\t\t\t\t\t\t// Push values into the array until the start of the array\n\t\t\t\t\t\t\t\tif (value && value.type && value.type == Twig.expression.type.parameter.start) {\n\t\t\t\t\t\t\t\t\tarray_ended = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnew_array.unshift(value);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!array_ended) {\n\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Expected end of parameter set.\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstack.push(new_array);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.expression.type.slice,\n\t\t\t\t\tregex: /^\\[(\\d*\\:\\d*)\\]/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar sliceRange = token.match[1].split(':');\n\n\t\t\t\t\t\t//sliceStart can be undefined when we pass parameters to the slice filter later\n\t\t\t\t\t\tvar sliceStart = sliceRange[0] ? parseInt(sliceRange[0]) : undefined;\n\t\t\t\t\t\tvar sliceEnd = sliceRange[1] ? parseInt(sliceRange[1]) : undefined;\n\n\t\t\t\t\t\ttoken.value = 'slice';\n\t\t\t\t\t\ttoken.params = [sliceStart, sliceEnd];\n\n\t\t\t\t\t\t//sliceEnd can't be undefined as the slice filter doesn't check for this, but it does check the length\n\t\t\t\t\t\t//of the params array, so just shorten it.\n\t\t\t\t\t\tif (!sliceEnd) {\n\t\t\t\t\t\t\ttoken.params = [sliceStart];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tvar input = stack.pop(),\n\t\t\t\t\t\t    params = token.params;\n\n\t\t\t\t\t\tstack.push(Twig.filter.apply(this, [token.value, input, params]));\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match an array start.\n      */\n\t\t\t\t\ttype: Twig.expression.type.array.start,\n\t\t\t\t\tregex: /^\\[/,\n\t\t\t\t\tnext: Twig.expression.set.expressions.concat([Twig.expression.type.array.end]),\n\t\t\t\t\tcompile: Twig.expression.fn.compile.push_both,\n\t\t\t\t\tparse: Twig.expression.fn.parse.push\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match an array end.\n      */\n\t\t\t\t\ttype: Twig.expression.type.array.end,\n\t\t\t\t\tregex: /^\\]/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar i = stack.length - 1,\n\t\t\t\t\t\t    stack_token;\n\t\t\t\t\t\t// pop tokens off the stack until the start of the object\n\t\t\t\t\t\tfor (; i >= 0; i--) {\n\t\t\t\t\t\t\tstack_token = stack.pop();\n\t\t\t\t\t\t\tif (stack_token.type === Twig.expression.type.array.start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toutput.push(stack_token);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tvar new_array = [],\n\t\t\t\t\t\t    array_ended = false,\n\t\t\t\t\t\t    value = null;\n\n\t\t\t\t\t\twhile (stack.length > 0) {\n\t\t\t\t\t\t\tvalue = stack.pop();\n\t\t\t\t\t\t\t// Push values into the array until the start of the array\n\t\t\t\t\t\t\tif (value.type && value.type == Twig.expression.type.array.start) {\n\t\t\t\t\t\t\t\tarray_ended = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnew_array.unshift(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!array_ended) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Expected end of array.\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstack.push(new_array);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Token that represents the start of a hash map '}'\n\t\t\t\t//\n\t\t\t\t// Hash maps take the form:\n\t\t\t\t//    { \"key\": 'value', \"another_key\": item }\n\t\t\t\t//\n\t\t\t\t// Keys must be quoted (either single or double) and values can be any expression.\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.expression.type.object.start,\n\t\t\t\t\tregex: /^\\{/,\n\t\t\t\t\tnext: Twig.expression.set.expressions.concat([Twig.expression.type.object.end]),\n\t\t\t\t\tcompile: Twig.expression.fn.compile.push_both,\n\t\t\t\t\tparse: Twig.expression.fn.parse.push\n\t\t\t\t},\n\n\t\t\t\t// Token that represents the end of a Hash Map '}'\n\t\t\t\t//\n\t\t\t\t// This is where the logic for building the internal\n\t\t\t\t// representation of a hash map is defined.\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.expression.type.object.end,\n\t\t\t\t\tregex: /^\\}/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar i = stack.length - 1,\n\t\t\t\t\t\t    stack_token;\n\n\t\t\t\t\t\t// pop tokens off the stack until the start of the object\n\t\t\t\t\t\tfor (; i >= 0; i--) {\n\t\t\t\t\t\t\tstack_token = stack.pop();\n\t\t\t\t\t\t\tif (stack_token && stack_token.type === Twig.expression.type.object.start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toutput.push(stack_token);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (end_token, stack, context) {\n\t\t\t\t\t\tvar new_object = {},\n\t\t\t\t\t\t    object_ended = false,\n\t\t\t\t\t\t    token = null,\n\t\t\t\t\t\t    token_key = null,\n\t\t\t\t\t\t    has_value = false,\n\t\t\t\t\t\t    value = null;\n\n\t\t\t\t\t\twhile (stack.length > 0) {\n\t\t\t\t\t\t\ttoken = stack.pop();\n\t\t\t\t\t\t\t// Push values into the array until the start of the object\n\t\t\t\t\t\t\tif (token && token.type && token.type === Twig.expression.type.object.start) {\n\t\t\t\t\t\t\t\tobject_ended = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (token && token.type && (token.type === Twig.expression.type.operator.binary || token.type === Twig.expression.type.operator.unary) && token.key) {\n\t\t\t\t\t\t\t\tif (!has_value) {\n\t\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Missing value for key '\" + token.key + \"' in object definition.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnew_object[token.key] = value;\n\n\t\t\t\t\t\t\t\t// Preserve the order that elements are added to the map\n\t\t\t\t\t\t\t\t// This is necessary since JavaScript objects don't\n\t\t\t\t\t\t\t\t// guarantee the order of keys\n\t\t\t\t\t\t\t\tif (new_object._keys === undefined) new_object._keys = [];\n\t\t\t\t\t\t\t\tnew_object._keys.unshift(token.key);\n\n\t\t\t\t\t\t\t\t// reset value check\n\t\t\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t\t\t\thas_value = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\thas_value = true;\n\t\t\t\t\t\t\t\tvalue = token;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!object_ended) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Unexpected end of object.\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstack.push(new_object);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Token representing a filter\n\t\t\t\t//\n\t\t\t\t// Filters can follow any expression and take the form:\n\t\t\t\t//    expression|filter(optional, args)\n\t\t\t\t//\n\t\t\t\t// Filter parsing is done in the Twig.filters namespace.\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.expression.type.filter,\n\t\t\t\t\t// match a | then a letter or _, then any number of letters, numbers, _ or -\n\t\t\t\t\tregex: /^\\|\\s?([a-zA-Z_][a-zA-Z0-9_\\-]*)/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended.concat([Twig.expression.type.parameter.start]),\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\ttoken.value = token.match[1];\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    input = stack.pop();\n\n\t\t\t\t\t\treturn parseParams(this, token.params, context).then(function (params) {\n\t\t\t\t\t\t\treturn Twig.filter.apply(that, [token.value, input, params]);\n\t\t\t\t\t\t}).then(function (value) {\n\t\t\t\t\t\t\tstack.push(value);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.expression.type._function,\n\t\t\t\t\t// match any letter or _, then any number of letters, numbers, _ or - followed by (\n\t\t\t\t\tregex: /^([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(/,\n\t\t\t\t\tnext: Twig.expression.type.parameter.start,\n\t\t\t\t\tvalidate: function (match, tokens) {\n\t\t\t\t\t\t// Make sure this function is not a reserved word\n\t\t\t\t\t\treturn match[1] && Twig.indexOf(Twig.expression.reservedWords, match[1]) < 0;\n\t\t\t\t\t},\n\t\t\t\t\ttransform: function (match, tokens) {\n\t\t\t\t\t\treturn '(';\n\t\t\t\t\t},\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar fn = token.match[1];\n\t\t\t\t\t\ttoken.fn = fn;\n\t\t\t\t\t\t// cleanup token\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\tdelete token.value;\n\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    fn = token.fn,\n\t\t\t\t\t\t    value;\n\n\t\t\t\t\t\treturn parseParams(this, token.params, context).then(function (params) {\n\t\t\t\t\t\t\tif (Twig.functions[fn]) {\n\t\t\t\t\t\t\t\t// Get the function from the built-in functions\n\t\t\t\t\t\t\t\tvalue = Twig.functions[fn].apply(that, params);\n\t\t\t\t\t\t\t} else if (typeof context[fn] == 'function') {\n\t\t\t\t\t\t\t\t// Get the function from the user/context defined functions\n\t\t\t\t\t\t\t\tvalue = context[fn].apply(context, params);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new Twig.Error(fn + ' function does not exist and is not defined in the context');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}).then(function (result) {\n\t\t\t\t\t\t\tstack.push(result);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Token representing a variable.\n\t\t\t\t//\n\t\t\t\t// Variables can contain letters, numbers, underscores and\n\t\t\t\t// dashes, but must start with a letter or underscore.\n\t\t\t\t//\n\t\t\t\t// Variables are retrieved from the render context and take\n\t\t\t\t// the value of 'undefined' if the given variable doesn't\n\t\t\t\t// exist in the context.\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.expression.type.variable,\n\t\t\t\t\t// match any letter or _, then any number of letters, numbers, _ or -\n\t\t\t\t\tregex: /^[a-zA-Z_][a-zA-Z0-9_]*/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended.concat([Twig.expression.type.parameter.start]),\n\t\t\t\t\tcompile: Twig.expression.fn.compile.push,\n\t\t\t\t\tvalidate: function (match, tokens) {\n\t\t\t\t\t\treturn Twig.indexOf(Twig.expression.reservedWords, match[0]) < 0;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\t// Get the variable from the context\n\t\t\t\t\t\treturn Twig.expression.resolveAsync.apply(this, [context[token.value], context]).then(function (value) {\n\t\t\t\t\t\t\tstack.push(value);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.expression.type.key.period,\n\t\t\t\t\tregex: /^\\.([a-zA-Z0-9_]+)/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended.concat([Twig.expression.type.parameter.start]),\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\ttoken.key = token.match[1];\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\tdelete token.value;\n\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context, next_token) {\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    key = token.key,\n\t\t\t\t\t\t    object = stack.pop(),\n\t\t\t\t\t\t    value;\n\n\t\t\t\t\t\treturn parseParams(this, token.params, context).then(function (params) {\n\t\t\t\t\t\t\tif (object === null || object === undefined) {\n\t\t\t\t\t\t\t\tif (that.options.strict_variables) {\n\t\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Can't access a key \" + key + \" on an null or undefined object.\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvalue = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar capitalize = function (value) {\n\t\t\t\t\t\t\t\t\treturn value.substr(0, 1).toUpperCase() + value.substr(1);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Get the variable from the context\n\t\t\t\t\t\t\t\tif (typeof object === 'object' && key in object) {\n\t\t\t\t\t\t\t\t\tvalue = object[key];\n\t\t\t\t\t\t\t\t} else if (object[\"get\" + capitalize(key)] !== undefined) {\n\t\t\t\t\t\t\t\t\tvalue = object[\"get\" + capitalize(key)];\n\t\t\t\t\t\t\t\t} else if (object[\"is\" + capitalize(key)] !== undefined) {\n\t\t\t\t\t\t\t\t\tvalue = object[\"is\" + capitalize(key)];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvalue = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// When resolving an expression we need to pass next_token in case the expression is a function\n\t\t\t\t\t\t\treturn Twig.expression.resolveAsync.apply(that, [value, context, params, next_token, object]);\n\t\t\t\t\t\t}).then(function (result) {\n\t\t\t\t\t\t\tstack.push(result);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.expression.type.key.brackets,\n\t\t\t\t\tregex: /^\\[([^\\]\\:]*)\\]/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended.concat([Twig.expression.type.parameter.start]),\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tvar match = token.match[1];\n\t\t\t\t\t\tdelete token.value;\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\t// The expression stack for the key\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile({\n\t\t\t\t\t\t\tvalue: match\n\t\t\t\t\t\t}).stack;\n\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, stack, context, next_token) {\n\t\t\t\t\t\t// Evaluate key\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    params = null,\n\t\t\t\t\t\t    object,\n\t\t\t\t\t\t    value;\n\n\t\t\t\t\t\treturn parseParams(this, token.params, context).then(function (parameters) {\n\t\t\t\t\t\t\tparams = parameters;\n\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(that, [token.stack, context]);\n\t\t\t\t\t\t}).then(function (key) {\n\t\t\t\t\t\t\tobject = stack.pop();\n\n\t\t\t\t\t\t\tif (object === null || object === undefined) {\n\t\t\t\t\t\t\t\tif (that.options.strict_variables) {\n\t\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Can't access a key \" + key + \" on an null or undefined object.\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the variable from the context\n\t\t\t\t\t\t\tif (typeof object === 'object' && key in object) {\n\t\t\t\t\t\t\t\tvalue = object[key];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// When resolving an expression we need to pass next_token in case the expression is a function\n\t\t\t\t\t\t\treturn Twig.expression.resolveAsync.apply(that, [value, object, params, next_token]);\n\t\t\t\t\t\t}).then(function (result) {\n\t\t\t\t\t\t\tstack.push(result);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a null value.\n      */\n\t\t\t\t\ttype: Twig.expression.type._null,\n\t\t\t\t\t// match a number\n\t\t\t\t\tregex: /^(null|NULL|none|NONE)/,\n\t\t\t\t\tnext: Twig.expression.set.operations,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\ttoken.value = null;\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: Twig.expression.fn.parse.push_value\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match the context\n      */\n\t\t\t\t\ttype: Twig.expression.type.context,\n\t\t\t\t\tregex: /^_context/,\n\t\t\t\t\tnext: Twig.expression.set.operations_extended.concat([Twig.expression.type.parameter.start]),\n\t\t\t\t\tcompile: Twig.expression.fn.compile.push,\n\t\t\t\t\tparse: function (token, stack, context) {\n\t\t\t\t\t\tstack.push(context);\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Match a boolean\n      */\n\t\t\t\t\ttype: Twig.expression.type.bool,\n\t\t\t\t\tregex: /^(true|TRUE|false|FALSE)/,\n\t\t\t\t\tnext: Twig.expression.set.operations,\n\t\t\t\t\tcompile: function (token, stack, output) {\n\t\t\t\t\t\ttoken.value = token.match[0].toLowerCase() === \"true\";\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\toutput.push(token);\n\t\t\t\t\t},\n\t\t\t\t\tparse: Twig.expression.fn.parse.push_value\n\t\t\t\t}];\n\n\t\t\t\t/**\n     * Resolve a context value.\n     *\n     * If the value is a function, it is executed with a context parameter.\n     *\n     * @param {string} key The context object key.\n     * @param {Object} context The render context.\n     */\n\t\t\t\tTwig.expression.resolveAsync = function (value, context, params, next_token, object) {\n\t\t\t\t\tif (typeof value == 'function') {\n\t\t\t\t\t\tvar promise = Twig.Promise.resolve(params);\n\n\t\t\t\t\t\t/*\n      If value is a function, it will have been impossible during the compile stage to determine that a following\n      set of parentheses were parameters for this function.\n       Those parentheses will have therefore been marked as an expression, with their own parameters, which really\n      belong to this function.\n       Those parameters will also need parsing in case they are actually an expression to pass as parameters.\n       */\n\t\t\t\t\t\tif (next_token && next_token.type === Twig.expression.type.parameter.end) {\n\t\t\t\t\t\t\t//When parsing these parameters, we need to get them all back, not just the last item on the stack.\n\t\t\t\t\t\t\tvar tokens_are_parameters = true;\n\n\t\t\t\t\t\t\tpromise = promise.then(function () {\n\t\t\t\t\t\t\t\treturn next_token.params && Twig.expression.parseAsync.apply(this, [next_token.params, context, tokens_are_parameters]);\n\t\t\t\t\t\t\t}).then(function (p) {\n\t\t\t\t\t\t\t\t//Clean up the parentheses tokens on the next loop\n\t\t\t\t\t\t\t\tnext_token.cleanup = true;\n\n\t\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn promise.then(function (params) {\n\t\t\t\t\t\t\treturn value.apply(object || context, params || []);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Twig.Promise.resolve(value);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tTwig.expression.resolve = function (value, context, params, next_token, object) {\n\t\t\t\t\tvar is_async = true,\n\t\t\t\t\t    result;\n\n\t\t\t\t\tTwig.expression.resolveAsync.apply(this, [value, context, params, next_token, object]).then(function (r) {\n\t\t\t\t\t\tis_async = false;\n\t\t\t\t\t\tresult = r;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (is_async) throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Registry for logic handlers.\n     */\n\t\t\t\tTwig.expression.handler = {};\n\n\t\t\t\t/**\n     * Define a new expression type, available at Twig.logic.type.{type}\n     *\n     * @param {string} type The name of the new type.\n     */\n\t\t\t\tTwig.expression.extendType = function (type) {\n\t\t\t\t\tTwig.expression.type[type] = \"Twig.expression.type.\" + type;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Extend the expression parsing functionality with a new definition.\n     *\n     * Token definitions follow this format:\n     *  {\n     *      type:     One of Twig.expression.type.[type], either pre-defined or added using\n     *                    Twig.expression.extendType\n     *\n     *      next:     Array of types from Twig.expression.type that can follow this token,\n     *\n     *      regex:    A regex or array of regex's that should match the token.\n     *\n     *      compile: function(token, stack, output) called when this token is being compiled.\n     *                   Should return an object with stack and output set.\n     *\n     *      parse:   function(token, stack, context) called when this token is being parsed.\n     *                   Should return an object with stack and context set.\n     *  }\n     *\n     * @param {Object} definition A token definition.\n     */\n\t\t\t\tTwig.expression.extend = function (definition) {\n\t\t\t\t\tif (!definition.type) {\n\t\t\t\t\t\tthrow new Twig.Error(\"Unable to extend logic definition. No type provided for \" + definition);\n\t\t\t\t\t}\n\t\t\t\t\tTwig.expression.handler[definition.type] = definition;\n\t\t\t\t};\n\n\t\t\t\t// Extend with built-in expressions\n\t\t\t\twhile (Twig.expression.definitions.length > 0) {\n\t\t\t\t\tTwig.expression.extend(Twig.expression.definitions.shift());\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Break an expression into tokens defined in Twig.expression.definitions.\n     *\n     * @param {string} expression The string to tokenize.\n     *\n     * @return {Array} An array of tokens.\n     */\n\t\t\t\tTwig.expression.tokenize = function (expression) {\n\t\t\t\t\tvar tokens = [],\n\n\t\t\t\t\t// Keep an offset of the location in the expression for error messages.\n\t\t\t\t\texp_offset = 0,\n\n\t\t\t\t\t// The valid next tokens of the previous token\n\t\t\t\t\tnext = null,\n\n\t\t\t\t\t// Match information\n\t\t\t\t\ttype,\n\t\t\t\t\t    regex,\n\t\t\t\t\t    regex_array,\n\n\t\t\t\t\t// The possible next token for the match\n\t\t\t\t\ttoken_next,\n\n\t\t\t\t\t// Has a match been found from the definitions\n\t\t\t\t\tmatch_found,\n\t\t\t\t\t    invalid_matches = [],\n\t\t\t\t\t    match_function;\n\n\t\t\t\t\tmatch_function = function () {\n\t\t\t\t\t\tvar match = Array.prototype.slice.apply(arguments),\n\t\t\t\t\t\t    string = match.pop(),\n\t\t\t\t\t\t    offset = match.pop();\n\n\t\t\t\t\t\tTwig.log.trace(\"Twig.expression.tokenize\", \"Matched a \", type, \" regular expression of \", match);\n\n\t\t\t\t\t\tif (next && Twig.indexOf(next, type) < 0) {\n\t\t\t\t\t\t\tinvalid_matches.push(type + \" cannot follow a \" + tokens[tokens.length - 1].type + \" at template:\" + exp_offset + \" near '\" + match[0].substring(0, 20) + \"...'\");\n\t\t\t\t\t\t\t// Not a match, don't change the expression\n\t\t\t\t\t\t\treturn match[0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Validate the token if a validation function is provided\n\t\t\t\t\t\tif (Twig.expression.handler[type].validate && !Twig.expression.handler[type].validate(match, tokens)) {\n\t\t\t\t\t\t\treturn match[0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinvalid_matches = [];\n\n\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\tmatch: match\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tmatch_found = true;\n\t\t\t\t\t\tnext = token_next;\n\t\t\t\t\t\texp_offset += match[0].length;\n\n\t\t\t\t\t\t// Does the token need to return output back to the expression string\n\t\t\t\t\t\t// e.g. a function match of cycle( might return the '(' back to the expression\n\t\t\t\t\t\t// This allows look-ahead to differentiate between token types (e.g. functions and variable names)\n\t\t\t\t\t\tif (Twig.expression.handler[type].transform) {\n\t\t\t\t\t\t\treturn Twig.expression.handler[type].transform(match, tokens);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t};\n\n\t\t\t\t\tTwig.log.debug(\"Twig.expression.tokenize\", \"Tokenizing expression \", expression);\n\n\t\t\t\t\twhile (expression.length > 0) {\n\t\t\t\t\t\texpression = expression.trim();\n\t\t\t\t\t\tfor (type in Twig.expression.handler) {\n\t\t\t\t\t\t\tif (Twig.expression.handler.hasOwnProperty(type)) {\n\t\t\t\t\t\t\t\ttoken_next = Twig.expression.handler[type].next;\n\t\t\t\t\t\t\t\tregex = Twig.expression.handler[type].regex;\n\t\t\t\t\t\t\t\tTwig.log.trace(\"Checking type \", type, \" on \", expression);\n\t\t\t\t\t\t\t\tif (regex instanceof Array) {\n\t\t\t\t\t\t\t\t\tregex_array = regex;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tregex_array = [regex];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tmatch_found = false;\n\t\t\t\t\t\t\t\twhile (regex_array.length > 0) {\n\t\t\t\t\t\t\t\t\tregex = regex_array.pop();\n\t\t\t\t\t\t\t\t\texpression = expression.replace(regex, match_function);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// An expression token has been matched. Break the for loop and start trying to\n\t\t\t\t\t\t\t\t//  match the next template (if expression isn't empty.)\n\t\t\t\t\t\t\t\tif (match_found) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!match_found) {\n\t\t\t\t\t\t\tif (invalid_matches.length > 0) {\n\t\t\t\t\t\t\t\tthrow new Twig.Error(invalid_matches.join(\" OR \"));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Unable to parse '\" + expression + \"' at template position\" + exp_offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTwig.log.trace(\"Twig.expression.tokenize\", \"Tokenized to \", tokens);\n\t\t\t\t\treturn tokens;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Compile an expression token.\n     *\n     * @param {Object} raw_token The uncompiled token.\n     *\n     * @return {Object} The compiled token.\n     */\n\t\t\t\tTwig.expression.compile = function (raw_token) {\n\t\t\t\t\tvar expression = raw_token.value,\n\n\t\t\t\t\t// Tokenize expression\n\t\t\t\t\ttokens = Twig.expression.tokenize(expression),\n\t\t\t\t\t    token = null,\n\t\t\t\t\t    output = [],\n\t\t\t\t\t    stack = [],\n\t\t\t\t\t    token_template = null;\n\n\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"Compiling \", expression);\n\n\t\t\t\t\t// Push tokens into RPN stack using the Shunting-yard algorithm\n\t\t\t\t\t// See http://en.wikipedia.org/wiki/Shunting_yard_algorithm\n\n\t\t\t\t\twhile (tokens.length > 0) {\n\t\t\t\t\t\ttoken = tokens.shift();\n\t\t\t\t\t\ttoken_template = Twig.expression.handler[token.type];\n\n\t\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"Compiling \", token);\n\n\t\t\t\t\t\t// Compile the template\n\t\t\t\t\t\ttoken_template.compile && token_template.compile(token, stack, output);\n\n\t\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"Stack is\", stack);\n\t\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"Output is\", output);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (stack.length > 0) {\n\t\t\t\t\t\toutput.push(stack.pop());\n\t\t\t\t\t}\n\n\t\t\t\t\tTwig.log.trace(\"Twig.expression.compile: \", \"Final output is\", output);\n\n\t\t\t\t\traw_token.stack = output;\n\t\t\t\t\tdelete raw_token.value;\n\n\t\t\t\t\treturn raw_token;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Parse an RPN expression stack within a context.\n     *\n     * @param {Array} tokens An array of compiled expression tokens.\n     * @param {Object} context The render context to parse the tokens with.\n     *\n     * @return {Object} The result of parsing all the tokens. The result\n     *                  can be anything, String, Array, Object, etc... based on\n     *                  the given expression.\n     */\n\t\t\t\tTwig.expression.parse = function (tokens, context, tokens_are_parameters, allow_async) {\n\t\t\t\t\tvar that = this;\n\n\t\t\t\t\t// If the token isn't an array, make it one.\n\t\t\t\t\tif (!(tokens instanceof Array)) {\n\t\t\t\t\t\ttokens = [tokens];\n\t\t\t\t\t}\n\n\t\t\t\t\t// The output stack\n\t\t\t\t\tvar stack = [],\n\t\t\t\t\t    next_token,\n\t\t\t\t\t    output = null,\n\t\t\t\t\t    promise = null,\n\t\t\t\t\t    is_async = true,\n\t\t\t\t\t    token_template = null,\n\t\t\t\t\t    loop_token_fixups = [];\n\n\t\t\t\t\tpromise = Twig.async.forEach(tokens, function (token, index) {\n\t\t\t\t\t\t//If the token is marked for cleanup, we don't need to parse it\n\t\t\t\t\t\tif (token.cleanup) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar result = null;\n\n\t\t\t\t\t\t//Determine the token that follows this one so that we can pass it to the parser\n\t\t\t\t\t\tif (tokens.length > index + 1) {\n\t\t\t\t\t\t\tnext_token = tokens[index + 1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttoken_template = Twig.expression.handler[token.type];\n\n\t\t\t\t\t\tif (token_template.parse) result = token_template.parse.apply(that, [token, stack, context, next_token]);\n\n\t\t\t\t\t\t//Store any binary tokens for later if we are in a loop.\n\t\t\t\t\t\tif (context.loop && token.type === Twig.expression.type.operator.binary) {\n\t\t\t\t\t\t\tloop_token_fixups.push(token);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}).then(function () {\n\t\t\t\t\t\t//Check every fixup and remove \"key\" as long as they still have \"params\". This covers the use case where\n\t\t\t\t\t\t//a \":\" operator is used in a loop with a \"(expression):\" statement. We need to be able to evaluate the expression\n\t\t\t\t\t\tTwig.forEach(loop_token_fixups, function (loop_token_fixup) {\n\t\t\t\t\t\t\tif (loop_token_fixup.params && loop_token_fixup.key) {\n\t\t\t\t\t\t\t\tdelete loop_token_fixup[\"key\"];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t//If parse has been called with a set of tokens that are parameters, we need to return the whole stack,\n\t\t\t\t\t\t//wrapped in an Array.\n\t\t\t\t\t\tif (tokens_are_parameters) {\n\t\t\t\t\t\t\tvar params = [];\n\t\t\t\t\t\t\twhile (stack.length > 0) {\n\t\t\t\t\t\t\t\tparams.unshift(stack.pop());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstack.push(params);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (allow_async) return Twig.Promise.resolve(stack.pop());\n\t\t\t\t\t}).then(function (v) {\n\t\t\t\t\t\tis_async = false;\n\t\t\t\t\t\treturn v;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (allow_async) return promise;\n\n\t\t\t\t\tif (is_async) throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t\t\t\t\t// Pop the final value off the stack\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 4 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.expression.operator.js\n\t\t\t//\n\t\t\t// This file handles operator lookups and parsing.\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\t/**\n     * Operator associativity constants.\n     */\n\n\t\t\t\tTwig.expression.operator = {\n\t\t\t\t\tleftToRight: 'leftToRight',\n\t\t\t\t\trightToLeft: 'rightToLeft'\n\t\t\t\t};\n\n\t\t\t\tvar containment = function (a, b) {\n\t\t\t\t\tif (b === undefined || b === null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else if (b.indexOf !== undefined) {\n\t\t\t\t\t\t// String\n\t\t\t\t\t\treturn a === b || a !== '' && b.indexOf(a) > -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar el;\n\t\t\t\t\t\tfor (el in b) {\n\t\t\t\t\t\t\tif (b.hasOwnProperty(el) && b[el] === a) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Get the precidence and associativity of an operator. These follow the order that C/C++ use.\n     * See http://en.wikipedia.org/wiki/Operators_in_C_and_C++ for the table of values.\n     */\n\t\t\t\tTwig.expression.operator.lookup = function (operator, token) {\n\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\tcase \"..\":\n\t\t\t\t\t\t\ttoken.precidence = 20;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\ttoken.precidence = 18;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// Ternary\n\t\t\t\t\t\tcase '?:':\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\tcase ':':\n\t\t\t\t\t\t\ttoken.precidence = 16;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.rightToLeft;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'or':\n\t\t\t\t\t\t\ttoken.precidence = 14;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'and':\n\t\t\t\t\t\t\ttoken.precidence = 13;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b-or':\n\t\t\t\t\t\t\ttoken.precidence = 12;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b-xor':\n\t\t\t\t\t\t\ttoken.precidence = 11;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b-and':\n\t\t\t\t\t\t\ttoken.precidence = 10;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '==':\n\t\t\t\t\t\tcase '!=':\n\t\t\t\t\t\t\ttoken.precidence = 9;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\tcase '<=':\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\tcase '>=':\n\t\t\t\t\t\tcase 'not in':\n\t\t\t\t\t\tcase 'in':\n\t\t\t\t\t\t\ttoken.precidence = 8;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '~': // String concatination\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\ttoken.precidence = 6;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '//':\n\t\t\t\t\t\tcase '**':\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\ttoken.precidence = 5;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.leftToRight;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'not':\n\t\t\t\t\t\t\ttoken.precidence = 3;\n\t\t\t\t\t\t\ttoken.associativity = Twig.expression.operator.rightToLeft;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Failed to lookup operator: \" + operator + \" is an unknown operator.\");\n\t\t\t\t\t}\n\t\t\t\t\ttoken.operator = operator;\n\t\t\t\t\treturn token;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Handle operations on the RPN stack.\n     *\n     * Returns the updated stack.\n     */\n\t\t\t\tTwig.expression.operator.parse = function (operator, stack) {\n\t\t\t\t\tTwig.log.trace(\"Twig.expression.operator.parse: \", \"Handling \", operator);\n\t\t\t\t\tvar a, b, c;\n\n\t\t\t\t\tif (operator === '?') {\n\t\t\t\t\t\tc = stack.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tb = stack.pop();\n\t\t\t\t\tif (operator !== 'not') {\n\t\t\t\t\t\ta = stack.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (operator !== 'in' && operator !== 'not in') {\n\t\t\t\t\t\tif (a && Array.isArray(a)) {\n\t\t\t\t\t\t\ta = a.length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (b && Array.isArray(b)) {\n\t\t\t\t\t\t\tb = b.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\tcase ':':\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '?:':\n\t\t\t\t\t\t\tif (Twig.lib.boolval(a)) {\n\t\t\t\t\t\t\t\tstack.push(a);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstack.push(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tif (a === undefined) {\n\t\t\t\t\t\t\t\t//An extended ternary.\n\t\t\t\t\t\t\t\ta = b;\n\t\t\t\t\t\t\t\tb = c;\n\t\t\t\t\t\t\t\tc = undefined;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (Twig.lib.boolval(a)) {\n\t\t\t\t\t\t\t\tstack.push(b);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tb = parseFloat(b);\n\t\t\t\t\t\t\ta = parseFloat(a);\n\t\t\t\t\t\t\tstack.push(a + b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tb = parseFloat(b);\n\t\t\t\t\t\t\ta = parseFloat(a);\n\t\t\t\t\t\t\tstack.push(a - b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tb = parseFloat(b);\n\t\t\t\t\t\t\ta = parseFloat(a);\n\t\t\t\t\t\t\tstack.push(a * b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\tb = parseFloat(b);\n\t\t\t\t\t\t\ta = parseFloat(a);\n\t\t\t\t\t\t\tstack.push(a / b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '//':\n\t\t\t\t\t\t\tb = parseFloat(b);\n\t\t\t\t\t\t\ta = parseFloat(a);\n\t\t\t\t\t\t\tstack.push(Math.floor(a / b));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tb = parseFloat(b);\n\t\t\t\t\t\t\ta = parseFloat(a);\n\t\t\t\t\t\t\tstack.push(a % b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '~':\n\t\t\t\t\t\t\tstack.push((a != null ? a.toString() : \"\") + (b != null ? b.toString() : \"\"));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'not':\n\t\t\t\t\t\tcase '!':\n\t\t\t\t\t\t\tstack.push(!Twig.lib.boolval(b));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tstack.push(a < b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '<=':\n\t\t\t\t\t\t\tstack.push(a <= b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tstack.push(a > b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '>=':\n\t\t\t\t\t\t\tstack.push(a >= b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '===':\n\t\t\t\t\t\t\tstack.push(a === b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '==':\n\t\t\t\t\t\t\tstack.push(a == b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '!==':\n\t\t\t\t\t\t\tstack.push(a !== b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '!=':\n\t\t\t\t\t\t\tstack.push(a != b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'or':\n\t\t\t\t\t\t\tstack.push(a || b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b-or':\n\t\t\t\t\t\t\tstack.push(a | b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b-xor':\n\t\t\t\t\t\t\tstack.push(a ^ b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'and':\n\t\t\t\t\t\t\tstack.push(a && b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b-and':\n\t\t\t\t\t\t\tstack.push(a & b);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '**':\n\t\t\t\t\t\t\tstack.push(Math.pow(a, b));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'not in':\n\t\t\t\t\t\t\tstack.push(!containment(a, b));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'in':\n\t\t\t\t\t\t\tstack.push(containment(a, b));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase '..':\n\t\t\t\t\t\t\tstack.push(Twig.functions.range(a, b));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdebugger;\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Failed to parse operator: \" + operator + \" is an unknown operator.\");\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 5 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.filters.js\n\t\t\t//\n\t\t\t// This file handles parsing filters.\n\t\t\tmodule.exports = function (Twig) {\n\n\t\t\t\t// Determine object type\n\t\t\t\tfunction is(type, obj) {\n\t\t\t\t\tvar clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t\t\t\t\treturn obj !== undefined && obj !== null && clas === type;\n\t\t\t\t}\n\n\t\t\t\tTwig.filters = {\n\t\t\t\t\t// String Filters\n\t\t\t\t\tupper: function (value) {\n\t\t\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn value.toUpperCase();\n\t\t\t\t\t},\n\t\t\t\t\tlower: function (value) {\n\t\t\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn value.toLowerCase();\n\t\t\t\t\t},\n\t\t\t\t\tcapitalize: function (value) {\n\t\t\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn value.substr(0, 1).toUpperCase() + value.toLowerCase().substr(1);\n\t\t\t\t\t},\n\t\t\t\t\ttitle: function (value) {\n\t\t\t\t\t\tif (typeof value !== \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn value.toLowerCase().replace(/(^|\\s)([a-z])/g, function (m, p1, p2) {\n\t\t\t\t\t\t\treturn p1 + p2.toUpperCase();\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tlength: function (value) {\n\t\t\t\t\t\tif (Twig.lib.is(\"Array\", value) || typeof value === \"string\") {\n\t\t\t\t\t\t\treturn value.length;\n\t\t\t\t\t\t} else if (Twig.lib.is(\"Object\", value)) {\n\t\t\t\t\t\t\tif (value._keys === undefined) {\n\t\t\t\t\t\t\t\treturn Object.keys(value).length;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn value._keys.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// Array/Object Filters\n\t\t\t\t\treverse: function (value) {\n\t\t\t\t\t\tif (is(\"Array\", value)) {\n\t\t\t\t\t\t\treturn value.reverse();\n\t\t\t\t\t\t} else if (is(\"String\", value)) {\n\t\t\t\t\t\t\treturn value.split(\"\").reverse().join(\"\");\n\t\t\t\t\t\t} else if (is(\"Object\", value)) {\n\t\t\t\t\t\t\tvar keys = value._keys || Object.keys(value).reverse();\n\t\t\t\t\t\t\tvalue._keys = keys;\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsort: function (value) {\n\t\t\t\t\t\tif (is(\"Array\", value)) {\n\t\t\t\t\t\t\treturn value.sort();\n\t\t\t\t\t\t} else if (is('Object', value)) {\n\t\t\t\t\t\t\t// Sorting objects isn't obvious since the order of\n\t\t\t\t\t\t\t// returned keys isn't guaranteed in JavaScript.\n\t\t\t\t\t\t\t// Because of this we use a \"hidden\" key called _keys to\n\t\t\t\t\t\t\t// store the keys in the order we want to return them.\n\n\t\t\t\t\t\t\tdelete value._keys;\n\t\t\t\t\t\t\tvar keys = Object.keys(value),\n\t\t\t\t\t\t\t    sorted_keys = keys.sort(function (a, b) {\n\t\t\t\t\t\t\t\tvar a1, a2;\n\n\t\t\t\t\t\t\t\t// if a and b are comparable, we're fine :-)\n\t\t\t\t\t\t\t\tif (value[a] > value[b] == !(value[a] <= value[b])) {\n\t\t\t\t\t\t\t\t\treturn value[a] > value[b] ? 1 : value[a] < value[b] ? -1 : 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// if a and b can be parsed as numbers, we can compare\n\t\t\t\t\t\t\t\t// their numeric value\n\t\t\t\t\t\t\t\telse if (!isNaN(a1 = parseFloat(value[a])) && !isNaN(b1 = parseFloat(value[b]))) {\n\t\t\t\t\t\t\t\t\t\treturn a1 > b1 ? 1 : a1 < b1 ? -1 : 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// if one of the values is a string, we convert the\n\t\t\t\t\t\t\t\t\t// other value to string as well\n\t\t\t\t\t\t\t\t\telse if (typeof value[a] == 'string') {\n\t\t\t\t\t\t\t\t\t\t\treturn value[a] > value[b].toString() ? 1 : value[a] < value[b].toString() ? -1 : 0;\n\t\t\t\t\t\t\t\t\t\t} else if (typeof value[b] == 'string') {\n\t\t\t\t\t\t\t\t\t\t\treturn value[a].toString() > value[b] ? 1 : value[a].toString() < value[b] ? -1 : 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// everything failed - return 'null' as sign, that\n\t\t\t\t\t\t\t\t\t\t// the values are not comparable\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tvalue._keys = sorted_keys;\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tkeys: function (value) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar keyset = value._keys || Object.keys(value),\n\t\t\t\t\t\t    output = [];\n\n\t\t\t\t\t\tTwig.forEach(keyset, function (key) {\n\t\t\t\t\t\t\tif (key === \"_keys\") return; // Ignore the _keys property\n\t\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\toutput.push(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn output;\n\t\t\t\t\t},\n\t\t\t\t\turl_encode: function (value) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar result = encodeURIComponent(value);\n\t\t\t\t\t\tresult = result.replace(\"'\", \"%27\");\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t},\n\t\t\t\t\tjoin: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar join_str = \"\",\n\t\t\t\t\t\t    output = [],\n\t\t\t\t\t\t    keyset = null;\n\n\t\t\t\t\t\tif (params && params[0]) {\n\t\t\t\t\t\t\tjoin_str = params[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is(\"Array\", value)) {\n\t\t\t\t\t\t\toutput = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkeyset = value._keys || Object.keys(value);\n\t\t\t\t\t\t\tTwig.forEach(keyset, function (key) {\n\t\t\t\t\t\t\t\tif (key === \"_keys\") return; // Ignore the _keys property\n\t\t\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\toutput.push(value[key]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn output.join(join_str);\n\t\t\t\t\t},\n\t\t\t\t\t\"default\": function (value, params) {\n\t\t\t\t\t\tif (params !== undefined && params.length > 1) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"default filter expects one argument\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value === undefined || value === null || value === '') {\n\t\t\t\t\t\t\tif (params === undefined) {\n\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn params[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tjson_encode: function (value) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn \"null\";\n\t\t\t\t\t\t} else if (typeof value == 'object' && is(\"Array\", value)) {\n\t\t\t\t\t\t\toutput = [];\n\n\t\t\t\t\t\t\tTwig.forEach(value, function (v) {\n\t\t\t\t\t\t\t\toutput.push(Twig.filters.json_encode(v));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn \"[\" + output.join(\",\") + \"]\";\n\t\t\t\t\t\t} else if (typeof value == 'object') {\n\t\t\t\t\t\t\tvar keyset = value._keys || Object.keys(value),\n\t\t\t\t\t\t\t    output = [];\n\n\t\t\t\t\t\t\tTwig.forEach(keyset, function (key) {\n\t\t\t\t\t\t\t\toutput.push(JSON.stringify(key) + \":\" + Twig.filters.json_encode(value[key]));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn \"{\" + output.join(\",\") + \"}\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmerge: function (value, params) {\n\t\t\t\t\t\tvar obj = [],\n\t\t\t\t\t\t    arr_index = 0,\n\t\t\t\t\t\t    keyset = [];\n\n\t\t\t\t\t\t// Check to see if all the objects being merged are arrays\n\t\t\t\t\t\tif (!is(\"Array\", value)) {\n\t\t\t\t\t\t\t// Create obj as an Object\n\t\t\t\t\t\t\tobj = {};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tTwig.forEach(params, function (param) {\n\t\t\t\t\t\t\t\tif (!is(\"Array\", param)) {\n\t\t\t\t\t\t\t\t\tobj = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!is(\"Array\", obj)) {\n\t\t\t\t\t\t\tobj._keys = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (is(\"Array\", value)) {\n\t\t\t\t\t\t\tTwig.forEach(value, function (val) {\n\t\t\t\t\t\t\t\tif (obj._keys) obj._keys.push(arr_index);\n\t\t\t\t\t\t\t\tobj[arr_index] = val;\n\t\t\t\t\t\t\t\tarr_index++;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkeyset = value._keys || Object.keys(value);\n\t\t\t\t\t\t\tTwig.forEach(keyset, function (key) {\n\t\t\t\t\t\t\t\tobj[key] = value[key];\n\t\t\t\t\t\t\t\tobj._keys.push(key);\n\n\t\t\t\t\t\t\t\t// Handle edge case where a number index in an object is greater than\n\t\t\t\t\t\t\t\t//   the array counter. In such a case, the array counter is increased\n\t\t\t\t\t\t\t\t//   one past the index.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Example {{ [\"a\", \"b\"]|merge({\"4\":\"value\"}, [\"c\", \"d\"])\n\t\t\t\t\t\t\t\t// Without this, d would have an index of \"4\" and overwrite the value\n\t\t\t\t\t\t\t\t//   of \"value\"\n\t\t\t\t\t\t\t\tvar int_key = parseInt(key, 10);\n\t\t\t\t\t\t\t\tif (!isNaN(int_key) && int_key >= arr_index) {\n\t\t\t\t\t\t\t\t\tarr_index = int_key + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// mixin the merge arrays\n\t\t\t\t\t\tTwig.forEach(params, function (param) {\n\t\t\t\t\t\t\tif (is(\"Array\", param)) {\n\t\t\t\t\t\t\t\tTwig.forEach(param, function (val) {\n\t\t\t\t\t\t\t\t\tif (obj._keys) obj._keys.push(arr_index);\n\t\t\t\t\t\t\t\t\tobj[arr_index] = val;\n\t\t\t\t\t\t\t\t\tarr_index++;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tkeyset = param._keys || Object.keys(param);\n\t\t\t\t\t\t\t\tTwig.forEach(keyset, function (key) {\n\t\t\t\t\t\t\t\t\tif (!obj[key]) obj._keys.push(key);\n\t\t\t\t\t\t\t\t\tobj[key] = param[key];\n\n\t\t\t\t\t\t\t\t\tvar int_key = parseInt(key, 10);\n\t\t\t\t\t\t\t\t\tif (!isNaN(int_key) && int_key >= arr_index) {\n\t\t\t\t\t\t\t\t\t\tarr_index = int_key + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (params.length === 0) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Filter merge expects at least one parameter\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t},\n\t\t\t\t\tdate: function (value, params) {\n\t\t\t\t\t\tvar date = Twig.functions.date(value);\n\t\t\t\t\t\tvar format = params && params.length ? params[0] : 'F j, Y H:i';\n\t\t\t\t\t\treturn Twig.lib.date(format, date);\n\t\t\t\t\t},\n\n\t\t\t\t\tdate_modify: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (params === undefined || params.length !== 1) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"date_modify filter expects 1 argument\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar modifyText = params[0],\n\t\t\t\t\t\t    time;\n\n\t\t\t\t\t\tif (Twig.lib.is(\"Date\", value)) {\n\t\t\t\t\t\t\ttime = Twig.lib.strtotime(modifyText, value.getTime() / 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Twig.lib.is(\"String\", value)) {\n\t\t\t\t\t\t\ttime = Twig.lib.strtotime(modifyText, Twig.lib.strtotime(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Twig.lib.is(\"Number\", value)) {\n\t\t\t\t\t\t\ttime = Twig.lib.strtotime(modifyText, value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn new Date(time * 1000);\n\t\t\t\t\t},\n\n\t\t\t\t\treplace: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar pairs = params[0],\n\t\t\t\t\t\t    tag;\n\t\t\t\t\t\tfor (tag in pairs) {\n\t\t\t\t\t\t\tif (pairs.hasOwnProperty(tag) && tag !== \"_keys\") {\n\t\t\t\t\t\t\t\tvalue = Twig.lib.replaceAll(value, tag, pairs[tag]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\n\t\t\t\t\tformat: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Twig.lib.vsprintf(value, params);\n\t\t\t\t\t},\n\n\t\t\t\t\tstriptags: function (value) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Twig.lib.strip_tags(value);\n\t\t\t\t\t},\n\n\t\t\t\t\tescape: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar strategy = \"html\";\n\t\t\t\t\t\tif (params && params.length && params[0] !== true) strategy = params[0];\n\n\t\t\t\t\t\tif (strategy == \"html\") {\n\t\t\t\t\t\t\tvar raw_value = value.toString().replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n\t\t\t\t\t\t\treturn Twig.Markup(raw_value, 'html');\n\t\t\t\t\t\t} else if (strategy == \"js\") {\n\t\t\t\t\t\t\tvar raw_value = value.toString();\n\t\t\t\t\t\t\tvar result = \"\";\n\n\t\t\t\t\t\t\tfor (var i = 0; i < raw_value.length; i++) {\n\t\t\t\t\t\t\t\tif (raw_value[i].match(/^[a-zA-Z0-9,\\._]$/)) result += raw_value[i];else {\n\t\t\t\t\t\t\t\t\tvar char_code = raw_value.charCodeAt(i);\n\n\t\t\t\t\t\t\t\t\tif (char_code < 0x80) result += \"\\\\x\" + char_code.toString(16).toUpperCase();else result += Twig.lib.sprintf(\"\\\\u%04s\", char_code.toString(16).toUpperCase());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn Twig.Markup(result, 'js');\n\t\t\t\t\t\t} else if (strategy == \"css\") {\n\t\t\t\t\t\t\tvar raw_value = value.toString();\n\t\t\t\t\t\t\tvar result = \"\";\n\n\t\t\t\t\t\t\tfor (var i = 0; i < raw_value.length; i++) {\n\t\t\t\t\t\t\t\tif (raw_value[i].match(/^[a-zA-Z0-9]$/)) result += raw_value[i];else {\n\t\t\t\t\t\t\t\t\tvar char_code = raw_value.charCodeAt(i);\n\t\t\t\t\t\t\t\t\tresult += \"\\\\\" + char_code.toString(16).toUpperCase() + \" \";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn Twig.Markup(result, 'css');\n\t\t\t\t\t\t} else if (strategy == \"url\") {\n\t\t\t\t\t\t\tvar result = Twig.filters.url_encode(value);\n\t\t\t\t\t\t\treturn Twig.Markup(result, 'url');\n\t\t\t\t\t\t} else if (strategy == \"html_attr\") {\n\t\t\t\t\t\t\tvar raw_value = value.toString();\n\t\t\t\t\t\t\tvar result = \"\";\n\n\t\t\t\t\t\t\tfor (var i = 0; i < raw_value.length; i++) {\n\t\t\t\t\t\t\t\tif (raw_value[i].match(/^[a-zA-Z0-9,\\.\\-_]$/)) result += raw_value[i];else if (raw_value[i].match(/^[&<>\"]$/)) result += raw_value[i].replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\");else {\n\t\t\t\t\t\t\t\t\tvar char_code = raw_value.charCodeAt(i);\n\n\t\t\t\t\t\t\t\t\t// The following replaces characters undefined in HTML with\n\t\t\t\t\t\t\t\t\t// the hex entity for the Unicode replacement character.\n\t\t\t\t\t\t\t\t\tif (char_code <= 0x1f && char_code != 0x09 && char_code != 0x0a && char_code != 0x0d) result += \"&#xFFFD;\";else if (char_code < 0x80) result += Twig.lib.sprintf(\"&#x%02s;\", char_code.toString(16).toUpperCase());else result += Twig.lib.sprintf(\"&#x%04s;\", char_code.toString(16).toUpperCase());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn Twig.Markup(result, 'html_attr');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"escape strategy unsupported\");\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/* Alias of escape */\n\t\t\t\t\t\"e\": function (value, params) {\n\t\t\t\t\t\treturn Twig.filters.escape(value, params);\n\t\t\t\t\t},\n\n\t\t\t\t\tnl2br: function (value) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar linebreak_tag = \"BACKSLASH_n_replace\",\n\t\t\t\t\t\t    br = \"<br />\" + linebreak_tag;\n\n\t\t\t\t\t\tvalue = Twig.filters.escape(value).replace(/\\r\\n/g, br).replace(/\\r/g, br).replace(/\\n/g, br);\n\n\t\t\t\t\t\tvalue = Twig.lib.replaceAll(value, linebreak_tag, \"\\n\");\n\n\t\t\t\t\t\treturn Twig.Markup(value);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Adapted from: http://phpjs.org/functions/number_format:481\n      */\n\t\t\t\t\tnumber_format: function (value, params) {\n\t\t\t\t\t\tvar number = value,\n\t\t\t\t\t\t    decimals = params && params[0] ? params[0] : undefined,\n\t\t\t\t\t\t    dec = params && params[1] !== undefined ? params[1] : \".\",\n\t\t\t\t\t\t    sep = params && params[2] !== undefined ? params[2] : \",\";\n\n\t\t\t\t\t\tnumber = (number + '').replace(/[^0-9+\\-Ee.]/g, '');\n\t\t\t\t\t\tvar n = !isFinite(+number) ? 0 : +number,\n\t\t\t\t\t\t    prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),\n\t\t\t\t\t\t    s = '',\n\t\t\t\t\t\t    toFixedFix = function (n, prec) {\n\t\t\t\t\t\t\tvar k = Math.pow(10, prec);\n\t\t\t\t\t\t\treturn '' + Math.round(n * k) / k;\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// Fix for IE parseFloat(0.55).toFixed(0) = 0;\n\t\t\t\t\t\ts = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.');\n\t\t\t\t\t\tif (s[0].length > 3) {\n\t\t\t\t\t\t\ts[0] = s[0].replace(/\\B(?=(?:\\d{3})+(?!\\d))/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((s[1] || '').length < prec) {\n\t\t\t\t\t\t\ts[1] = s[1] || '';\n\t\t\t\t\t\t\ts[1] += new Array(prec - s[1].length + 1).join('0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn s.join(dec);\n\t\t\t\t\t},\n\n\t\t\t\t\ttrim: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar str = Twig.filters.escape('' + value),\n\t\t\t\t\t\t    whitespace;\n\t\t\t\t\t\tif (params && params[0]) {\n\t\t\t\t\t\t\twhitespace = '' + params[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhitespace = ' \\n\\r\\t\\f\\x0b\\xa0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u3000';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (var i = 0; i < str.length; i++) {\n\t\t\t\t\t\t\tif (whitespace.indexOf(str.charAt(i)) === -1) {\n\t\t\t\t\t\t\t\tstr = str.substring(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = str.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tif (whitespace.indexOf(str.charAt(i)) === -1) {\n\t\t\t\t\t\t\t\tstr = str.substring(0, i + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn whitespace.indexOf(str.charAt(0)) === -1 ? str : '';\n\t\t\t\t\t},\n\n\t\t\t\t\ttruncate: function (value, params) {\n\t\t\t\t\t\tvar length = 30,\n\t\t\t\t\t\t    preserve = false,\n\t\t\t\t\t\t    separator = '...';\n\n\t\t\t\t\t\tvalue = value + '';\n\t\t\t\t\t\tif (params) {\n\t\t\t\t\t\t\tif (params[0]) {\n\t\t\t\t\t\t\t\tlength = params[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (params[1]) {\n\t\t\t\t\t\t\t\tpreserve = params[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (params[2]) {\n\t\t\t\t\t\t\t\tseparator = params[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (value.length > length) {\n\n\t\t\t\t\t\t\tif (preserve) {\n\t\t\t\t\t\t\t\tlength = value.indexOf(' ', length);\n\t\t\t\t\t\t\t\tif (length === -1) {\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalue = value.substr(0, length) + separator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\n\t\t\t\t\tslice: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (params === undefined || params.length < 1) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"slice filter expects at least 1 argument\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// default to start of string\n\t\t\t\t\t\tvar start = params[0] || 0;\n\t\t\t\t\t\t// default to length of string\n\t\t\t\t\t\tvar length = params.length > 1 ? params[1] : value.length;\n\t\t\t\t\t\t// handle negative start values\n\t\t\t\t\t\tvar startIndex = start >= 0 ? start : Math.max(value.length + start, 0);\n\n\t\t\t\t\t\tif (Twig.lib.is(\"Array\", value)) {\n\t\t\t\t\t\t\tvar output = [];\n\t\t\t\t\t\t\tfor (var i = startIndex; i < startIndex + length && i < value.length; i++) {\n\t\t\t\t\t\t\t\toutput.push(value[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn output;\n\t\t\t\t\t\t} else if (Twig.lib.is(\"String\", value)) {\n\t\t\t\t\t\t\treturn value.substr(startIndex, length);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"slice filter expects value to be an array or string\");\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tabs: function (value) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Math.abs(value);\n\t\t\t\t\t},\n\n\t\t\t\t\tfirst: function (value) {\n\t\t\t\t\t\tif (is(\"Array\", value)) {\n\t\t\t\t\t\t\treturn value[0];\n\t\t\t\t\t\t} else if (is(\"Object\", value)) {\n\t\t\t\t\t\t\tif ('_keys' in value) {\n\t\t\t\t\t\t\t\treturn value[value._keys[0]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (typeof value === \"string\") {\n\t\t\t\t\t\t\treturn value.substr(0, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\n\t\t\t\t\tsplit: function (value, params) {\n\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (params === undefined || params.length < 1 || params.length > 2) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"split filter expects 1 or 2 argument\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Twig.lib.is(\"String\", value)) {\n\t\t\t\t\t\t\tvar delimiter = params[0],\n\t\t\t\t\t\t\t    limit = params[1],\n\t\t\t\t\t\t\t    split = value.split(delimiter);\n\n\t\t\t\t\t\t\tif (limit === undefined) {\n\n\t\t\t\t\t\t\t\treturn split;\n\t\t\t\t\t\t\t} else if (limit < 0) {\n\n\t\t\t\t\t\t\t\treturn value.split(delimiter, split.length + limit);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar limitedSplit = [];\n\n\t\t\t\t\t\t\t\tif (delimiter == '') {\n\t\t\t\t\t\t\t\t\t// empty delimiter\n\t\t\t\t\t\t\t\t\t// \"aabbcc\"|split('', 2)\n\t\t\t\t\t\t\t\t\t//     -> ['aa', 'bb', 'cc']\n\n\t\t\t\t\t\t\t\t\twhile (split.length > 0) {\n\t\t\t\t\t\t\t\t\t\tvar temp = \"\";\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < limit && split.length > 0; i++) {\n\t\t\t\t\t\t\t\t\t\t\ttemp += split.shift();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlimitedSplit.push(temp);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// non-empty delimiter\n\t\t\t\t\t\t\t\t\t// \"one,two,three,four,five\"|split(',', 3)\n\t\t\t\t\t\t\t\t\t//     -> ['one', 'two', 'three,four,five']\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < limit - 1 && split.length > 0; i++) {\n\t\t\t\t\t\t\t\t\t\tlimitedSplit.push(split.shift());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (split.length > 0) {\n\t\t\t\t\t\t\t\t\t\tlimitedSplit.push(split.join(delimiter));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn limitedSplit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"split filter expects value to be a string\");\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tlast: function (value) {\n\t\t\t\t\t\tif (Twig.lib.is('Object', value)) {\n\t\t\t\t\t\t\tvar keys;\n\n\t\t\t\t\t\t\tif (value._keys === undefined) {\n\t\t\t\t\t\t\t\tkeys = Object.keys(value);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tkeys = value._keys;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn value[keys[keys.length - 1]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// string|array\n\t\t\t\t\t\treturn value[value.length - 1];\n\t\t\t\t\t},\n\t\t\t\t\traw: function (value) {\n\t\t\t\t\t\treturn Twig.Markup(value);\n\t\t\t\t\t},\n\t\t\t\t\tbatch: function (items, params) {\n\t\t\t\t\t\tvar size = params.shift(),\n\t\t\t\t\t\t    fill = params.shift(),\n\t\t\t\t\t\t    result,\n\t\t\t\t\t\t    last,\n\t\t\t\t\t\t    missing;\n\n\t\t\t\t\t\tif (!Twig.lib.is(\"Array\", items)) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"batch filter expects items to be an array\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!Twig.lib.is(\"Number\", size)) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"batch filter expects size to be a number\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsize = Math.ceil(size);\n\n\t\t\t\t\t\tresult = Twig.lib.chunkArray(items, size);\n\n\t\t\t\t\t\tif (fill && items.length % size != 0) {\n\t\t\t\t\t\t\tlast = result.pop();\n\t\t\t\t\t\t\tmissing = size - last.length;\n\n\t\t\t\t\t\t\twhile (missing--) {\n\t\t\t\t\t\t\t\tlast.push(fill);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tresult.push(last);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t},\n\t\t\t\t\tround: function (value, params) {\n\t\t\t\t\t\tparams = params || [];\n\n\t\t\t\t\t\tvar precision = params.length > 0 ? params[0] : 0,\n\t\t\t\t\t\t    method = params.length > 1 ? params[1] : \"common\";\n\n\t\t\t\t\t\tvalue = parseFloat(value);\n\n\t\t\t\t\t\tif (precision && !Twig.lib.is(\"Number\", precision)) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"round filter expects precision to be a number\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (method === \"common\") {\n\t\t\t\t\t\t\treturn Twig.lib.round(value, precision);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!Twig.lib.is(\"Function\", Math[method])) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"round filter expects method to be 'floor', 'ceil', or 'common'\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Math[method](value * Math.pow(10, precision)) / Math.pow(10, precision);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tTwig.filter = function (filter, value, params) {\n\t\t\t\t\tif (!Twig.filters[filter]) {\n\t\t\t\t\t\tthrow \"Unable to find filter \" + filter;\n\t\t\t\t\t}\n\t\t\t\t\treturn Twig.filters[filter].apply(this, [value, params]);\n\t\t\t\t};\n\n\t\t\t\tTwig.filter.extend = function (filter, definition) {\n\t\t\t\t\tTwig.filters[filter] = definition;\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 6 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.functions.js\n\t\t\t//\n\t\t\t// This file handles parsing filters.\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t/**\n     * @constant\n     * @type {string}\n     */\n\t\t\t\tvar TEMPLATE_NOT_FOUND_MESSAGE = 'Template \"{name}\" is not defined.';\n\n\t\t\t\t// Determine object type\n\t\t\t\tfunction is(type, obj) {\n\t\t\t\t\tvar clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t\t\t\t\treturn obj !== undefined && obj !== null && clas === type;\n\t\t\t\t}\n\n\t\t\t\tTwig.functions = {\n\t\t\t\t\t//  attribute, block, constant, date, dump, parent, random,.\n\n\t\t\t\t\t// Range function from http://phpjs.org/functions/range:499\n\t\t\t\t\t// Used under an MIT License\n\t\t\t\t\trange: function (low, high, step) {\n\t\t\t\t\t\t// http://kevin.vanzonneveld.net\n\t\t\t\t\t\t// +   original by: Waldo Malqui Silva\n\t\t\t\t\t\t// *     example 1: range ( 0, 12 );\n\t\t\t\t\t\t// *     returns 1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\t\t\t\t\t\t// *     example 2: range( 0, 100, 10 );\n\t\t\t\t\t\t// *     returns 2: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n\t\t\t\t\t\t// *     example 3: range( 'a', 'i' );\n\t\t\t\t\t\t// *     returns 3: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n\t\t\t\t\t\t// *     example 4: range( 'c', 'a' );\n\t\t\t\t\t\t// *     returns 4: ['c', 'b', 'a']\n\t\t\t\t\t\tvar matrix = [];\n\t\t\t\t\t\tvar inival, endval, plus;\n\t\t\t\t\t\tvar walker = step || 1;\n\t\t\t\t\t\tvar chars = false;\n\n\t\t\t\t\t\tif (!isNaN(low) && !isNaN(high)) {\n\t\t\t\t\t\t\tinival = parseInt(low, 10);\n\t\t\t\t\t\t\tendval = parseInt(high, 10);\n\t\t\t\t\t\t} else if (isNaN(low) && isNaN(high)) {\n\t\t\t\t\t\t\tchars = true;\n\t\t\t\t\t\t\tinival = low.charCodeAt(0);\n\t\t\t\t\t\t\tendval = high.charCodeAt(0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinival = isNaN(low) ? 0 : low;\n\t\t\t\t\t\t\tendval = isNaN(high) ? 0 : high;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplus = inival > endval ? false : true;\n\t\t\t\t\t\tif (plus) {\n\t\t\t\t\t\t\twhile (inival <= endval) {\n\t\t\t\t\t\t\t\tmatrix.push(chars ? String.fromCharCode(inival) : inival);\n\t\t\t\t\t\t\t\tinival += walker;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (inival >= endval) {\n\t\t\t\t\t\t\t\tmatrix.push(chars ? String.fromCharCode(inival) : inival);\n\t\t\t\t\t\t\t\tinival -= walker;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn matrix;\n\t\t\t\t\t},\n\t\t\t\t\tcycle: function (arr, i) {\n\t\t\t\t\t\tvar pos = i % arr.length;\n\t\t\t\t\t\treturn arr[pos];\n\t\t\t\t\t},\n\t\t\t\t\tdump: function () {\n\t\t\t\t\t\tvar EOL = '\\n',\n\t\t\t\t\t\t    indentChar = '  ',\n\t\t\t\t\t\t    indentTimes = 0,\n\t\t\t\t\t\t    out = '',\n\t\t\t\t\t\t    args = Array.prototype.slice.call(arguments),\n\t\t\t\t\t\t    indent = function (times) {\n\t\t\t\t\t\t\tvar ind = '';\n\t\t\t\t\t\t\twhile (times > 0) {\n\t\t\t\t\t\t\t\ttimes--;\n\t\t\t\t\t\t\t\tind += indentChar;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ind;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t    displayVar = function (variable) {\n\t\t\t\t\t\t\tout += indent(indentTimes);\n\t\t\t\t\t\t\tif (typeof variable === 'object') {\n\t\t\t\t\t\t\t\tdumpVar(variable);\n\t\t\t\t\t\t\t} else if (typeof variable === 'function') {\n\t\t\t\t\t\t\t\tout += 'function()' + EOL;\n\t\t\t\t\t\t\t} else if (typeof variable === 'string') {\n\t\t\t\t\t\t\t\tout += 'string(' + variable.length + ') \"' + variable + '\"' + EOL;\n\t\t\t\t\t\t\t} else if (typeof variable === 'number') {\n\t\t\t\t\t\t\t\tout += 'number(' + variable + ')' + EOL;\n\t\t\t\t\t\t\t} else if (typeof variable === 'boolean') {\n\t\t\t\t\t\t\t\tout += 'bool(' + variable + ')' + EOL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t    dumpVar = function (variable) {\n\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\tif (variable === null) {\n\t\t\t\t\t\t\t\tout += 'NULL' + EOL;\n\t\t\t\t\t\t\t} else if (variable === undefined) {\n\t\t\t\t\t\t\t\tout += 'undefined' + EOL;\n\t\t\t\t\t\t\t} else if (typeof variable === 'object') {\n\t\t\t\t\t\t\t\tout += indent(indentTimes) + typeof variable;\n\t\t\t\t\t\t\t\tindentTimes++;\n\t\t\t\t\t\t\t\tout += '(' + function (obj) {\n\t\t\t\t\t\t\t\t\tvar size = 0,\n\t\t\t\t\t\t\t\t\t    key;\n\t\t\t\t\t\t\t\t\tfor (key in obj) {\n\t\t\t\t\t\t\t\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\t\t\tsize++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t\t\t}(variable) + ') {' + EOL;\n\t\t\t\t\t\t\t\tfor (i in variable) {\n\t\t\t\t\t\t\t\t\tout += indent(indentTimes) + '[' + i + ']=> ' + EOL;\n\t\t\t\t\t\t\t\t\tdisplayVar(variable[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tindentTimes--;\n\t\t\t\t\t\t\t\tout += indent(indentTimes) + '}' + EOL;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdisplayVar(variable);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// handle no argument case by dumping the entire render context\n\t\t\t\t\t\tif (args.length == 0) args.push(this.context);\n\n\t\t\t\t\t\tTwig.forEach(args, function (variable) {\n\t\t\t\t\t\t\tdumpVar(variable);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn out;\n\t\t\t\t\t},\n\t\t\t\t\tdate: function (date, time) {\n\t\t\t\t\t\tvar dateObj;\n\t\t\t\t\t\tif (date === undefined || date === null || date === \"\") {\n\t\t\t\t\t\t\tdateObj = new Date();\n\t\t\t\t\t\t} else if (Twig.lib.is(\"Date\", date)) {\n\t\t\t\t\t\t\tdateObj = date;\n\t\t\t\t\t\t} else if (Twig.lib.is(\"String\", date)) {\n\t\t\t\t\t\t\tif (date.match(/^[0-9]+$/)) {\n\t\t\t\t\t\t\t\tdateObj = new Date(date * 1000);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdateObj = new Date(Twig.lib.strtotime(date) * 1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (Twig.lib.is(\"Number\", date)) {\n\t\t\t\t\t\t\t// timestamp\n\t\t\t\t\t\t\tdateObj = new Date(date * 1000);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Unable to parse date \" + date);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn dateObj;\n\t\t\t\t\t},\n\t\t\t\t\tblock: function (block) {\n\t\t\t\t\t\tif (this.originalBlockTokens[block]) {\n\t\t\t\t\t\t\treturn Twig.logic.parse.apply(this, [this.originalBlockTokens[block], this.context]).output;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn this.blocks[block];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tparent: function () {\n\t\t\t\t\t\t// Add a placeholder\n\t\t\t\t\t\treturn Twig.placeholders.parent;\n\t\t\t\t\t},\n\t\t\t\t\tattribute: function (object, method, params) {\n\t\t\t\t\t\tif (Twig.lib.is('Object', object)) {\n\t\t\t\t\t\t\tif (object.hasOwnProperty(method)) {\n\t\t\t\t\t\t\t\tif (typeof object[method] === \"function\") {\n\t\t\t\t\t\t\t\t\treturn object[method].apply(undefined, params);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn object[method];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Array will return element 0-index\n\t\t\t\t\t\treturn object[method] || undefined;\n\t\t\t\t\t},\n\t\t\t\t\tmax: function (values) {\n\t\t\t\t\t\tif (Twig.lib.is(\"Object\", values)) {\n\t\t\t\t\t\t\tdelete values[\"_keys\"];\n\t\t\t\t\t\t\treturn Twig.lib.max(values);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Twig.lib.max.apply(null, arguments);\n\t\t\t\t\t},\n\t\t\t\t\tmin: function (values) {\n\t\t\t\t\t\tif (Twig.lib.is(\"Object\", values)) {\n\t\t\t\t\t\t\tdelete values[\"_keys\"];\n\t\t\t\t\t\t\treturn Twig.lib.min(values);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Twig.lib.min.apply(null, arguments);\n\t\t\t\t\t},\n\t\t\t\t\ttemplate_from_string: function (template) {\n\t\t\t\t\t\tif (template === undefined) {\n\t\t\t\t\t\t\ttemplate = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Twig.Templates.parsers.twig({\n\t\t\t\t\t\t\toptions: this.options,\n\t\t\t\t\t\t\tdata: template\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\trandom: function (value) {\n\t\t\t\t\t\tvar LIMIT_INT31 = 0x80000000;\n\n\t\t\t\t\t\tfunction getRandomNumber(n) {\n\t\t\t\t\t\t\tvar random = Math.floor(Math.random() * LIMIT_INT31);\n\t\t\t\t\t\t\tvar limits = [0, n];\n\t\t\t\t\t\t\tvar min = Math.min.apply(null, limits),\n\t\t\t\t\t\t\t    max = Math.max.apply(null, limits);\n\t\t\t\t\t\t\treturn min + Math.floor((max - min + 1) * random / LIMIT_INT31);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Twig.lib.is(\"Number\", value)) {\n\t\t\t\t\t\t\treturn getRandomNumber(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Twig.lib.is(\"String\", value)) {\n\t\t\t\t\t\t\treturn value.charAt(getRandomNumber(value.length - 1));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Twig.lib.is(\"Array\", value)) {\n\t\t\t\t\t\t\treturn value[getRandomNumber(value.length - 1)];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Twig.lib.is(\"Object\", value)) {\n\t\t\t\t\t\t\tvar keys = Object.keys(value);\n\t\t\t\t\t\t\treturn value[keys[getRandomNumber(keys.length - 1)]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn getRandomNumber(LIMIT_INT31 - 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Returns the content of a template without rendering it\n      * @param {string} name\n      * @param {boolean} [ignore_missing=false]\n      * @returns {string}\n      */\n\t\t\t\t\tsource: function (name, ignore_missing) {\n\t\t\t\t\t\tvar templateSource;\n\t\t\t\t\t\tvar templateFound = false;\n\t\t\t\t\t\tvar isNodeEnvironment = typeof module !== 'undefined' && typeof module.exports !== 'undefined' && typeof window === 'undefined';\n\t\t\t\t\t\tvar loader;\n\t\t\t\t\t\tvar path;\n\n\t\t\t\t\t\t//if we are running in a node.js environment, set the loader to 'fs' and ensure the\n\t\t\t\t\t\t// path is relative to the CWD of the running script\n\t\t\t\t\t\t//else, set the loader to 'ajax' and set the path to the value of name\n\t\t\t\t\t\tif (isNodeEnvironment) {\n\t\t\t\t\t\t\tloader = 'fs';\n\t\t\t\t\t\t\tpath = __dirname + '/' + name;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tloader = 'ajax';\n\t\t\t\t\t\t\tpath = name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//build the params object\n\t\t\t\t\t\tvar params = {\n\t\t\t\t\t\t\tid: name,\n\t\t\t\t\t\t\tpath: path,\n\t\t\t\t\t\t\tmethod: loader,\n\t\t\t\t\t\t\tparser: 'source',\n\t\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\t\tfetchTemplateSource: true\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t//default ignore_missing to false\n\t\t\t\t\t\tif (typeof ignore_missing === 'undefined') {\n\t\t\t\t\t\t\tignore_missing = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//try to load the remote template\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//on exception, log it\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttemplateSource = Twig.Templates.loadRemote(name, params);\n\n\t\t\t\t\t\t\t//if the template is undefined or null, set the template to an empty string and do NOT flip the\n\t\t\t\t\t\t\t// boolean indicating we found the template\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t//else, all is good! flip the boolean indicating we found the template\n\t\t\t\t\t\t\tif (typeof templateSource === 'undefined' || templateSource === null) {\n\t\t\t\t\t\t\t\ttemplateSource = '';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttemplateFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tTwig.log.debug('Twig.functions.source: ', 'Problem loading template  ', e);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//if the template was NOT found AND we are not ignoring missing templates, return the same message\n\t\t\t\t\t\t// that is returned by the PHP implementation of the twig source() function\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//else, return the template source\n\t\t\t\t\t\tif (!templateFound && !ignore_missing) {\n\t\t\t\t\t\t\treturn TEMPLATE_NOT_FOUND_MESSAGE.replace('{name}', name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn templateSource;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tTwig._function = function (_function, value, params) {\n\t\t\t\t\tif (!Twig.functions[_function]) {\n\t\t\t\t\t\tthrow \"Unable to find function \" + _function;\n\t\t\t\t\t}\n\t\t\t\t\treturn Twig.functions[_function](value, params);\n\t\t\t\t};\n\n\t\t\t\tTwig._function.extend = function (_function, definition) {\n\t\t\t\t\tTwig.functions[_function] = definition;\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 7 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t// ## twig.lib.js\n\t\t\t//\n\t\t\t// This file contains 3rd party libraries used within twig.\n\t\t\t//\n\t\t\t// Copies of the licenses for the code included here can be found in the\n\t\t\t// LICENSES.md file.\n\t\t\t//\n\n\t\t\tmodule.exports = function (Twig) {\n\n\t\t\t\t// Namespace for libraries\n\t\t\t\tTwig.lib = {};\n\n\t\t\t\tTwig.lib.sprintf = __webpack_require__(8);\n\t\t\t\tTwig.lib.vsprintf = __webpack_require__(9);\n\t\t\t\tTwig.lib.round = __webpack_require__(10);\n\t\t\t\tTwig.lib.max = __webpack_require__(11);\n\t\t\t\tTwig.lib.min = __webpack_require__(12);\n\t\t\t\tTwig.lib.strip_tags = __webpack_require__(13);\n\t\t\t\tTwig.lib.strtotime = __webpack_require__(14);\n\t\t\t\tTwig.lib.date = __webpack_require__(15);\n\t\t\t\tTwig.lib.boolval = __webpack_require__(16);\n\n\t\t\t\tTwig.lib.is = function (type, obj) {\n\t\t\t\t\tvar clas = Object.prototype.toString.call(obj).slice(8, -1);\n\t\t\t\t\treturn obj !== undefined && obj !== null && clas === type;\n\t\t\t\t};\n\n\t\t\t\t// shallow-copy an object\n\t\t\t\tTwig.lib.copy = function (src) {\n\t\t\t\t\tvar target = {},\n\t\t\t\t\t    key;\n\t\t\t\t\tfor (key in src) target[key] = src[key];\n\n\t\t\t\t\treturn target;\n\t\t\t\t};\n\n\t\t\t\tTwig.lib.extend = function (src, add) {\n\t\t\t\t\tvar keys = Object.keys(add),\n\t\t\t\t\t    i;\n\n\t\t\t\t\ti = keys.length;\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tsrc[keys[i]] = add[keys[i]];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn src;\n\t\t\t\t};\n\n\t\t\t\tTwig.lib.replaceAll = function (string, search, replace) {\n\t\t\t\t\treturn string.split(search).join(replace);\n\t\t\t\t};\n\n\t\t\t\t// chunk an array (arr) into arrays of (size) items, returns an array of arrays, or an empty array on invalid input\n\t\t\t\tTwig.lib.chunkArray = function (arr, size) {\n\t\t\t\t\tvar returnVal = [],\n\t\t\t\t\t    x = 0,\n\t\t\t\t\t    len = arr.length;\n\n\t\t\t\t\tif (size < 1 || !Twig.lib.is(\"Array\", arr)) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (x < len) {\n\t\t\t\t\t\treturnVal.push(arr.slice(x, x += size));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn returnVal;\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 8 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function sprintf() {\n\t\t\t\t//  discuss at: http://locutus.io/php/sprintf/\n\t\t\t\t// original by: Ash Searle (http://hexmen.com/blog/)\n\t\t\t\t// improved by: Michael White (http://getsprink.com)\n\t\t\t\t// improved by: Jack\n\t\t\t\t// improved by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// improved by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// improved by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// improved by: Dj\n\t\t\t\t// improved by: Allidylls\n\t\t\t\t//    input by: Paulo Freitas\n\t\t\t\t//    input by: Brett Zamir (http://brett-zamir.me)\n\t\t\t\t//   example 1: sprintf(\"%01.2f\", 123.1)\n\t\t\t\t//   returns 1: '123.10'\n\t\t\t\t//   example 2: sprintf(\"[%10s]\", 'monkey')\n\t\t\t\t//   returns 2: '[    monkey]'\n\t\t\t\t//   example 3: sprintf(\"[%'#10s]\", 'monkey')\n\t\t\t\t//   returns 3: '[####monkey]'\n\t\t\t\t//   example 4: sprintf(\"%d\", 123456789012345)\n\t\t\t\t//   returns 4: '123456789012345'\n\t\t\t\t//   example 5: sprintf('%-03s', 'E')\n\t\t\t\t//   returns 5: 'E00'\n\n\t\t\t\tvar regex = /%%|%(\\d+\\$)?([-+'#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(?:\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuideEfFgG])/g;\n\t\t\t\tvar a = arguments;\n\t\t\t\tvar i = 0;\n\t\t\t\tvar format = a[i++];\n\n\t\t\t\tvar _pad = function _pad(str, len, chr, leftJustify) {\n\t\t\t\t\tif (!chr) {\n\t\t\t\t\t\tchr = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tvar padding = str.length >= len ? '' : new Array(1 + len - str.length >>> 0).join(chr);\n\t\t\t\t\treturn leftJustify ? str + padding : padding + str;\n\t\t\t\t};\n\n\t\t\t\tvar justify = function justify(value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {\n\t\t\t\t\tvar diff = minWidth - value.length;\n\t\t\t\t\tif (diff > 0) {\n\t\t\t\t\t\tif (leftJustify || !zeroPad) {\n\t\t\t\t\t\t\tvalue = _pad(value, minWidth, customPadChar, leftJustify);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = [value.slice(0, prefix.length), _pad('', diff, '0', true), value.slice(prefix.length)].join('');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\n\t\t\t\tvar _formatBaseX = function _formatBaseX(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {\n\t\t\t\t\t// Note: casts negative numbers to positive ones\n\t\t\t\t\tvar number = value >>> 0;\n\t\t\t\t\tprefix = prefix && number && {\n\t\t\t\t\t\t'2': '0b',\n\t\t\t\t\t\t'8': '0',\n\t\t\t\t\t\t'16': '0x'\n\t\t\t\t\t}[base] || '';\n\t\t\t\t\tvalue = prefix + _pad(number.toString(base), precision || 0, '0', false);\n\t\t\t\t\treturn justify(value, prefix, leftJustify, minWidth, zeroPad);\n\t\t\t\t};\n\n\t\t\t\t// _formatString()\n\t\t\t\tvar _formatString = function _formatString(value, leftJustify, minWidth, precision, zeroPad, customPadChar) {\n\t\t\t\t\tif (precision !== null && precision !== undefined) {\n\t\t\t\t\t\tvalue = value.slice(0, precision);\n\t\t\t\t\t}\n\t\t\t\t\treturn justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);\n\t\t\t\t};\n\n\t\t\t\t// doFormat()\n\t\t\t\tvar doFormat = function doFormat(substring, valueIndex, flags, minWidth, precision, type) {\n\t\t\t\t\tvar number, prefix, method, textTransform, value;\n\n\t\t\t\t\tif (substring === '%%') {\n\t\t\t\t\t\treturn '%';\n\t\t\t\t\t}\n\n\t\t\t\t\t// parse flags\n\t\t\t\t\tvar leftJustify = false;\n\t\t\t\t\tvar positivePrefix = '';\n\t\t\t\t\tvar zeroPad = false;\n\t\t\t\t\tvar prefixBaseX = false;\n\t\t\t\t\tvar customPadChar = ' ';\n\t\t\t\t\tvar flagsl = flags.length;\n\t\t\t\t\tvar j;\n\t\t\t\t\tfor (j = 0; j < flagsl; j++) {\n\t\t\t\t\t\tswitch (flags.charAt(j)) {\n\t\t\t\t\t\t\tcase ' ':\n\t\t\t\t\t\t\t\tpositivePrefix = ' ';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\t\tpositivePrefix = '+';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\tleftJustify = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\t\t\tcustomPadChar = flags.charAt(j + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '0':\n\t\t\t\t\t\t\t\tzeroPad = true;\n\t\t\t\t\t\t\t\tcustomPadChar = '0';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\t\tprefixBaseX = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// parameters may be null, undefined, empty-string or real valued\n\t\t\t\t\t// we want to ignore null, undefined and empty-string values\n\t\t\t\t\tif (!minWidth) {\n\t\t\t\t\t\tminWidth = 0;\n\t\t\t\t\t} else if (minWidth === '*') {\n\t\t\t\t\t\tminWidth = +a[i++];\n\t\t\t\t\t} else if (minWidth.charAt(0) === '*') {\n\t\t\t\t\t\tminWidth = +a[minWidth.slice(1, -1)];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminWidth = +minWidth;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: undocumented perl feature:\n\t\t\t\t\tif (minWidth < 0) {\n\t\t\t\t\t\tminWidth = -minWidth;\n\t\t\t\t\t\tleftJustify = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isFinite(minWidth)) {\n\t\t\t\t\t\tthrow new Error('sprintf: (minimum-)width must be finite');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!precision) {\n\t\t\t\t\t\tprecision = 'fFeE'.indexOf(type) > -1 ? 6 : type === 'd' ? 0 : undefined;\n\t\t\t\t\t} else if (precision === '*') {\n\t\t\t\t\t\tprecision = +a[i++];\n\t\t\t\t\t} else if (precision.charAt(0) === '*') {\n\t\t\t\t\t\tprecision = +a[precision.slice(1, -1)];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprecision = +precision;\n\t\t\t\t\t}\n\n\t\t\t\t\t// grab value using valueIndex if required?\n\t\t\t\t\tvalue = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];\n\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\t\treturn _formatString(value + '', leftJustify, minWidth, precision, zeroPad, customPadChar);\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn _formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\treturn _formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t\t\t\t\t\tcase 'o':\n\t\t\t\t\t\t\treturn _formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t\t\t\t\t\tcase 'x':\n\t\t\t\t\t\t\treturn _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t\t\t\t\t\tcase 'X':\n\t\t\t\t\t\t\treturn _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();\n\t\t\t\t\t\tcase 'u':\n\t\t\t\t\t\t\treturn _formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\tnumber = +value || 0;\n\t\t\t\t\t\t\t// Plain Math.round doesn't just truncate\n\t\t\t\t\t\t\tnumber = Math.round(number - number % 1);\n\t\t\t\t\t\t\tprefix = number < 0 ? '-' : positivePrefix;\n\t\t\t\t\t\t\tvalue = prefix + _pad(String(Math.abs(number)), precision, '0', false);\n\t\t\t\t\t\t\treturn justify(value, prefix, leftJustify, minWidth, zeroPad);\n\t\t\t\t\t\tcase 'e':\n\t\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tcase 'f': // @todo: Should handle locales (as per setlocale)\n\t\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tcase 'g':\n\t\t\t\t\t\tcase 'G':\n\t\t\t\t\t\t\tnumber = +value;\n\t\t\t\t\t\t\tprefix = number < 0 ? '-' : positivePrefix;\n\t\t\t\t\t\t\tmethod = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\n\t\t\t\t\t\t\ttextTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\n\t\t\t\t\t\t\tvalue = prefix + Math.abs(number)[method](precision);\n\t\t\t\t\t\t\treturn justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn substring;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\treturn format.replace(regex, doFormat);\n\t\t\t};\n\t\t\t//# sourceMappingURL=sprintf.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 9 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function vsprintf(format, args) {\n\t\t\t\t//  discuss at: http://locutus.io/php/vsprintf/\n\t\t\t\t// original by: ejsanders\n\t\t\t\t//   example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1])\n\t\t\t\t//   returns 1: '1988-08-01'\n\n\t\t\t\tvar sprintf = __webpack_require__(8);\n\n\t\t\t\treturn sprintf.apply(this, [format].concat(args));\n\t\t\t};\n\t\t\t//# sourceMappingURL=vsprintf.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 10 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function round(value, precision, mode) {\n\t\t\t\t//  discuss at: http://locutus.io/php/round/\n\t\t\t\t// original by: Philip Peterson\n\t\t\t\t//  revised by: Onno Marsman (https://twitter.com/onnomarsman)\n\t\t\t\t//  revised by: T.Wild\n\t\t\t\t//  revised by: Rafa Kukawski (http://blog.kukawski.pl)\n\t\t\t\t//    input by: Greenseed\n\t\t\t\t//    input by: meo\n\t\t\t\t//    input by: William\n\t\t\t\t//    input by: Josep Sanz (http://www.ws3.es/)\n\t\t\t\t// bugfixed by: Brett Zamir (http://brett-zamir.me)\n\t\t\t\t//      note 1: Great work. Ideas for improvement:\n\t\t\t\t//      note 1: - code more compliant with developer guidelines\n\t\t\t\t//      note 1: - for implementing PHP constant arguments look at\n\t\t\t\t//      note 1: the pathinfo() function, it offers the greatest\n\t\t\t\t//      note 1: flexibility & compatibility possible\n\t\t\t\t//   example 1: round(1241757, -3)\n\t\t\t\t//   returns 1: 1242000\n\t\t\t\t//   example 2: round(3.6)\n\t\t\t\t//   returns 2: 4\n\t\t\t\t//   example 3: round(2.835, 2)\n\t\t\t\t//   returns 3: 2.84\n\t\t\t\t//   example 4: round(1.1749999999999, 2)\n\t\t\t\t//   returns 4: 1.17\n\t\t\t\t//   example 5: round(58551.799999999996, 2)\n\t\t\t\t//   returns 5: 58551.8\n\n\t\t\t\tvar m, f, isHalf, sgn; // helper variables\n\t\t\t\t// making sure precision is integer\n\t\t\t\tprecision |= 0;\n\t\t\t\tm = Math.pow(10, precision);\n\t\t\t\tvalue *= m;\n\t\t\t\t// sign of the number\n\t\t\t\tsgn = value > 0 | -(value < 0);\n\t\t\t\tisHalf = value % 1 === 0.5 * sgn;\n\t\t\t\tf = Math.floor(value);\n\n\t\t\t\tif (isHalf) {\n\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\tcase 'PHP_ROUND_HALF_DOWN':\n\t\t\t\t\t\t\t// rounds .5 toward zero\n\t\t\t\t\t\t\tvalue = f + (sgn < 0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'PHP_ROUND_HALF_EVEN':\n\t\t\t\t\t\t\t// rouds .5 towards the next even integer\n\t\t\t\t\t\t\tvalue = f + f % 2 * sgn;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'PHP_ROUND_HALF_ODD':\n\t\t\t\t\t\t\t// rounds .5 towards the next odd integer\n\t\t\t\t\t\t\tvalue = f + !(f % 2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// rounds .5 away from zero\n\t\t\t\t\t\t\tvalue = f + (sgn > 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn (isHalf ? value : Math.round(value)) / m;\n\t\t\t};\n\t\t\t//# sourceMappingURL=round.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 11 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t\t\t\treturn typeof obj;\n\t\t\t} : function (obj) {\n\t\t\t\treturn obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t\t\t};\n\n\t\t\tmodule.exports = function max() {\n\t\t\t\t//  discuss at: http://locutus.io/php/max/\n\t\t\t\t// original by: Onno Marsman (https://twitter.com/onnomarsman)\n\t\t\t\t//  revised by: Onno Marsman (https://twitter.com/onnomarsman)\n\t\t\t\t// improved by: Jack\n\t\t\t\t//      note 1: Long code cause we're aiming for maximum PHP compatibility\n\t\t\t\t//   example 1: max(1, 3, 5, 6, 7)\n\t\t\t\t//   returns 1: 7\n\t\t\t\t//   example 2: max([2, 4, 5])\n\t\t\t\t//   returns 2: 5\n\t\t\t\t//   example 3: max(0, 'hello')\n\t\t\t\t//   returns 3: 0\n\t\t\t\t//   example 4: max('hello', 0)\n\t\t\t\t//   returns 4: 'hello'\n\t\t\t\t//   example 5: max(-1, 'hello')\n\t\t\t\t//   returns 5: 'hello'\n\t\t\t\t//   example 6: max([2, 4, 8], [2, 5, 7])\n\t\t\t\t//   returns 6: [2, 5, 7]\n\n\t\t\t\tvar ar;\n\t\t\t\tvar retVal;\n\t\t\t\tvar i = 0;\n\t\t\t\tvar n = 0;\n\t\t\t\tvar argv = arguments;\n\t\t\t\tvar argc = argv.length;\n\t\t\t\tvar _obj2Array = function _obj2Array(obj) {\n\t\t\t\t\tif (Object.prototype.toString.call(obj) === '[object Array]') {\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar ar = [];\n\t\t\t\t\t\tfor (var i in obj) {\n\t\t\t\t\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\tar.push(obj[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ar;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvar _compare = function _compare(current, next) {\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tvar n = 0;\n\t\t\t\t\tvar tmp = 0;\n\t\t\t\t\tvar nl = 0;\n\t\t\t\t\tvar cl = 0;\n\n\t\t\t\t\tif (current === next) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {\n\t\t\t\t\t\tif ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t\t\t\t\t\t\tcurrent = _obj2Array(current);\n\t\t\t\t\t\t\tnext = _obj2Array(next);\n\t\t\t\t\t\t\tcl = current.length;\n\t\t\t\t\t\t\tnl = next.length;\n\t\t\t\t\t\t\tif (nl > cl) {\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t} else if (nl < cl) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 0, n = cl; i < n; ++i) {\n\t\t\t\t\t\t\t\ttmp = _compare(current[i], next[i]);\n\t\t\t\t\t\t\t\tif (tmp === 1) {\n\t\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t\t} else if (tmp === -1) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else if (isNaN(next) && !isNaN(current)) {\n\t\t\t\t\t\tif (current === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn current < 0 ? 1 : -1;\n\t\t\t\t\t} else if (isNaN(current) && !isNaN(next)) {\n\t\t\t\t\t\tif (next === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn next > 0 ? 1 : -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (next === current) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn next > current ? 1 : -1;\n\t\t\t\t};\n\n\t\t\t\tif (argc === 0) {\n\t\t\t\t\tthrow new Error('At least one value should be passed to max()');\n\t\t\t\t} else if (argc === 1) {\n\t\t\t\t\tif (_typeof(argv[0]) === 'object') {\n\t\t\t\t\t\tar = _obj2Array(argv[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wrong parameter count for max()');\n\t\t\t\t\t}\n\t\t\t\t\tif (ar.length === 0) {\n\t\t\t\t\t\tthrow new Error('Array must contain at least one element for max()');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tar = argv;\n\t\t\t\t}\n\n\t\t\t\tretVal = ar[0];\n\t\t\t\tfor (i = 1, n = ar.length; i < n; ++i) {\n\t\t\t\t\tif (_compare(retVal, ar[i]) === 1) {\n\t\t\t\t\t\tretVal = ar[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t};\n\t\t\t//# sourceMappingURL=max.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 12 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t\t\t\treturn typeof obj;\n\t\t\t} : function (obj) {\n\t\t\t\treturn obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t\t\t};\n\n\t\t\tmodule.exports = function min() {\n\t\t\t\t//  discuss at: http://locutus.io/php/min/\n\t\t\t\t// original by: Onno Marsman (https://twitter.com/onnomarsman)\n\t\t\t\t//  revised by: Onno Marsman (https://twitter.com/onnomarsman)\n\t\t\t\t// improved by: Jack\n\t\t\t\t//      note 1: Long code cause we're aiming for maximum PHP compatibility\n\t\t\t\t//   example 1: min(1, 3, 5, 6, 7)\n\t\t\t\t//   returns 1: 1\n\t\t\t\t//   example 2: min([2, 4, 5])\n\t\t\t\t//   returns 2: 2\n\t\t\t\t//   example 3: min(0, 'hello')\n\t\t\t\t//   returns 3: 0\n\t\t\t\t//   example 4: min('hello', 0)\n\t\t\t\t//   returns 4: 'hello'\n\t\t\t\t//   example 5: min(-1, 'hello')\n\t\t\t\t//   returns 5: -1\n\t\t\t\t//   example 6: min([2, 4, 8], [2, 5, 7])\n\t\t\t\t//   returns 6: [2, 4, 8]\n\n\t\t\t\tvar ar;\n\t\t\t\tvar retVal;\n\t\t\t\tvar i = 0;\n\t\t\t\tvar n = 0;\n\t\t\t\tvar argv = arguments;\n\t\t\t\tvar argc = argv.length;\n\t\t\t\tvar _obj2Array = function _obj2Array(obj) {\n\t\t\t\t\tif (Object.prototype.toString.call(obj) === '[object Array]') {\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t}\n\t\t\t\t\tvar ar = [];\n\t\t\t\t\tfor (var i in obj) {\n\t\t\t\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\t\t\t\tar.push(obj[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn ar;\n\t\t\t\t};\n\n\t\t\t\tvar _compare = function _compare(current, next) {\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tvar n = 0;\n\t\t\t\t\tvar tmp = 0;\n\t\t\t\t\tvar nl = 0;\n\t\t\t\t\tvar cl = 0;\n\n\t\t\t\t\tif (current === next) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {\n\t\t\t\t\t\tif ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t\t\t\t\t\t\tcurrent = _obj2Array(current);\n\t\t\t\t\t\t\tnext = _obj2Array(next);\n\t\t\t\t\t\t\tcl = current.length;\n\t\t\t\t\t\t\tnl = next.length;\n\t\t\t\t\t\t\tif (nl > cl) {\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t} else if (nl < cl) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 0, n = cl; i < n; ++i) {\n\t\t\t\t\t\t\t\ttmp = _compare(current[i], next[i]);\n\t\t\t\t\t\t\t\tif (tmp === 1) {\n\t\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t\t} else if (tmp === -1) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else if (isNaN(next) && !isNaN(current)) {\n\t\t\t\t\t\tif (current === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn current < 0 ? 1 : -1;\n\t\t\t\t\t} else if (isNaN(current) && !isNaN(next)) {\n\t\t\t\t\t\tif (next === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn next > 0 ? 1 : -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (next === current) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn next > current ? 1 : -1;\n\t\t\t\t};\n\n\t\t\t\tif (argc === 0) {\n\t\t\t\t\tthrow new Error('At least one value should be passed to min()');\n\t\t\t\t} else if (argc === 1) {\n\t\t\t\t\tif (_typeof(argv[0]) === 'object') {\n\t\t\t\t\t\tar = _obj2Array(argv[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wrong parameter count for min()');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ar.length === 0) {\n\t\t\t\t\t\tthrow new Error('Array must contain at least one element for min()');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tar = argv;\n\t\t\t\t}\n\n\t\t\t\tretVal = ar[0];\n\n\t\t\t\tfor (i = 1, n = ar.length; i < n; ++i) {\n\t\t\t\t\tif (_compare(retVal, ar[i]) === -1) {\n\t\t\t\t\t\tretVal = ar[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn retVal;\n\t\t\t};\n\t\t\t//# sourceMappingURL=min.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 13 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function strip_tags(input, allowed) {\n\t\t\t\t// eslint-disable-line camelcase\n\t\t\t\t//  discuss at: http://locutus.io/php/strip_tags/\n\t\t\t\t// original by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// improved by: Luke Godfrey\n\t\t\t\t// improved by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t//    input by: Pul\n\t\t\t\t//    input by: Alex\n\t\t\t\t//    input by: Marc Palau\n\t\t\t\t//    input by: Brett Zamir (http://brett-zamir.me)\n\t\t\t\t//    input by: Bobby Drake\n\t\t\t\t//    input by: Evertjan Garretsen\n\t\t\t\t// bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)\n\t\t\t\t// bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// bugfixed by: Eric Nagel\n\t\t\t\t// bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// bugfixed by: Tomasz Wesolowski\n\t\t\t\t//  revised by: Rafa Kukawski (http://blog.kukawski.pl)\n\t\t\t\t//   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>')\n\t\t\t\t//   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'\n\t\t\t\t//   example 2: strip_tags('<p>Kevin <img src=\"someimage.png\" onmouseover=\"someFunction()\">van <i>Zonneveld</i></p>', '<p>')\n\t\t\t\t//   returns 2: '<p>Kevin van Zonneveld</p>'\n\t\t\t\t//   example 3: strip_tags(\"<a href='http://kvz.io'>Kevin van Zonneveld</a>\", \"<a>\")\n\t\t\t\t//   returns 3: \"<a href='http://kvz.io'>Kevin van Zonneveld</a>\"\n\t\t\t\t//   example 4: strip_tags('1 < 5 5 > 1')\n\t\t\t\t//   returns 4: '1 < 5 5 > 1'\n\t\t\t\t//   example 5: strip_tags('1 <br/> 1')\n\t\t\t\t//   returns 5: '1  1'\n\t\t\t\t//   example 6: strip_tags('1 <br/> 1', '<br>')\n\t\t\t\t//   returns 6: '1 <br/> 1'\n\t\t\t\t//   example 7: strip_tags('1 <br/> 1', '<br><br/>')\n\t\t\t\t//   returns 7: '1 <br/> 1'\n\n\t\t\t\t// making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)\n\t\t\t\tallowed = (((allowed || '') + '').toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join('');\n\n\t\t\t\tvar tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>/gi;\n\t\t\t\tvar commentsAndPhpTags = /<!--[\\s\\S]*?-->|<\\?(?:php)?[\\s\\S]*?\\?>/gi;\n\n\t\t\t\treturn input.replace(commentsAndPhpTags, '').replace(tags, function ($0, $1) {\n\t\t\t\t\treturn allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';\n\t\t\t\t});\n\t\t\t};\n\t\t\t//# sourceMappingURL=strip_tags.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 14 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function strtotime(text, now) {\n\t\t\t\t//  discuss at: http://locutus.io/php/strtotime/\n\t\t\t\t// original by: Caio Ariede (http://caioariede.com)\n\t\t\t\t// improved by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// improved by: Caio Ariede (http://caioariede.com)\n\t\t\t\t// improved by: A. Matas Quezada (http://amatiasq.com)\n\t\t\t\t// improved by: preuter\n\t\t\t\t// improved by: Brett Zamir (http://brett-zamir.me)\n\t\t\t\t// improved by: Mirko Faber\n\t\t\t\t//    input by: David\n\t\t\t\t// bugfixed by: Wagner B. Soares\n\t\t\t\t// bugfixed by: Artur Tchernychev\n\t\t\t\t// bugfixed by: Stephan Bsch-Plepelits (http://github.com/plepe)\n\t\t\t\t//      note 1: Examples all have a fixed timestamp to prevent\n\t\t\t\t//      note 1: tests to fail because of variable time(zones)\n\t\t\t\t//   example 1: strtotime('+1 day', 1129633200)\n\t\t\t\t//   returns 1: 1129719600\n\t\t\t\t//   example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200)\n\t\t\t\t//   returns 2: 1130425202\n\t\t\t\t//   example 3: strtotime('last month', 1129633200)\n\t\t\t\t//   returns 3: 1127041200\n\t\t\t\t//   example 4: strtotime('2009-05-04 08:30:00 GMT')\n\t\t\t\t//   returns 4: 1241425800\n\t\t\t\t//   example 5: strtotime('2009-05-04 08:30:00+00')\n\t\t\t\t//   returns 5: 1241425800\n\t\t\t\t//   example 6: strtotime('2009-05-04 08:30:00+02:00')\n\t\t\t\t//   returns 6: 1241418600\n\t\t\t\t//   example 7: strtotime('2009-05-04T08:30:00Z')\n\t\t\t\t//   returns 7: 1241425800\n\n\t\t\t\tvar parsed;\n\t\t\t\tvar match;\n\t\t\t\tvar today;\n\t\t\t\tvar year;\n\t\t\t\tvar date;\n\t\t\t\tvar days;\n\t\t\t\tvar ranges;\n\t\t\t\tvar len;\n\t\t\t\tvar times;\n\t\t\t\tvar regex;\n\t\t\t\tvar i;\n\t\t\t\tvar fail = false;\n\n\t\t\t\tif (!text) {\n\t\t\t\t\treturn fail;\n\t\t\t\t}\n\n\t\t\t\t// Unecessary spaces\n\t\t\t\ttext = text.replace(/^\\s+|\\s+$/g, '').replace(/\\s{2,}/g, ' ').replace(/[\\t\\r\\n]/g, '').toLowerCase();\n\n\t\t\t\t// in contrast to php, js Date.parse function interprets:\n\t\t\t\t// dates given as yyyy-mm-dd as in timezone: UTC,\n\t\t\t\t// dates with \".\" or \"-\" as MDY instead of DMY\n\t\t\t\t// dates with two-digit years differently\n\t\t\t\t// etc...etc...\n\t\t\t\t// ...therefore we manually parse lots of common date formats\n\t\t\t\tvar pattern = new RegExp(['^(\\\\d{1,4})', '([\\\\-\\\\.\\\\/:])', '(\\\\d{1,2})', '([\\\\-\\\\.\\\\/:])', '(\\\\d{1,4})', '(?:\\\\s(\\\\d{1,2}):(\\\\d{2})?:?(\\\\d{2})?)?', '(?:\\\\s([A-Z]+)?)?$'].join(''));\n\t\t\t\tmatch = text.match(pattern);\n\n\t\t\t\tif (match && match[2] === match[4]) {\n\t\t\t\t\tif (match[1] > 1901) {\n\t\t\t\t\t\tswitch (match[2]) {\n\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\t// YYYY-M-D\n\t\t\t\t\t\t\t\tif (match[3] > 12 || match[5] > 31) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\t\t// YYYY.M.D is not parsed by strtotime()\n\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t// YYYY/M/D\n\t\t\t\t\t\t\t\tif (match[3] > 12 || match[5] > 31) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (match[5] > 1901) {\n\t\t\t\t\t\tswitch (match[2]) {\n\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\t// D-M-YYYY\n\t\t\t\t\t\t\t\tif (match[3] > 12 || match[1] > 31) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\t\t// D.M.YYYY\n\t\t\t\t\t\t\t\tif (match[3] > 12 || match[1] > 31) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t// M/D/YYYY\n\t\t\t\t\t\t\t\tif (match[1] > 12 || match[3] > 31) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn new Date(match[5], parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (match[2]) {\n\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\t// YY-M-D\n\t\t\t\t\t\t\t\tif (match[3] > 12 || match[5] > 31 || match[1] < 70 && match[1] > 38) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tyear = match[1] >= 0 && match[1] <= 38 ? +match[1] + 2000 : match[1];\n\t\t\t\t\t\t\t\treturn new Date(year, parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\t\t// D.M.YY or H.MM.SS\n\t\t\t\t\t\t\t\tif (match[5] >= 70) {\n\t\t\t\t\t\t\t\t\t// D.M.YY\n\t\t\t\t\t\t\t\t\tif (match[3] > 12 || match[1] > 31) {\n\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (match[5] < 60 && !match[6]) {\n\t\t\t\t\t\t\t\t\t// H.MM.SS\n\t\t\t\t\t\t\t\t\tif (match[1] > 23 || match[3] > 59) {\n\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttoday = new Date();\n\t\t\t\t\t\t\t\t\treturn new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// invalid format, cannot be parsed\n\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t// M/D/YY\n\t\t\t\t\t\t\t\tif (match[1] > 12 || match[3] > 31 || match[5] < 70 && match[5] > 38) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tyear = match[5] >= 0 && match[5] <= 38 ? +match[5] + 2000 : match[5];\n\t\t\t\t\t\t\t\treturn new Date(year, parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;\n\t\t\t\t\t\t\tcase ':':\n\t\t\t\t\t\t\t\t// HH:MM:SS\n\t\t\t\t\t\t\t\tif (match[1] > 23 || match[3] > 59 || match[5] > 59) {\n\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttoday = new Date();\n\t\t\t\t\t\t\t\treturn new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0) / 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// other formats and \"now\" should be parsed by Date.parse()\n\t\t\t\tif (text === 'now') {\n\t\t\t\t\treturn now === null || isNaN(now) ? new Date().getTime() / 1000 | 0 : now | 0;\n\t\t\t\t}\n\t\t\t\tif (!isNaN(parsed = Date.parse(text))) {\n\t\t\t\t\treturn parsed / 1000 | 0;\n\t\t\t\t}\n\t\t\t\t// Browsers !== Chrome have problems parsing ISO 8601 date strings, as they do\n\t\t\t\t// not accept lower case characters, space, or shortened time zones.\n\t\t\t\t// Therefore, fix these problems and try again.\n\t\t\t\t// Examples:\n\t\t\t\t//   2015-04-15 20:33:59+02\n\t\t\t\t//   2015-04-15 20:33:59z\n\t\t\t\t//   2015-04-15t20:33:59+02:00\n\t\t\t\tpattern = new RegExp(['^([0-9]{4}-[0-9]{2}-[0-9]{2})', '[ t]', '([0-9]{2}:[0-9]{2}:[0-9]{2}(\\\\.[0-9]+)?)', '([\\\\+-][0-9]{2}(:[0-9]{2})?|z)'].join(''));\n\t\t\t\tmatch = text.match(pattern);\n\t\t\t\tif (match) {\n\t\t\t\t\t// @todo: time zone information\n\t\t\t\t\tif (match[4] === 'z') {\n\t\t\t\t\t\tmatch[4] = 'Z';\n\t\t\t\t\t} else if (match[4].match(/^([+-][0-9]{2})$/)) {\n\t\t\t\t\t\tmatch[4] = match[4] + ':00';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isNaN(parsed = Date.parse(match[1] + 'T' + match[2] + match[4]))) {\n\t\t\t\t\t\treturn parsed / 1000 | 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdate = now ? new Date(now * 1000) : new Date();\n\t\t\t\tdays = {\n\t\t\t\t\t'sun': 0,\n\t\t\t\t\t'mon': 1,\n\t\t\t\t\t'tue': 2,\n\t\t\t\t\t'wed': 3,\n\t\t\t\t\t'thu': 4,\n\t\t\t\t\t'fri': 5,\n\t\t\t\t\t'sat': 6\n\t\t\t\t};\n\t\t\t\tranges = {\n\t\t\t\t\t'yea': 'FullYear',\n\t\t\t\t\t'mon': 'Month',\n\t\t\t\t\t'day': 'Date',\n\t\t\t\t\t'hou': 'Hours',\n\t\t\t\t\t'min': 'Minutes',\n\t\t\t\t\t'sec': 'Seconds'\n\t\t\t\t};\n\n\t\t\t\tfunction lastNext(type, range, modifier) {\n\t\t\t\t\tvar diff;\n\t\t\t\t\tvar day = days[range];\n\n\t\t\t\t\tif (typeof day !== 'undefined') {\n\t\t\t\t\t\tdiff = day - date.getDay();\n\n\t\t\t\t\t\tif (diff === 0) {\n\t\t\t\t\t\t\tdiff = 7 * modifier;\n\t\t\t\t\t\t} else if (diff > 0 && type === 'last') {\n\t\t\t\t\t\t\tdiff -= 7;\n\t\t\t\t\t\t} else if (diff < 0 && type === 'next') {\n\t\t\t\t\t\t\tdiff += 7;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdate.setDate(date.getDate() + diff);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction process(val) {\n\t\t\t\t\t// @todo: Reconcile this with regex using \\s, taking into account\n\t\t\t\t\t// browser issues with split and regexes\n\t\t\t\t\tvar splt = val.split(' ');\n\t\t\t\t\tvar type = splt[0];\n\t\t\t\t\tvar range = splt[1].substring(0, 3);\n\t\t\t\t\tvar typeIsNumber = /\\d+/.test(type);\n\t\t\t\t\tvar ago = splt[2] === 'ago';\n\t\t\t\t\tvar num = (type === 'last' ? -1 : 1) * (ago ? -1 : 1);\n\n\t\t\t\t\tif (typeIsNumber) {\n\t\t\t\t\t\tnum *= parseInt(type, 10);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ranges.hasOwnProperty(range) && !splt[1].match(/^mon(day|\\.)?$/i)) {\n\t\t\t\t\t\treturn date['set' + ranges[range]](date['get' + ranges[range]]() + num);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (range === 'wee') {\n\t\t\t\t\t\treturn date.setDate(date.getDate() + num * 7);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (type === 'next' || type === 'last') {\n\t\t\t\t\t\tlastNext(type, range, num);\n\t\t\t\t\t} else if (!typeIsNumber) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\ttimes = '(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec' + '|sunday|sun\\\\.?|monday|mon\\\\.?|tuesday|tue\\\\.?|wednesday|wed\\\\.?' + '|thursday|thu\\\\.?|friday|fri\\\\.?|saturday|sat\\\\.?)';\n\t\t\t\tregex = '([+-]?\\\\d+\\\\s' + times + '|' + '(last|next)\\\\s' + times + ')(\\\\sago)?';\n\n\t\t\t\tmatch = text.match(new RegExp(regex, 'gi'));\n\t\t\t\tif (!match) {\n\t\t\t\t\treturn fail;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0, len = match.length; i < len; i++) {\n\t\t\t\t\tif (!process(match[i])) {\n\t\t\t\t\t\treturn fail;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn date.getTime() / 1000;\n\t\t\t};\n\t\t\t//# sourceMappingURL=strtotime.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 15 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function date(format, timestamp) {\n\t\t\t\t//  discuss at: http://locutus.io/php/date/\n\t\t\t\t// original by: Carlos R. L. Rodrigues (http://www.jsfromhell.com)\n\t\t\t\t// original by: gettimeofday\n\t\t\t\t//    parts by: Peter-Paul Koch (http://www.quirksmode.org/js/beat.html)\n\t\t\t\t// improved by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// improved by: MeEtc (http://yass.meetcweb.com)\n\t\t\t\t// improved by: Brad Touesnard\n\t\t\t\t// improved by: Tim Wiel\n\t\t\t\t// improved by: Bryan Elliott\n\t\t\t\t// improved by: David Randall\n\t\t\t\t// improved by: Theriault (https://github.com/Theriault)\n\t\t\t\t// improved by: Theriault (https://github.com/Theriault)\n\t\t\t\t// improved by: Brett Zamir (http://brett-zamir.me)\n\t\t\t\t// improved by: Theriault (https://github.com/Theriault)\n\t\t\t\t// improved by: Thomas Beaucourt (http://www.webapp.fr)\n\t\t\t\t// improved by: JT\n\t\t\t\t// improved by: Theriault (https://github.com/Theriault)\n\t\t\t\t// improved by: Rafa Kukawski (http://blog.kukawski.pl)\n\t\t\t\t// improved by: Theriault (https://github.com/Theriault)\n\t\t\t\t//    input by: Brett Zamir (http://brett-zamir.me)\n\t\t\t\t//    input by: majak\n\t\t\t\t//    input by: Alex\n\t\t\t\t//    input by: Martin\n\t\t\t\t//    input by: Alex Wilson\n\t\t\t\t//    input by: Haravikk\n\t\t\t\t// bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// bugfixed by: majak\n\t\t\t\t// bugfixed by: Kevin van Zonneveld (http://kvz.io)\n\t\t\t\t// bugfixed by: Brett Zamir (http://brett-zamir.me)\n\t\t\t\t// bugfixed by: omid (http://locutus.io/php/380:380#comment_137122)\n\t\t\t\t// bugfixed by: Chris (http://www.devotis.nl/)\n\t\t\t\t//      note 1: Uses global: locutus to store the default timezone\n\t\t\t\t//      note 1: Although the function potentially allows timezone info\n\t\t\t\t//      note 1: (see notes), it currently does not set\n\t\t\t\t//      note 1: per a timezone specified by date_default_timezone_set(). Implementers might use\n\t\t\t\t//      note 1: $locutus.currentTimezoneOffset and\n\t\t\t\t//      note 1: $locutus.currentTimezoneDST set by that function\n\t\t\t\t//      note 1: in order to adjust the dates in this function\n\t\t\t\t//      note 1: (or our other date functions!) accordingly\n\t\t\t\t//   example 1: date('H:m:s \\\\m \\\\i\\\\s \\\\m\\\\o\\\\n\\\\t\\\\h', 1062402400)\n\t\t\t\t//   returns 1: '07:09:40 m is month'\n\t\t\t\t//   example 2: date('F j, Y, g:i a', 1062462400)\n\t\t\t\t//   returns 2: 'September 2, 2003, 12:26 am'\n\t\t\t\t//   example 3: date('Y W o', 1062462400)\n\t\t\t\t//   returns 3: '2003 36 2003'\n\t\t\t\t//   example 4: var $x = date('Y m d', (new Date()).getTime() / 1000)\n\t\t\t\t//   example 4: $x = $x + ''\n\t\t\t\t//   example 4: var $result = $x.length // 2009 01 09\n\t\t\t\t//   returns 4: 10\n\t\t\t\t//   example 5: date('W', 1104534000)\n\t\t\t\t//   returns 5: '52'\n\t\t\t\t//   example 6: date('B t', 1104534000)\n\t\t\t\t//   returns 6: '999 31'\n\t\t\t\t//   example 7: date('W U', 1293750000.82); // 2010-12-31\n\t\t\t\t//   returns 7: '52 1293750000'\n\t\t\t\t//   example 8: date('W', 1293836400); // 2011-01-01\n\t\t\t\t//   returns 8: '52'\n\t\t\t\t//   example 9: date('W Y-m-d', 1293974054); // 2011-01-02\n\t\t\t\t//   returns 9: '52 2011-01-02'\n\t\t\t\t//        test: skip-1 skip-2 skip-5\n\n\t\t\t\tvar jsdate, f;\n\t\t\t\t// Keep this here (works, but for code commented-out below for file size reasons)\n\t\t\t\t// var tal= [];\n\t\t\t\tvar txtWords = ['Sun', 'Mon', 'Tues', 'Wednes', 'Thurs', 'Fri', 'Satur', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n\t\t\t\t// trailing backslash -> (dropped)\n\t\t\t\t// a backslash followed by any character (including backslash) -> the character\n\t\t\t\t// empty string -> empty string\n\t\t\t\tvar formatChr = /\\\\?(.?)/gi;\n\t\t\t\tvar formatChrCb = function formatChrCb(t, s) {\n\t\t\t\t\treturn f[t] ? f[t]() : s;\n\t\t\t\t};\n\t\t\t\tvar _pad = function _pad(n, c) {\n\t\t\t\t\tn = String(n);\n\t\t\t\t\twhile (n.length < c) {\n\t\t\t\t\t\tn = '0' + n;\n\t\t\t\t\t}\n\t\t\t\t\treturn n;\n\t\t\t\t};\n\t\t\t\tf = {\n\t\t\t\t\t// Day\n\t\t\t\t\td: function d() {\n\t\t\t\t\t\t// Day of month w/leading 0; 01..31\n\t\t\t\t\t\treturn _pad(f.j(), 2);\n\t\t\t\t\t},\n\t\t\t\t\tD: function D() {\n\t\t\t\t\t\t// Shorthand day name; Mon...Sun\n\t\t\t\t\t\treturn f.l().slice(0, 3);\n\t\t\t\t\t},\n\t\t\t\t\tj: function j() {\n\t\t\t\t\t\t// Day of month; 1..31\n\t\t\t\t\t\treturn jsdate.getDate();\n\t\t\t\t\t},\n\t\t\t\t\tl: function l() {\n\t\t\t\t\t\t// Full day name; Monday...Sunday\n\t\t\t\t\t\treturn txtWords[f.w()] + 'day';\n\t\t\t\t\t},\n\t\t\t\t\tN: function N() {\n\t\t\t\t\t\t// ISO-8601 day of week; 1[Mon]..7[Sun]\n\t\t\t\t\t\treturn f.w() || 7;\n\t\t\t\t\t},\n\t\t\t\t\tS: function S() {\n\t\t\t\t\t\t// Ordinal suffix for day of month; st, nd, rd, th\n\t\t\t\t\t\tvar j = f.j();\n\t\t\t\t\t\tvar i = j % 10;\n\t\t\t\t\t\tif (i <= 3 && parseInt(j % 100 / 10, 10) === 1) {\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ['st', 'nd', 'rd'][i - 1] || 'th';\n\t\t\t\t\t},\n\t\t\t\t\tw: function w() {\n\t\t\t\t\t\t// Day of week; 0[Sun]..6[Sat]\n\t\t\t\t\t\treturn jsdate.getDay();\n\t\t\t\t\t},\n\t\t\t\t\tz: function z() {\n\t\t\t\t\t\t// Day of year; 0..365\n\t\t\t\t\t\tvar a = new Date(f.Y(), f.n() - 1, f.j());\n\t\t\t\t\t\tvar b = new Date(f.Y(), 0, 1);\n\t\t\t\t\t\treturn Math.round((a - b) / 864e5);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Week\n\t\t\t\t\tW: function W() {\n\t\t\t\t\t\t// ISO-8601 week number\n\t\t\t\t\t\tvar a = new Date(f.Y(), f.n() - 1, f.j() - f.N() + 3);\n\t\t\t\t\t\tvar b = new Date(a.getFullYear(), 0, 4);\n\t\t\t\t\t\treturn _pad(1 + Math.round((a - b) / 864e5 / 7), 2);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Month\n\t\t\t\t\tF: function F() {\n\t\t\t\t\t\t// Full month name; January...December\n\t\t\t\t\t\treturn txtWords[6 + f.n()];\n\t\t\t\t\t},\n\t\t\t\t\tm: function m() {\n\t\t\t\t\t\t// Month w/leading 0; 01...12\n\t\t\t\t\t\treturn _pad(f.n(), 2);\n\t\t\t\t\t},\n\t\t\t\t\tM: function M() {\n\t\t\t\t\t\t// Shorthand month name; Jan...Dec\n\t\t\t\t\t\treturn f.F().slice(0, 3);\n\t\t\t\t\t},\n\t\t\t\t\tn: function n() {\n\t\t\t\t\t\t// Month; 1...12\n\t\t\t\t\t\treturn jsdate.getMonth() + 1;\n\t\t\t\t\t},\n\t\t\t\t\tt: function t() {\n\t\t\t\t\t\t// Days in month; 28...31\n\t\t\t\t\t\treturn new Date(f.Y(), f.n(), 0).getDate();\n\t\t\t\t\t},\n\n\t\t\t\t\t// Year\n\t\t\t\t\tL: function L() {\n\t\t\t\t\t\t// Is leap year?; 0 or 1\n\t\t\t\t\t\tvar j = f.Y();\n\t\t\t\t\t\treturn j % 4 === 0 & j % 100 !== 0 | j % 400 === 0;\n\t\t\t\t\t},\n\t\t\t\t\to: function o() {\n\t\t\t\t\t\t// ISO-8601 year\n\t\t\t\t\t\tvar n = f.n();\n\t\t\t\t\t\tvar W = f.W();\n\t\t\t\t\t\tvar Y = f.Y();\n\t\t\t\t\t\treturn Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);\n\t\t\t\t\t},\n\t\t\t\t\tY: function Y() {\n\t\t\t\t\t\t// Full year; e.g. 1980...2010\n\t\t\t\t\t\treturn jsdate.getFullYear();\n\t\t\t\t\t},\n\t\t\t\t\ty: function y() {\n\t\t\t\t\t\t// Last two digits of year; 00...99\n\t\t\t\t\t\treturn f.Y().toString().slice(-2);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Time\n\t\t\t\t\ta: function a() {\n\t\t\t\t\t\t// am or pm\n\t\t\t\t\t\treturn jsdate.getHours() > 11 ? 'pm' : 'am';\n\t\t\t\t\t},\n\t\t\t\t\tA: function A() {\n\t\t\t\t\t\t// AM or PM\n\t\t\t\t\t\treturn f.a().toUpperCase();\n\t\t\t\t\t},\n\t\t\t\t\tB: function B() {\n\t\t\t\t\t\t// Swatch Internet time; 000..999\n\t\t\t\t\t\tvar H = jsdate.getUTCHours() * 36e2;\n\t\t\t\t\t\t// Hours\n\t\t\t\t\t\tvar i = jsdate.getUTCMinutes() * 60;\n\t\t\t\t\t\t// Minutes\n\t\t\t\t\t\t// Seconds\n\t\t\t\t\t\tvar s = jsdate.getUTCSeconds();\n\t\t\t\t\t\treturn _pad(Math.floor((H + i + s + 36e2) / 86.4) % 1e3, 3);\n\t\t\t\t\t},\n\t\t\t\t\tg: function g() {\n\t\t\t\t\t\t// 12-Hours; 1..12\n\t\t\t\t\t\treturn f.G() % 12 || 12;\n\t\t\t\t\t},\n\t\t\t\t\tG: function G() {\n\t\t\t\t\t\t// 24-Hours; 0..23\n\t\t\t\t\t\treturn jsdate.getHours();\n\t\t\t\t\t},\n\t\t\t\t\th: function h() {\n\t\t\t\t\t\t// 12-Hours w/leading 0; 01..12\n\t\t\t\t\t\treturn _pad(f.g(), 2);\n\t\t\t\t\t},\n\t\t\t\t\tH: function H() {\n\t\t\t\t\t\t// 24-Hours w/leading 0; 00..23\n\t\t\t\t\t\treturn _pad(f.G(), 2);\n\t\t\t\t\t},\n\t\t\t\t\ti: function i() {\n\t\t\t\t\t\t// Minutes w/leading 0; 00..59\n\t\t\t\t\t\treturn _pad(jsdate.getMinutes(), 2);\n\t\t\t\t\t},\n\t\t\t\t\ts: function s() {\n\t\t\t\t\t\t// Seconds w/leading 0; 00..59\n\t\t\t\t\t\treturn _pad(jsdate.getSeconds(), 2);\n\t\t\t\t\t},\n\t\t\t\t\tu: function u() {\n\t\t\t\t\t\t// Microseconds; 000000-999000\n\t\t\t\t\t\treturn _pad(jsdate.getMilliseconds() * 1000, 6);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Timezone\n\t\t\t\t\te: function e() {\n\t\t\t\t\t\t// Timezone identifier; e.g. Atlantic/Azores, ...\n\t\t\t\t\t\t// The following works, but requires inclusion of the very large\n\t\t\t\t\t\t// timezone_abbreviations_list() function.\n\t\t\t\t\t\t/*              return that.date_default_timezone_get();\n       */\n\t\t\t\t\t\tvar msg = 'Not supported (see source code of date() for timezone on how to add support)';\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t},\n\t\t\t\t\tI: function I() {\n\t\t\t\t\t\t// DST observed?; 0 or 1\n\t\t\t\t\t\t// Compares Jan 1 minus Jan 1 UTC to Jul 1 minus Jul 1 UTC.\n\t\t\t\t\t\t// If they are not equal, then DST is observed.\n\t\t\t\t\t\tvar a = new Date(f.Y(), 0);\n\t\t\t\t\t\t// Jan 1\n\t\t\t\t\t\tvar c = Date.UTC(f.Y(), 0);\n\t\t\t\t\t\t// Jan 1 UTC\n\t\t\t\t\t\tvar b = new Date(f.Y(), 6);\n\t\t\t\t\t\t// Jul 1\n\t\t\t\t\t\t// Jul 1 UTC\n\t\t\t\t\t\tvar d = Date.UTC(f.Y(), 6);\n\t\t\t\t\t\treturn a - c !== b - d ? 1 : 0;\n\t\t\t\t\t},\n\t\t\t\t\tO: function O() {\n\t\t\t\t\t\t// Difference to GMT in hour format; e.g. +0200\n\t\t\t\t\t\tvar tzo = jsdate.getTimezoneOffset();\n\t\t\t\t\t\tvar a = Math.abs(tzo);\n\t\t\t\t\t\treturn (tzo > 0 ? '-' : '+') + _pad(Math.floor(a / 60) * 100 + a % 60, 4);\n\t\t\t\t\t},\n\t\t\t\t\tP: function P() {\n\t\t\t\t\t\t// Difference to GMT w/colon; e.g. +02:00\n\t\t\t\t\t\tvar O = f.O();\n\t\t\t\t\t\treturn O.substr(0, 3) + ':' + O.substr(3, 2);\n\t\t\t\t\t},\n\t\t\t\t\tT: function T() {\n\t\t\t\t\t\t// The following works, but requires inclusion of the very\n\t\t\t\t\t\t// large timezone_abbreviations_list() function.\n\t\t\t\t\t\t/*              var abbr, i, os, _default;\n      if (!tal.length) {\n        tal = that.timezone_abbreviations_list();\n      }\n      if ($locutus && $locutus.default_timezone) {\n        _default = $locutus.default_timezone;\n        for (abbr in tal) {\n          for (i = 0; i < tal[abbr].length; i++) {\n            if (tal[abbr][i].timezone_id === _default) {\n              return abbr.toUpperCase();\n            }\n          }\n        }\n      }\n      for (abbr in tal) {\n        for (i = 0; i < tal[abbr].length; i++) {\n          os = -jsdate.getTimezoneOffset() * 60;\n          if (tal[abbr][i].offset === os) {\n            return abbr.toUpperCase();\n          }\n        }\n      }\n      */\n\t\t\t\t\t\treturn 'UTC';\n\t\t\t\t\t},\n\t\t\t\t\tZ: function Z() {\n\t\t\t\t\t\t// Timezone offset in seconds (-43200...50400)\n\t\t\t\t\t\treturn -jsdate.getTimezoneOffset() * 60;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Full Date/Time\n\t\t\t\t\tc: function c() {\n\t\t\t\t\t\t// ISO-8601 date.\n\t\t\t\t\t\treturn 'Y-m-d\\\\TH:i:sP'.replace(formatChr, formatChrCb);\n\t\t\t\t\t},\n\t\t\t\t\tr: function r() {\n\t\t\t\t\t\t// RFC 2822\n\t\t\t\t\t\treturn 'D, d M Y H:i:s O'.replace(formatChr, formatChrCb);\n\t\t\t\t\t},\n\t\t\t\t\tU: function U() {\n\t\t\t\t\t\t// Seconds since UNIX epoch\n\t\t\t\t\t\treturn jsdate / 1000 | 0;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar _date = function _date(format, timestamp) {\n\t\t\t\t\tjsdate = timestamp === undefined ? new Date() // Not provided\n\t\t\t\t\t: timestamp instanceof Date ? new Date(timestamp) // JS Date()\n\t\t\t\t\t: new Date(timestamp * 1000) // UNIX timestamp (auto-convert to int)\n\t\t\t\t\t;\n\t\t\t\t\treturn format.replace(formatChr, formatChrCb);\n\t\t\t\t};\n\n\t\t\t\treturn _date(format, timestamp);\n\t\t\t};\n\t\t\t//# sourceMappingURL=date.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 16 */\n\t\t/***/function (module, exports) {\n\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function boolval(mixedVar) {\n\t\t\t\t// original by: Will Rowe\n\t\t\t\t//   example 1: boolval(true)\n\t\t\t\t//   returns 1: true\n\t\t\t\t//   example 2: boolval(false)\n\t\t\t\t//   returns 2: false\n\t\t\t\t//   example 3: boolval(0)\n\t\t\t\t//   returns 3: false\n\t\t\t\t//   example 4: boolval(0.0)\n\t\t\t\t//   returns 4: false\n\t\t\t\t//   example 5: boolval('')\n\t\t\t\t//   returns 5: false\n\t\t\t\t//   example 6: boolval('0')\n\t\t\t\t//   returns 6: false\n\t\t\t\t//   example 7: boolval([])\n\t\t\t\t//   returns 7: false\n\t\t\t\t//   example 8: boolval('')\n\t\t\t\t//   returns 8: false\n\t\t\t\t//   example 9: boolval(null)\n\t\t\t\t//   returns 9: false\n\t\t\t\t//   example 10: boolval(undefined)\n\t\t\t\t//   returns 10: false\n\t\t\t\t//   example 11: boolval('true')\n\t\t\t\t//   returns 11: true\n\n\t\t\t\tif (mixedVar === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (mixedVar === 0 || mixedVar === 0.0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (mixedVar === '' || mixedVar === '0') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(mixedVar) && mixedVar.length === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (mixedVar === null || mixedVar === undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t};\n\t\t\t//# sourceMappingURL=boolval.js.map\n\n\t\t\t/***/\n\t\t},\n\t\t/* 17 */\n\t\t/***/function (module, exports) {\n\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t'use strict';\n\n\t\t\t\tTwig.Templates.registerLoader('ajax', function (location, params, callback, error_callback) {\n\t\t\t\t\tvar template,\n\t\t\t\t\t    xmlhttp,\n\t\t\t\t\t    precompiled = params.precompiled,\n\t\t\t\t\t    parser = this.parsers[params.parser] || this.parser.twig;\n\n\t\t\t\t\tif (typeof XMLHttpRequest === \"undefined\") {\n\t\t\t\t\t\tthrow new Twig.Error('Unsupported platform: Unable to do ajax requests ' + 'because there is no \"XMLHTTPRequest\" implementation');\n\t\t\t\t\t}\n\n\t\t\t\t\txmlhttp = new XMLHttpRequest();\n\t\t\t\t\txmlhttp.onreadystatechange = function () {\n\t\t\t\t\t\tvar data = null;\n\n\t\t\t\t\t\tif (xmlhttp.readyState === 4) {\n\t\t\t\t\t\t\tif (xmlhttp.status === 200 || window.cordova && xmlhttp.status == 0) {\n\t\t\t\t\t\t\t\tTwig.log.debug(\"Got template \", xmlhttp.responseText);\n\n\t\t\t\t\t\t\t\tif (precompiled === true) {\n\t\t\t\t\t\t\t\t\tdata = JSON.parse(xmlhttp.responseText);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdata = xmlhttp.responseText;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tparams.url = location;\n\t\t\t\t\t\t\t\tparams.data = data;\n\n\t\t\t\t\t\t\t\ttemplate = parser.call(this, params);\n\n\t\t\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\t\t\tcallback(template);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (typeof error_callback === 'function') {\n\t\t\t\t\t\t\t\t\terror_callback(xmlhttp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\txmlhttp.open(\"GET\", location, !!params.async);\n\t\t\t\t\txmlhttp.send();\n\n\t\t\t\t\tif (params.async) {\n\t\t\t\t\t\t// TODO: return deferred promise\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn template;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 18 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t'use strict';\n\n\t\t\t\tvar fs, path;\n\n\t\t\t\ttry {\n\t\t\t\t\t// require lib dependencies at runtime\n\t\t\t\t\tfs = __webpack_require__(19);\n\t\t\t\t\tpath = __webpack_require__(20);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// NOTE: this is in a try/catch to avoid errors cross platform\n\t\t\t\t}\n\n\t\t\t\tTwig.Templates.registerLoader('fs', function (location, params, callback, error_callback) {\n\t\t\t\t\tvar template,\n\t\t\t\t\t    data = null,\n\t\t\t\t\t    precompiled = params.precompiled,\n\t\t\t\t\t    parser = this.parsers[params.parser] || this.parser.twig;\n\n\t\t\t\t\tif (!fs || !path) {\n\t\t\t\t\t\tthrow new Twig.Error('Unsupported platform: Unable to load from file ' + 'because there is no \"fs\" or \"path\" implementation');\n\t\t\t\t\t}\n\n\t\t\t\t\tvar loadTemplateFn = function (err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (typeof error_callback === 'function') {\n\t\t\t\t\t\t\t\terror_callback(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (precompiled === true) {\n\t\t\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparams.data = data;\n\t\t\t\t\t\tparams.path = params.path || location;\n\n\t\t\t\t\t\t// template is in data\n\t\t\t\t\t\ttemplate = parser.call(this, params);\n\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\tcallback(template);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tparams.path = params.path || location;\n\n\t\t\t\t\tif (params.async) {\n\t\t\t\t\t\tfs.stat(params.path, function (err, stats) {\n\t\t\t\t\t\t\tif (err || !stats.isFile()) {\n\t\t\t\t\t\t\t\tif (typeof error_callback === 'function') {\n\t\t\t\t\t\t\t\t\terror_callback(new Twig.Error('Unable to find template file ' + params.path));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfs.readFile(params.path, 'utf8', loadTemplateFn);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// TODO: return deferred promise\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!fs.statSync(params.path).isFile()) {\n\t\t\t\t\t\t\t\tthrow new Twig.Error('Unable to find template file ' + params.path);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tthrow new Twig.Error('Unable to find template file ' + params.path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata = fs.readFileSync(params.path, 'utf8');\n\t\t\t\t\t\tloadTemplateFn(undefined, data);\n\t\t\t\t\t\treturn template;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 19 */\n\t\t/***/function (module, exports) {\n\n\t\t\tmodule.exports = require(\"fs\");\n\n\t\t\t/***/\n\t\t},\n\t\t/* 20 */\n\t\t/***/function (module, exports) {\n\n\t\t\tmodule.exports = require(\"path\");\n\n\t\t\t/***/\n\t\t},\n\t\t/* 21 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.logic.js\n\t\t\t//\n\t\t\t// This file handles tokenizing, compiling and parsing logic tokens. {% ... %}\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\t/**\n     * Namespace for logic handling.\n     */\n\n\t\t\t\tTwig.logic = {};\n\n\t\t\t\t/**\n     * Logic token types.\n     */\n\t\t\t\tTwig.logic.type = {\n\t\t\t\t\tif_: 'Twig.logic.type.if',\n\t\t\t\t\tendif: 'Twig.logic.type.endif',\n\t\t\t\t\tfor_: 'Twig.logic.type.for',\n\t\t\t\t\tendfor: 'Twig.logic.type.endfor',\n\t\t\t\t\telse_: 'Twig.logic.type.else',\n\t\t\t\t\telseif: 'Twig.logic.type.elseif',\n\t\t\t\t\tset: 'Twig.logic.type.set',\n\t\t\t\t\tsetcapture: 'Twig.logic.type.setcapture',\n\t\t\t\t\tendset: 'Twig.logic.type.endset',\n\t\t\t\t\tfilter: 'Twig.logic.type.filter',\n\t\t\t\t\tendfilter: 'Twig.logic.type.endfilter',\n\t\t\t\t\tshortblock: 'Twig.logic.type.shortblock',\n\t\t\t\t\tblock: 'Twig.logic.type.block',\n\t\t\t\t\tendblock: 'Twig.logic.type.endblock',\n\t\t\t\t\textends_: 'Twig.logic.type.extends',\n\t\t\t\t\tuse: 'Twig.logic.type.use',\n\t\t\t\t\tinclude: 'Twig.logic.type.include',\n\t\t\t\t\tspaceless: 'Twig.logic.type.spaceless',\n\t\t\t\t\tendspaceless: 'Twig.logic.type.endspaceless',\n\t\t\t\t\tmacro: 'Twig.logic.type.macro',\n\t\t\t\t\tendmacro: 'Twig.logic.type.endmacro',\n\t\t\t\t\timport_: 'Twig.logic.type.import',\n\t\t\t\t\tfrom: 'Twig.logic.type.from',\n\t\t\t\t\tembed: 'Twig.logic.type.embed',\n\t\t\t\t\tendembed: 'Twig.logic.type.endembed'\n\t\t\t\t};\n\n\t\t\t\t// Regular expressions for handling logic tokens.\n\t\t\t\t//\n\t\t\t\t// Properties:\n\t\t\t\t//\n\t\t\t\t//      type:  The type of expression this matches\n\t\t\t\t//\n\t\t\t\t//      regex: A regular expression that matches the format of the token\n\t\t\t\t//\n\t\t\t\t//      next:  What logic tokens (if any) pop this token off the logic stack. If empty, the\n\t\t\t\t//             logic token is assumed to not require an end tag and isn't push onto the stack.\n\t\t\t\t//\n\t\t\t\t//      open:  Does this tag open a logic expression or is it standalone. For example,\n\t\t\t\t//             {% endif %} cannot exist without an opening {% if ... %} tag, so open = false.\n\t\t\t\t//\n\t\t\t\t//  Functions:\n\t\t\t\t//\n\t\t\t\t//      compile: A function that handles compiling the token into an output token ready for\n\t\t\t\t//               parsing with the parse function.\n\t\t\t\t//\n\t\t\t\t//      parse:   A function that parses the compiled token into output (HTML / whatever the\n\t\t\t\t//               template represents).\n\t\t\t\tTwig.logic.definitions = [{\n\t\t\t\t\t/**\n      * If type logic tokens.\n      *\n      *  Format: {% if expression %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.if_,\n\t\t\t\t\tregex: /^if\\s+([\\s\\S]+)$/,\n\t\t\t\t\tnext: [Twig.logic.type.else_, Twig.logic.type.elseif, Twig.logic.type.endif],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar expression = token.match[1];\n\t\t\t\t\t\t// Compile the expression.\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar that = this;\n\n\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.stack, context]).then(function (result) {\n\t\t\t\t\t\t\tchain = true;\n\n\t\t\t\t\t\t\tif (Twig.lib.boolval(result)) {\n\t\t\t\t\t\t\t\tchain = false;\n\n\t\t\t\t\t\t\t\treturn Twig.parseAsync.apply(that, [token.output, context]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}).then(function (output) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Else if type logic tokens.\n      *\n      *  Format: {% elseif expression %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.elseif,\n\t\t\t\t\tregex: /^elseif\\s+([^\\s].*)$/,\n\t\t\t\t\tnext: [Twig.logic.type.else_, Twig.logic.type.elseif, Twig.logic.type.endif],\n\t\t\t\t\topen: false,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar expression = token.match[1];\n\t\t\t\t\t\t// Compile the expression.\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar that = this;\n\n\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.stack, context]).then(function (result) {\n\t\t\t\t\t\t\tif (chain && Twig.lib.boolval(result)) {\n\t\t\t\t\t\t\t\tchain = false;\n\n\t\t\t\t\t\t\t\treturn Twig.parseAsync.apply(that, [token.output, context]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}).then(function (output) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Else if type logic tokens.\n      *\n      *  Format: {% elseif expression %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.else_,\n\t\t\t\t\tregex: /^else$/,\n\t\t\t\t\tnext: [Twig.logic.type.endif, Twig.logic.type.endfor],\n\t\t\t\t\topen: false,\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar promise = Twig.Promise.resolve('');\n\n\t\t\t\t\t\tif (chain) {\n\t\t\t\t\t\t\tpromise = Twig.parseAsync.apply(this, [token.output, context]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn promise.then(function (output) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * End if type logic tokens.\n      *\n      *  Format: {% endif %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.endif,\n\t\t\t\t\tregex: /^endif$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * For type logic tokens.\n      *\n      *  Format: {% for expression %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.for_,\n\t\t\t\t\tregex: /^for\\s+([a-zA-Z0-9_,\\s]+)\\s+in\\s+([^\\s].*?)(?:\\s+if\\s+([^\\s].*))?$/,\n\t\t\t\t\tnext: [Twig.logic.type.else_, Twig.logic.type.endfor],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar key_value = token.match[1],\n\t\t\t\t\t\t    expression = token.match[2],\n\t\t\t\t\t\t    conditional = token.match[3],\n\t\t\t\t\t\t    kv_split = null;\n\n\t\t\t\t\t\ttoken.key_var = null;\n\t\t\t\t\t\ttoken.value_var = null;\n\n\t\t\t\t\t\tif (key_value.indexOf(\",\") >= 0) {\n\t\t\t\t\t\t\tkv_split = key_value.split(',');\n\t\t\t\t\t\t\tif (kv_split.length === 2) {\n\t\t\t\t\t\t\t\ttoken.key_var = kv_split[0].trim();\n\t\t\t\t\t\t\t\ttoken.value_var = kv_split[1].trim();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Invalid expression in for loop: \" + key_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.value_var = key_value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Valid expressions for a for loop\n\t\t\t\t\t\t//   for item     in expression\n\t\t\t\t\t\t//   for key,item in expression\n\n\t\t\t\t\t\t// Compile the expression.\n\t\t\t\t\t\ttoken.expression = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\t// Compile the conditional (if available)\n\t\t\t\t\t\tif (conditional) {\n\t\t\t\t\t\t\ttoken.conditional = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\t\tvalue: conditional\n\t\t\t\t\t\t\t}]).stack;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, continue_chain) {\n\t\t\t\t\t\t// Parse expression\n\t\t\t\t\t\tvar output = [],\n\t\t\t\t\t\t    len,\n\t\t\t\t\t\t    index = 0,\n\t\t\t\t\t\t    keyset,\n\t\t\t\t\t\t    that = this,\n\t\t\t\t\t\t    conditional = token.conditional,\n\t\t\t\t\t\t    buildLoop = function (index, len) {\n\t\t\t\t\t\t\tvar isConditional = conditional !== undefined;\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tindex: index + 1,\n\t\t\t\t\t\t\t\tindex0: index,\n\t\t\t\t\t\t\t\trevindex: isConditional ? undefined : len - index,\n\t\t\t\t\t\t\t\trevindex0: isConditional ? undefined : len - index - 1,\n\t\t\t\t\t\t\t\tfirst: index === 0,\n\t\t\t\t\t\t\t\tlast: isConditional ? undefined : index === len - 1,\n\t\t\t\t\t\t\t\tlength: isConditional ? undefined : len,\n\t\t\t\t\t\t\t\tparent: context\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// run once for each iteration of the loop\n\t\t\t\t\t\tloop = function (key, value) {\n\t\t\t\t\t\t\tvar inner_context = Twig.ChildContext(context);\n\n\t\t\t\t\t\t\tinner_context[token.value_var] = value;\n\n\t\t\t\t\t\t\tif (token.key_var) {\n\t\t\t\t\t\t\t\tinner_context[token.key_var] = key;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Loop object\n\t\t\t\t\t\t\tinner_context.loop = buildLoop(index, len);\n\n\t\t\t\t\t\t\tvar promise = conditional === undefined ? Twig.Promise.resolve(true) : Twig.expression.parseAsync.apply(that, [conditional, inner_context]);\n\n\t\t\t\t\t\t\tpromise.then(function (condition) {\n\t\t\t\t\t\t\t\tif (!condition) return;\n\n\t\t\t\t\t\t\t\treturn Twig.parseAsync.apply(that, [token.output, inner_context]).then(function (o) {\n\t\t\t\t\t\t\t\t\toutput.push(o);\n\t\t\t\t\t\t\t\t\tindex += 1;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}).then(function () {\n\t\t\t\t\t\t\t\t// Delete loop-related variables from the context\n\t\t\t\t\t\t\t\tdelete inner_context['loop'];\n\t\t\t\t\t\t\t\tdelete inner_context[token.value_var];\n\t\t\t\t\t\t\t\tdelete inner_context[token.key_var];\n\n\t\t\t\t\t\t\t\t// Merge in values that exist in context but have changed\n\t\t\t\t\t\t\t\t// in inner_context.\n\t\t\t\t\t\t\t\tTwig.merge(context, inner_context, true);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.expression, context]).then(function (result) {\n\t\t\t\t\t\t\tif (Twig.lib.is('Array', result)) {\n\t\t\t\t\t\t\t\tlen = result.length;\n\t\t\t\t\t\t\t\tTwig.async.forEach(result, function (value) {\n\t\t\t\t\t\t\t\t\tvar key = index;\n\n\t\t\t\t\t\t\t\t\treturn loop(key, value);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else if (Twig.lib.is('Object', result)) {\n\t\t\t\t\t\t\t\tif (result._keys !== undefined) {\n\t\t\t\t\t\t\t\t\tkeyset = result._keys;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tkeyset = Object.keys(result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlen = keyset.length;\n\t\t\t\t\t\t\t\tTwig.forEach(keyset, function (key) {\n\t\t\t\t\t\t\t\t\t// Ignore the _keys property, it's internal to twig.js\n\t\t\t\t\t\t\t\t\tif (key === \"_keys\") return;\n\n\t\t\t\t\t\t\t\t\tloop(key, result[key]);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Only allow else statements if no output was generated\n\t\t\t\t\t\t\tcontinue_chain = output.length === 0;\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: continue_chain,\n\t\t\t\t\t\t\t\toutput: Twig.output.apply(that, [output])\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * End if type logic tokens.\n      *\n      *  Format: {% endif %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.endfor,\n\t\t\t\t\tregex: /^endfor$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Set type logic tokens.\n      *\n      *  Format: {% set key = expression %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.set,\n\t\t\t\t\tregex: /^set\\s+([a-zA-Z0-9_,\\s]+)\\s*=\\s*([\\s\\S]+)$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar key = token.match[1].trim(),\n\t\t\t\t\t\t    expression = token.match[2],\n\n\t\t\t\t\t\t// Compile the expression.\n\t\t\t\t\t\texpression_stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\ttoken.key = key;\n\t\t\t\t\t\ttoken.expression = expression_stack;\n\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, continue_chain) {\n\t\t\t\t\t\tvar key = token.key;\n\n\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.expression, context]).then(function (value) {\n\t\t\t\t\t\t\tif (value === context) {\n\t\t\t\t\t\t\t\t/*  If storing the context in a variable, it needs to be a clone of the current state of context.\n            Otherwise we have a context with infinite recursion.\n            Fixes #341\n        */\n\t\t\t\t\t\t\t\tvalue = Twig.lib.copy(value);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontext[key] = value;\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: continue_chain,\n\t\t\t\t\t\t\t\tcontext: context\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Set capture type logic tokens.\n      *\n      *  Format: {% set key %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.setcapture,\n\t\t\t\t\tregex: /^set\\s+([a-zA-Z0-9_,\\s]+)$/,\n\t\t\t\t\tnext: [Twig.logic.type.endset],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar key = token.match[1].trim();\n\n\t\t\t\t\t\ttoken.key = key;\n\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, continue_chain) {\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    key = token.key;\n\n\t\t\t\t\t\treturn Twig.parseAsync.apply(this, [token.output, context]).then(function (value) {\n\t\t\t\t\t\t\t// set on both the global and local context\n\t\t\t\t\t\t\tthat.context[key] = value;\n\t\t\t\t\t\t\tcontext[key] = value;\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: continue_chain,\n\t\t\t\t\t\t\t\tcontext: context\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * End set type block logic tokens.\n      *\n      *  Format: {% endset %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.endset,\n\t\t\t\t\tregex: /^endset$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Filter logic tokens.\n      *\n      *  Format: {% filter upper %} or {% filter lower|escape %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.filter,\n\t\t\t\t\tregex: /^filter\\s+(.+)$/,\n\t\t\t\t\tnext: [Twig.logic.type.endfilter],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar expression = \"|\" + token.match[1].trim();\n\t\t\t\t\t\t// Compile the expression.\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\treturn Twig.parseAsync.apply(this, [token.output, context]).then(function (unfiltered) {\n\t\t\t\t\t\t\tvar stack = [{\n\t\t\t\t\t\t\t\ttype: Twig.expression.type.string,\n\t\t\t\t\t\t\t\tvalue: unfiltered\n\t\t\t\t\t\t\t}].concat(token.stack);\n\n\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(that, [stack, context]);\n\t\t\t\t\t\t}).then(function (output) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * End filter logic tokens.\n      *\n      *  Format: {% endfilter %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.endfilter,\n\t\t\t\t\tregex: /^endfilter$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Block logic tokens.\n      *\n      *  Format: {% block title %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.block,\n\t\t\t\t\tregex: /^block\\s+([a-zA-Z0-9_]+)$/,\n\t\t\t\t\tnext: [Twig.logic.type.endblock],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\ttoken.block = token.match[1].trim();\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    block_output,\n\t\t\t\t\t\t    output,\n\t\t\t\t\t\t    promise = Twig.Promise.resolve(),\n\t\t\t\t\t\t    isImported = Twig.indexOf(this.importedBlocks, token.block) > -1,\n\t\t\t\t\t\t    hasParent = this.blocks[token.block] && Twig.indexOf(this.blocks[token.block], Twig.placeholders.parent) > -1;\n\n\t\t\t\t\t\t// Don't override previous blocks unless they're imported with \"use\"\n\t\t\t\t\t\t// Loops should be exempted as well.\n\t\t\t\t\t\tif (this.blocks[token.block] === undefined || isImported || hasParent || context.loop || token.overwrite) {\n\t\t\t\t\t\t\tif (token.expression) {\n\t\t\t\t\t\t\t\tpromise = Twig.expression.parseAsync.apply(this, [token.output, context]).then(function (value) {\n\t\t\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(that, [{\n\t\t\t\t\t\t\t\t\t\ttype: Twig.expression.type.string,\n\t\t\t\t\t\t\t\t\t\tvalue: value\n\t\t\t\t\t\t\t\t\t}, context]);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpromise = Twig.parseAsync.apply(this, [token.output, context]).then(function (value) {\n\t\t\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(that, [{\n\t\t\t\t\t\t\t\t\t\ttype: Twig.expression.type.string,\n\t\t\t\t\t\t\t\t\t\tvalue: value\n\t\t\t\t\t\t\t\t\t}, context]);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpromise = promise.then(function (block_output) {\n\t\t\t\t\t\t\t\tif (isImported) {\n\t\t\t\t\t\t\t\t\t// once the block is overridden, remove it from the list of imported blocks\n\t\t\t\t\t\t\t\t\tthat.importedBlocks.splice(that.importedBlocks.indexOf(token.block), 1);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (hasParent) {\n\t\t\t\t\t\t\t\t\tthat.blocks[token.block] = Twig.Markup(that.blocks[token.block].replace(Twig.placeholders.parent, block_output));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthat.blocks[token.block] = block_output;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthat.originalBlockTokens[token.block] = {\n\t\t\t\t\t\t\t\t\ttype: token.type,\n\t\t\t\t\t\t\t\t\tblock: token.block,\n\t\t\t\t\t\t\t\t\toutput: token.output,\n\t\t\t\t\t\t\t\t\toverwrite: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn promise.then(function () {\n\t\t\t\t\t\t\t// Check if a child block has been set from a template extending this one.\n\t\t\t\t\t\t\tif (that.child.blocks[token.block]) {\n\t\t\t\t\t\t\t\toutput = that.child.blocks[token.block];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toutput = that.blocks[token.block];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Block shorthand logic tokens.\n      *\n      *  Format: {% block title expression %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.shortblock,\n\t\t\t\t\tregex: /^block\\s+([a-zA-Z0-9_]+)\\s+(.+)$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\ttoken.expression = token.match[2].trim();\n\n\t\t\t\t\t\ttoken.output = Twig.expression.compile({\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: token.expression\n\t\t\t\t\t\t}).stack;\n\n\t\t\t\t\t\ttoken.block = token.match[1].trim();\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\treturn Twig.logic.handler[Twig.logic.type.block].parse.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * End block logic tokens.\n      *\n      *  Format: {% endblock %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.endblock,\n\t\t\t\t\tregex: /^endblock(?:\\s+([a-zA-Z0-9_]+))?$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Block logic tokens.\n      *\n      *  Format: {% extends \"template.twig\" %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.extends_,\n\t\t\t\t\tregex: /^extends\\s+(.+)$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar expression = token.match[1].trim();\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar template,\n\t\t\t\t\t\t    that = this,\n\t\t\t\t\t\t    innerContext = Twig.ChildContext(context);\n\n\t\t\t\t\t\t// Resolve filename\n\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.stack, context]).then(function (file) {\n\t\t\t\t\t\t\t// Set parent template\n\t\t\t\t\t\t\tthat.extend = file;\n\n\t\t\t\t\t\t\tif (file instanceof Twig.Template) {\n\t\t\t\t\t\t\t\ttemplate = file;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Import file\n\t\t\t\t\t\t\t\ttemplate = that.importFile(file);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Render the template in case it puts anything in its context\n\t\t\t\t\t\t\treturn template.renderAsync(innerContext);\n\t\t\t\t\t\t}).then(function () {\n\t\t\t\t\t\t\t// Extend the parent context with the extended context\n\t\t\t\t\t\t\tTwig.lib.extend(context, innerContext);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: ''\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Block logic tokens.\n      *\n      *  Format: {% use \"template.twig\" %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.use,\n\t\t\t\t\tregex: /^use\\s+(.+)$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar expression = token.match[1].trim();\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar that = this;\n\n\t\t\t\t\t\t// Resolve filename\n\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.stack, context]).then(function (file) {\n\t\t\t\t\t\t\t// Import blocks\n\t\t\t\t\t\t\tthat.importBlocks(file);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: ''\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Block logic tokens.\n      *\n      *  Format: {% includes \"template.twig\" [with {some: 'values'} only] %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.include,\n\t\t\t\t\tregex: /^include\\s+(.+?)(?:\\s|$)(ignore missing(?:\\s|$))?(?:with\\s+([\\S\\s]+?))?(?:\\s|$)(only)?$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar match = token.match,\n\t\t\t\t\t\t    expression = match[1].trim(),\n\t\t\t\t\t\t    ignoreMissing = match[2] !== undefined,\n\t\t\t\t\t\t    withContext = match[3],\n\t\t\t\t\t\t    only = match[4] !== undefined && match[4].length;\n\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.only = only;\n\t\t\t\t\t\ttoken.ignoreMissing = ignoreMissing;\n\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\tif (withContext !== undefined) {\n\t\t\t\t\t\t\ttoken.withStack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\t\tvalue: withContext.trim()\n\t\t\t\t\t\t\t}]).stack;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\t// Resolve filename\n\t\t\t\t\t\tvar innerContext = {},\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    template,\n\t\t\t\t\t\t    that = this,\n\t\t\t\t\t\t    promise = Twig.Promise.resolve();\n\n\t\t\t\t\t\tif (!token.only) {\n\t\t\t\t\t\t\tinnerContext = Twig.ChildContext(context);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (token.withStack !== undefined) {\n\t\t\t\t\t\t\tpromise = Twig.expression.parseAsync.apply(this, [token.withStack, context]).then(function (withContext) {\n\t\t\t\t\t\t\t\tfor (i in withContext) {\n\t\t\t\t\t\t\t\t\tif (withContext.hasOwnProperty(i)) innerContext[i] = withContext[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn promise.then(function () {\n\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(that, [token.stack, context]);\n\t\t\t\t\t\t}).then(function (file) {\n\t\t\t\t\t\t\tif (file instanceof Twig.Template) {\n\t\t\t\t\t\t\t\ttemplate = file;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Import file\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttemplate = that.importFile(file);\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tif (token.ignoreMissing) {\n\t\t\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn template.renderAsync(innerContext);\n\t\t\t\t\t\t}).then(function (output) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\ttype: Twig.logic.type.spaceless,\n\t\t\t\t\tregex: /^spaceless$/,\n\t\t\t\t\tnext: [Twig.logic.type.endspaceless],\n\t\t\t\t\topen: true,\n\n\t\t\t\t\t// Parse the html and return it without any spaces between tags\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\t// Parse the output without any filter\n\t\t\t\t\t\treturn Twig.parseAsync.apply(this, [token.output, context]).then(function (unfiltered) {\n\t\t\t\t\t\t\tvar // A regular expression to find closing and opening tags with spaces between them\n\t\t\t\t\t\t\trBetweenTagSpaces = />\\s+</g,\n\n\t\t\t\t\t\t\t// Replace all space between closing and opening html tags\n\t\t\t\t\t\t\toutput = unfiltered.replace(rBetweenTagSpaces, '><').trim();\n\t\t\t\t\t\t\t// Rewrap output as a Twig.Markup\n\t\t\t\t\t\t\toutput = Twig.Markup(output);\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Add the {% endspaceless %} token\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.logic.type.endspaceless,\n\t\t\t\t\tregex: /^endspaceless$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * Macro logic tokens.\n      *\n      * Format: {% maro input(name, value, type, size) %}\n      *\n      */\n\t\t\t\t\ttype: Twig.logic.type.macro,\n\t\t\t\t\tregex: /^macro\\s+([a-zA-Z0-9_]+)\\s*\\(\\s*((?:[a-zA-Z0-9_]+(?:,\\s*)?)*)\\s*\\)$/,\n\t\t\t\t\tnext: [Twig.logic.type.endmacro],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar macroName = token.match[1],\n\t\t\t\t\t\t    parameters = token.match[2].split(/[\\s,]+/);\n\n\t\t\t\t\t\t//TODO: Clean up duplicate check\n\t\t\t\t\t\tfor (var i = 0; i < parameters.length; i++) {\n\t\t\t\t\t\t\tfor (var j = 0; j < parameters.length; j++) {\n\t\t\t\t\t\t\t\tif (parameters[i] === parameters[j] && i !== j) {\n\t\t\t\t\t\t\t\t\tthrow new Twig.Error(\"Duplicate arguments for parameter: \" + parameters[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttoken.macroName = macroName;\n\t\t\t\t\t\ttoken.parameters = parameters;\n\n\t\t\t\t\t\tdelete token.match;\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar template = this;\n\t\t\t\t\t\tthis.macros[token.macroName] = function () {\n\t\t\t\t\t\t\t// Pass global context and other macros\n\t\t\t\t\t\t\tvar macroContext = {\n\t\t\t\t\t\t\t\t_self: template.macros\n\t\t\t\t\t\t\t\t// Add parameters from context to macroContext\n\t\t\t\t\t\t\t};for (var i = 0; i < token.parameters.length; i++) {\n\t\t\t\t\t\t\t\tvar prop = token.parameters[i];\n\t\t\t\t\t\t\t\tif (typeof arguments[i] !== 'undefined') {\n\t\t\t\t\t\t\t\t\tmacroContext[prop] = arguments[i];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmacroContext[prop] = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Render\n\t\t\t\t\t\t\treturn Twig.parseAsync.apply(template, [token.output, macroContext]);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\toutput: ''\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * End macro logic tokens.\n      *\n      * Format: {% endmacro %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.endmacro,\n\t\t\t\t\tregex: /^endmacro$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}, {\n\t\t\t\t\t/*\n     * import logic tokens.\n     *\n     * Format: {% import \"template.twig\" as form %}\n     */\n\t\t\t\t\ttype: Twig.logic.type.import_,\n\t\t\t\t\tregex: /^import\\s+(.+)\\s+as\\s+([a-zA-Z0-9_]+)$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar expression = token.match[1].trim(),\n\t\t\t\t\t\t    contextName = token.match[2].trim();\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.expression = expression;\n\t\t\t\t\t\ttoken.contextName = contextName;\n\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    output = { chain: chain, output: '' };\n\n\t\t\t\t\t\tif (token.expression === '_self') {\n\t\t\t\t\t\t\tcontext[token.contextName] = this.macros;\n\t\t\t\t\t\t\treturn Twig.Promise.resolve(output);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(this, [token.stack, context]).then(function (file) {\n\t\t\t\t\t\t\treturn that.importFile(file || token.expression);\n\t\t\t\t\t\t}).then(function (template) {\n\t\t\t\t\t\t\tcontext[token.contextName] = template.renderAsync({}, { output: 'macros' });\n\n\t\t\t\t\t\t\treturn output;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/*\n     * from logic tokens.\n     *\n     * Format: {% from \"template.twig\" import func as form %}\n     */\n\t\t\t\t\ttype: Twig.logic.type.from,\n\t\t\t\t\tregex: /^from\\s+(.+)\\s+import\\s+([a-zA-Z0-9_, ]+)$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar expression = token.match[1].trim(),\n\t\t\t\t\t\t    macroExpressions = token.match[2].trim().split(/\\s*,\\s*/),\n\t\t\t\t\t\t    macroNames = {};\n\n\t\t\t\t\t\tfor (var i = 0; i < macroExpressions.length; i++) {\n\t\t\t\t\t\t\tvar res = macroExpressions[i];\n\n\t\t\t\t\t\t\t// match function as variable\n\t\t\t\t\t\t\tvar macroMatch = res.match(/^([a-zA-Z0-9_]+)\\s+as\\s+([a-zA-Z0-9_]+)$/);\n\t\t\t\t\t\t\tif (macroMatch) {\n\t\t\t\t\t\t\t\tmacroNames[macroMatch[1].trim()] = macroMatch[2].trim();\n\t\t\t\t\t\t\t} else if (res.match(/^([a-zA-Z0-9_]+)$/)) {\n\t\t\t\t\t\t\t\tmacroNames[res] = res;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// ignore import\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.expression = expression;\n\t\t\t\t\t\ttoken.macroNames = macroNames;\n\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t    promise = Twig.Promise.resolve(this.macros);\n\n\t\t\t\t\t\tif (token.expression !== \"_self\") {\n\t\t\t\t\t\t\tpromise = Twig.expression.parseAsync.apply(this, [token.stack, context]).then(function (file) {\n\t\t\t\t\t\t\t\treturn that.importFile(file || token.expression);\n\t\t\t\t\t\t\t}).then(function (template) {\n\t\t\t\t\t\t\t\treturn template.renderAsync({}, { output: 'macros' });\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn promise.then(function (macros) {\n\t\t\t\t\t\t\tfor (var macroName in token.macroNames) {\n\t\t\t\t\t\t\t\tif (macros.hasOwnProperty(macroName)) {\n\t\t\t\t\t\t\t\t\tcontext[token.macroNames[macroName]] = macros[macroName];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: ''\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, {\n\t\t\t\t\t/**\n      * The embed tag combines the behaviour of include and extends.\n      * It allows you to include another template's contents, just like include does.\n      *\n      *  Format: {% embed \"template.twig\" [with {some: 'values'} only] %}\n      */\n\t\t\t\t\ttype: Twig.logic.type.embed,\n\t\t\t\t\tregex: /^embed\\s+(.+?)(?:\\s|$)(ignore missing(?:\\s|$))?(?:with\\s+([\\S\\s]+?))?(?:\\s|$)(only)?$/,\n\t\t\t\t\tnext: [Twig.logic.type.endembed],\n\t\t\t\t\topen: true,\n\t\t\t\t\tcompile: function (token) {\n\t\t\t\t\t\tvar match = token.match,\n\t\t\t\t\t\t    expression = match[1].trim(),\n\t\t\t\t\t\t    ignoreMissing = match[2] !== undefined,\n\t\t\t\t\t\t    withContext = match[3],\n\t\t\t\t\t\t    only = match[4] !== undefined && match[4].length;\n\n\t\t\t\t\t\tdelete token.match;\n\n\t\t\t\t\t\ttoken.only = only;\n\t\t\t\t\t\ttoken.ignoreMissing = ignoreMissing;\n\n\t\t\t\t\t\ttoken.stack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\tvalue: expression\n\t\t\t\t\t\t}]).stack;\n\n\t\t\t\t\t\tif (withContext !== undefined) {\n\t\t\t\t\t\t\ttoken.withStack = Twig.expression.compile.apply(this, [{\n\t\t\t\t\t\t\t\ttype: Twig.expression.type.expression,\n\t\t\t\t\t\t\t\tvalue: withContext.trim()\n\t\t\t\t\t\t\t}]).stack;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn token;\n\t\t\t\t\t},\n\t\t\t\t\tparse: function (token, context, chain) {\n\t\t\t\t\t\t// Resolve filename\n\t\t\t\t\t\tvar innerContext = {},\n\t\t\t\t\t\t    that = this,\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    template,\n\t\t\t\t\t\t    promise = Twig.Promise.resolve();\n\n\t\t\t\t\t\tif (!token.only) {\n\t\t\t\t\t\t\tfor (i in context) {\n\t\t\t\t\t\t\t\tif (context.hasOwnProperty(i)) innerContext[i] = context[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (token.withStack !== undefined) {\n\t\t\t\t\t\t\tpromise = Twig.expression.parseAsync.apply(this, [token.withStack, context]).then(function (withContext) {\n\t\t\t\t\t\t\t\tfor (i in withContext) {\n\t\t\t\t\t\t\t\t\tif (withContext.hasOwnProperty(i)) innerContext[i] = withContext[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn promise.then(function () {\n\t\t\t\t\t\t\treturn Twig.expression.parseAsync.apply(that, [token.stack, innerContext]);\n\t\t\t\t\t\t}).then(function (file) {\n\t\t\t\t\t\t\tif (file instanceof Twig.Template) {\n\t\t\t\t\t\t\t\ttemplate = file;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Import file\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\ttemplate = that.importFile(file);\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tif (token.ignoreMissing) {\n\t\t\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// reset previous blocks\n\t\t\t\t\t\t\tthat.blocks = {};\n\n\t\t\t\t\t\t\t// parse tokens. output will be not used\n\t\t\t\t\t\t\treturn Twig.parseAsync.apply(that, [token.output, innerContext]).then(function () {\n\t\t\t\t\t\t\t\t// render tempalte with blocks defined in embed block\n\t\t\t\t\t\t\t\treturn template.renderAsync(innerContext, { 'blocks': that.blocks });\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}).then(function (output) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\t\t\toutput: output\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/* Add the {% endembed %} token\n     *\n     */\n\t\t\t\t{\n\t\t\t\t\ttype: Twig.logic.type.endembed,\n\t\t\t\t\tregex: /^endembed$/,\n\t\t\t\t\tnext: [],\n\t\t\t\t\topen: false\n\t\t\t\t}];\n\n\t\t\t\t/**\n     * Registry for logic handlers.\n     */\n\t\t\t\tTwig.logic.handler = {};\n\n\t\t\t\t/**\n     * Define a new token type, available at Twig.logic.type.{type}\n     */\n\t\t\t\tTwig.logic.extendType = function (type, value) {\n\t\t\t\t\tvalue = value || \"Twig.logic.type\" + type;\n\t\t\t\t\tTwig.logic.type[type] = value;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Extend the logic parsing functionality with a new token definition.\n     *\n     * // Define a new tag\n     * Twig.logic.extend({\n     *     type: Twig.logic.type.{type},\n     *     // The pattern to match for this token\n     *     regex: ...,\n     *     // What token types can follow this token, leave blank if any.\n     *     next: [ ... ]\n     *     // Create and return compiled version of the token\n     *     compile: function(token) { ... }\n     *     // Parse the compiled token with the context provided by the render call\n     *     //   and whether this token chain is complete.\n     *     parse: function(token, context, chain) { ... }\n     * });\n     *\n     * @param {Object} definition The new logic expression.\n     */\n\t\t\t\tTwig.logic.extend = function (definition) {\n\n\t\t\t\t\tif (!definition.type) {\n\t\t\t\t\t\tthrow new Twig.Error(\"Unable to extend logic definition. No type provided for \" + definition);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTwig.logic.extendType(definition.type);\n\t\t\t\t\t}\n\t\t\t\t\tTwig.logic.handler[definition.type] = definition;\n\t\t\t\t};\n\n\t\t\t\t// Extend with built-in expressions\n\t\t\t\twhile (Twig.logic.definitions.length > 0) {\n\t\t\t\t\tTwig.logic.extend(Twig.logic.definitions.shift());\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Compile a logic token into an object ready for parsing.\n     *\n     * @param {Object} raw_token An uncompiled logic token.\n     *\n     * @return {Object} A compiled logic token, ready for parsing.\n     */\n\t\t\t\tTwig.logic.compile = function (raw_token) {\n\t\t\t\t\tvar expression = raw_token.value.trim(),\n\t\t\t\t\t    token = Twig.logic.tokenize.apply(this, [expression]),\n\t\t\t\t\t    token_template = Twig.logic.handler[token.type];\n\n\t\t\t\t\t// Check if the token needs compiling\n\t\t\t\t\tif (token_template.compile) {\n\t\t\t\t\t\ttoken = token_template.compile.apply(this, [token]);\n\t\t\t\t\t\tTwig.log.trace(\"Twig.logic.compile: \", \"Compiled logic token to \", token);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn token;\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Tokenize logic expressions. This function matches token expressions against regular\n     * expressions provided in token definitions provided with Twig.logic.extend.\n     *\n     * @param {string} expression the logic token expression to tokenize\n     *                (i.e. what's between {% and %})\n     *\n     * @return {Object} The matched token with type set to the token type and match to the regex match.\n     */\n\t\t\t\tTwig.logic.tokenize = function (expression) {\n\t\t\t\t\tvar token = {},\n\t\t\t\t\t    token_template_type = null,\n\t\t\t\t\t    token_type = null,\n\t\t\t\t\t    token_regex = null,\n\t\t\t\t\t    regex_array = null,\n\t\t\t\t\t    regex = null,\n\t\t\t\t\t    match = null;\n\n\t\t\t\t\t// Ignore whitespace around expressions.\n\t\t\t\t\texpression = expression.trim();\n\n\t\t\t\t\tfor (token_template_type in Twig.logic.handler) {\n\t\t\t\t\t\tif (Twig.logic.handler.hasOwnProperty(token_template_type)) {\n\t\t\t\t\t\t\t// Get the type and regex for this template type\n\t\t\t\t\t\t\ttoken_type = Twig.logic.handler[token_template_type].type;\n\t\t\t\t\t\t\ttoken_regex = Twig.logic.handler[token_template_type].regex;\n\n\t\t\t\t\t\t\t// Handle multiple regular expressions per type.\n\t\t\t\t\t\t\tregex_array = [];\n\t\t\t\t\t\t\tif (token_regex instanceof Array) {\n\t\t\t\t\t\t\t\tregex_array = token_regex;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tregex_array.push(token_regex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check regular expressions in the order they were specified in the definition.\n\t\t\t\t\t\t\twhile (regex_array.length > 0) {\n\t\t\t\t\t\t\t\tregex = regex_array.shift();\n\t\t\t\t\t\t\t\tmatch = regex.exec(expression.trim());\n\t\t\t\t\t\t\t\tif (match !== null) {\n\t\t\t\t\t\t\t\t\ttoken.type = token_type;\n\t\t\t\t\t\t\t\t\ttoken.match = match;\n\t\t\t\t\t\t\t\t\tTwig.log.trace(\"Twig.logic.tokenize: \", \"Matched a \", token_type, \" regular expression of \", match);\n\t\t\t\t\t\t\t\t\treturn token;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// No regex matches\n\t\t\t\t\tthrow new Twig.Error(\"Unable to parse '\" + expression.trim() + \"'\");\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Parse a logic token within a given context.\n     *\n     * What are logic chains?\n     *      Logic chains represent a series of tokens that are connected,\n     *          for example:\n     *          {% if ... %} {% else %} {% endif %}\n     *\n     *      The chain parameter is used to signify if a chain is open of closed.\n     *      open:\n     *          More tokens in this chain should be parsed.\n     *      closed:\n     *          This token chain has completed parsing and any additional\n     *          tokens (else, elseif, etc...) should be ignored.\n     *\n     * @param {Object} token The compiled token.\n     * @param {Object} context The render context.\n     * @param {boolean} chain Is this an open logic chain. If false, that means a\n     *                        chain is closed and no further cases should be parsed.\n     */\n\t\t\t\tTwig.logic.parse = function (token, context, chain, allow_async) {\n\t\t\t\t\tvar output = '',\n\t\t\t\t\t    promise,\n\t\t\t\t\t    is_async = true,\n\t\t\t\t\t    token_template;\n\n\t\t\t\t\tcontext = context || {};\n\n\t\t\t\t\tTwig.log.debug(\"Twig.logic.parse: \", \"Parsing logic token \", token);\n\n\t\t\t\t\ttoken_template = Twig.logic.handler[token.type];\n\n\t\t\t\t\tif (token_template.parse) {\n\t\t\t\t\t\toutput = token_template.parse.apply(this, [token, context, chain]);\n\t\t\t\t\t}\n\n\t\t\t\t\tpromise = Twig.isPromise(output) ? output : Twig.Promise.resolve(output);\n\n\t\t\t\t\tpromise.then(function (o) {\n\t\t\t\t\t\tis_async = false;\n\t\t\t\t\t\toutput = o;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (allow_async) return promise || Twig.Promise.resolve(output);\n\n\t\t\t\t\tif (is_async) throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');\n\n\t\t\t\t\treturn output;\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 22 */\n\t\t/***/function (module, exports) {\n\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t'use strict';\n\n\t\t\t\tTwig.Templates.registerParser('source', function (params) {\n\t\t\t\t\treturn params.data || '';\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 23 */\n\t\t/***/function (module, exports) {\n\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t'use strict';\n\n\t\t\t\tTwig.Templates.registerParser('twig', function (params) {\n\t\t\t\t\treturn new Twig.Template(params);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 24 */\n\t\t/***/function (module, exports, __webpack_require__) {\n\n\t\t\t// ## twig.path.js\n\t\t\t//\n\t\t\t// This file handles path parsing\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\t/**\n     * Namespace for path handling.\n     */\n\n\t\t\t\tTwig.path = {};\n\n\t\t\t\t/**\n     * Generate the canonical version of a url based on the given base path and file path and in\n     * the previously registered namespaces.\n     *\n     * @param  {string} template The Twig Template\n     * @param  {string} file     The file path, may be relative and may contain namespaces.\n     *\n     * @return {string}          The canonical version of the path\n     */\n\t\t\t\tTwig.path.parsePath = function (template, file) {\n\t\t\t\t\tvar namespaces = null,\n\t\t\t\t\t    file = file || \"\";\n\n\t\t\t\t\tif (typeof template === 'object' && typeof template.options === 'object') {\n\t\t\t\t\t\tnamespaces = template.options.namespaces;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof namespaces === 'object' && file.indexOf('::') > 0 || file.indexOf('@') >= 0) {\n\t\t\t\t\t\tfor (var k in namespaces) {\n\t\t\t\t\t\t\tif (namespaces.hasOwnProperty(k)) {\n\t\t\t\t\t\t\t\tfile = file.replace(k + '::', namespaces[k]);\n\t\t\t\t\t\t\t\tfile = file.replace('@' + k, namespaces[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn file;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Twig.path.relativePath(template, file);\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Generate the relative canonical version of a url based on the given base path and file path.\n     *\n     * @param {Twig.Template} template The Twig.Template.\n     * @param {string} file The file path, relative to the base path.\n     *\n     * @return {string} The canonical version of the path.\n     */\n\t\t\t\tTwig.path.relativePath = function (template, file) {\n\t\t\t\t\tvar base,\n\t\t\t\t\t    base_path,\n\t\t\t\t\t    sep_chr = \"/\",\n\t\t\t\t\t    new_path = [],\n\t\t\t\t\t    file = file || \"\",\n\t\t\t\t\t    val;\n\n\t\t\t\t\tif (template.url) {\n\t\t\t\t\t\tif (typeof template.base !== 'undefined') {\n\t\t\t\t\t\t\tbase = template.base + (template.base.charAt(template.base.length - 1) === '/' ? '' : '/');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbase = template.url;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (template.path) {\n\t\t\t\t\t\t// Get the system-specific path separator\n\t\t\t\t\t\tvar path = __webpack_require__(20),\n\t\t\t\t\t\t    sep = path.sep || sep_chr,\n\t\t\t\t\t\t    relative = new RegExp(\"^\\\\.{1,2}\" + sep.replace(\"\\\\\", \"\\\\\\\\\"));\n\t\t\t\t\t\tfile = file.replace(/\\//g, sep);\n\n\t\t\t\t\t\tif (template.base !== undefined && file.match(relative) == null) {\n\t\t\t\t\t\t\tfile = file.replace(template.base, '');\n\t\t\t\t\t\t\tbase = template.base + sep;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbase = path.normalize(template.path);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbase = base.replace(sep + sep, sep);\n\t\t\t\t\t\tsep_chr = sep;\n\t\t\t\t\t} else if ((template.name || template.id) && template.method && template.method !== 'fs' && template.method !== 'ajax') {\n\t\t\t\t\t\t// Custom registered loader\n\t\t\t\t\t\tbase = template.base || template.name || template.id;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Twig.Error(\"Cannot extend an inline template.\");\n\t\t\t\t\t}\n\n\t\t\t\t\tbase_path = base.split(sep_chr);\n\n\t\t\t\t\t// Remove file from url\n\t\t\t\t\tbase_path.pop();\n\t\t\t\t\tbase_path = base_path.concat(file.split(sep_chr));\n\n\t\t\t\t\twhile (base_path.length > 0) {\n\t\t\t\t\t\tval = base_path.shift();\n\t\t\t\t\t\tif (val == \".\") {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t} else if (val == \"..\" && new_path.length > 0 && new_path[new_path.length - 1] != \"..\") {\n\t\t\t\t\t\t\tnew_path.pop();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnew_path.push(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new_path.join(sep_chr);\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 25 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.tests.js\n\t\t\t//\n\t\t\t// This file handles expression tests. (is empty, is not defined, etc...)\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\tTwig.tests = {\n\t\t\t\t\tempty: function (value) {\n\t\t\t\t\t\tif (value === null || value === undefined) return true;\n\t\t\t\t\t\t// Handler numbers\n\t\t\t\t\t\tif (typeof value === \"number\") return false; // numbers are never \"empty\"\n\t\t\t\t\t\t// Handle strings and arrays\n\t\t\t\t\t\tif (value.length && value.length > 0) return false;\n\t\t\t\t\t\t// Handle objects\n\t\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\t\tif (value.hasOwnProperty(key)) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\todd: function (value) {\n\t\t\t\t\t\treturn value % 2 === 1;\n\t\t\t\t\t},\n\t\t\t\t\teven: function (value) {\n\t\t\t\t\t\treturn value % 2 === 0;\n\t\t\t\t\t},\n\t\t\t\t\tdivisibleby: function (value, params) {\n\t\t\t\t\t\treturn value % params[0] === 0;\n\t\t\t\t\t},\n\t\t\t\t\tdefined: function (value) {\n\t\t\t\t\t\treturn value !== undefined;\n\t\t\t\t\t},\n\t\t\t\t\tnone: function (value) {\n\t\t\t\t\t\treturn value === null;\n\t\t\t\t\t},\n\t\t\t\t\t'null': function (value) {\n\t\t\t\t\t\treturn this.none(value); // Alias of none\n\t\t\t\t\t},\n\t\t\t\t\t'same as': function (value, params) {\n\t\t\t\t\t\treturn value === params[0];\n\t\t\t\t\t},\n\t\t\t\t\tsameas: function (value, params) {\n\t\t\t\t\t\tconsole.warn('`sameas` is deprecated use `same as`');\n\t\t\t\t\t\treturn Twig.tests['same as'](value, params);\n\t\t\t\t\t},\n\t\t\t\t\titerable: function (value) {\n\t\t\t\t\t\treturn value && (Twig.lib.is(\"Array\", value) || Twig.lib.is(\"Object\", value));\n\t\t\t\t\t}\n\t\t\t\t\t/*\n     constant ?\n      */\n\t\t\t\t};\n\n\t\t\t\tTwig.test = function (test, value, params) {\n\t\t\t\t\tif (!Twig.tests[test]) {\n\t\t\t\t\t\tthrow \"Test \" + test + \" is not defined.\";\n\t\t\t\t\t}\n\t\t\t\t\treturn Twig.tests[test](value, params);\n\t\t\t\t};\n\n\t\t\t\tTwig.test.extend = function (test, definition) {\n\t\t\t\t\tTwig.tests[test] = definition;\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 26 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.async.js\n\t\t\t//\n\t\t\t// This file handles asynchronous tasks within twig.\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\tTwig.parseAsync = function (tokens, context) {\n\t\t\t\t\treturn Twig.parse.apply(this, [tokens, context, true]);\n\t\t\t\t};\n\n\t\t\t\tTwig.expression.parseAsync = function (tokens, context, tokens_are_parameters) {\n\t\t\t\t\treturn Twig.expression.parse.apply(this, [tokens, context, tokens_are_parameters, true]);\n\t\t\t\t};\n\n\t\t\t\tTwig.logic.parseAsync = function (token, context, chain) {\n\t\t\t\t\treturn Twig.logic.parse.apply(this, [token, context, chain, true]);\n\t\t\t\t};\n\n\t\t\t\tTwig.Template.prototype.renderAsync = function (context, params) {\n\t\t\t\t\treturn this.render(context, params, true);\n\t\t\t\t};\n\n\t\t\t\tTwig.async = {};\n\n\t\t\t\t/**\n     * Checks for `thenable` objects\n     */\n\t\t\t\tTwig.isPromise = function (obj) {\n\t\t\t\t\treturn obj && typeof obj.then == 'function';\n\t\t\t\t};\n\n\t\t\t\t/**\n     * An alternate implementation of a Promise that does not fully follow\n     * the spec, but instead works fully synchronous while still being\n     * thenable.\n     *\n     * These promises can be mixed with regular promises at which point\n     * the synchronous behaviour is lost.\n     */\n\t\t\t\tTwig.Promise = function (executor) {\n\t\t\t\t\t// State\n\t\t\t\t\tvar state = 'unknown';\n\t\t\t\t\tvar value = null;\n\t\t\t\t\tvar handlers = null;\n\n\t\t\t\t\tfunction changeState(newState, v) {\n\t\t\t\t\t\tstate = newState;\n\t\t\t\t\t\tvalue = v;\n\t\t\t\t\t\tnotify();\n\t\t\t\t\t};\n\t\t\t\t\tfunction onResolve(v) {\n\t\t\t\t\t\tchangeState('resolve', v);\n\t\t\t\t\t}\n\t\t\t\t\tfunction onReject(e) {\n\t\t\t\t\t\tchangeState('reject', e);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction notify() {\n\t\t\t\t\t\tif (!handlers) return;\n\n\t\t\t\t\t\tTwig.forEach(handlers, function (h) {\n\t\t\t\t\t\t\tappend(h.resolve, h.reject);\n\t\t\t\t\t\t});\n\t\t\t\t\t\thandlers = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction append(onResolved, onRejected) {\n\t\t\t\t\t\tvar h = {\n\t\t\t\t\t\t\tresolve: onResolved,\n\t\t\t\t\t\t\treject: onRejected\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// The promise has yet to be rejected or resolved.\n\t\t\t\t\t\tif (state == 'unknown') {\n\t\t\t\t\t\t\thandlers = handlers || [];\n\t\t\t\t\t\t\treturn handlers.push(h);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The state has been changed to either resolve, or reject\n\t\t\t\t\t\t// which means we should call the handler.\n\t\t\t\t\t\tif (h[state]) h[state](value);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction run(fn, resolve, reject) {\n\t\t\t\t\t\tvar done = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfn(function (v) {\n\t\t\t\t\t\t\t\tif (done) return;\n\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t\tresolve(v);\n\t\t\t\t\t\t\t}, function (e) {\n\t\t\t\t\t\t\t\tif (done) return;\n\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction ready(result) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!Twig.isPromise(result)) {\n\t\t\t\t\t\t\t\treturn onResolve(result);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trun(result.then.bind(result), ready, onReject);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tonReject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trun(executor, ready, onReject);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tthen: function (onResolved, onRejected) {\n\t\t\t\t\t\t\tvar hasResolved = typeof onResolved == 'function';\n\t\t\t\t\t\t\tvar hasRejected = typeof onRejected == 'function';\n\n\t\t\t\t\t\t\treturn new Twig.Promise(function (resolve, reject) {\n\t\t\t\t\t\t\t\tappend(function (result) {\n\t\t\t\t\t\t\t\t\tif (hasResolved) {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tresolve(onResolved(result));\n\t\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, function (err) {\n\t\t\t\t\t\t\t\t\tif (hasRejected) {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tresolve(onRejected(err));\n\t\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcatch: function (onRejected) {\n\t\t\t\t\t\t\treturn this.then(null, onRejected);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\tTwig.Promise.resolve = function (value) {\n\t\t\t\t\treturn new Twig.Promise(function (resolve) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tTwig.Promise.reject = function (e) {\n\t\t\t\t\treturn new Twig.Promise(function (resolve, reject) {\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tTwig.Promise.all = function (promises) {\n\t\t\t\t\tvar results = [];\n\n\t\t\t\t\treturn Twig.async.forEach(promises, function (p, index) {\n\t\t\t\t\t\tif (!Twig.isPromise(p)) {\n\t\t\t\t\t\t\tresults[index] = p;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn p.then(function (v) {\n\t\t\t\t\t\t\tresults[index] = v;\n\t\t\t\t\t\t});\n\t\t\t\t\t}).then(function () {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\t/**\n    * Go over each item in a fashion compatible with Twig.forEach,\n    * allow the function to return a promise or call the third argument\n    * to signal it is finished.\n    *\n    * Each item in the array will be called sequentially.\n    */\n\t\t\t\tTwig.async.forEach = function forEachAsync(arr, callback) {\n\t\t\t\t\tvar arg_index = 0;\n\t\t\t\t\tvar callbacks = {};\n\t\t\t\t\tvar promise = new Twig.Promise(function (resolve, reject) {\n\t\t\t\t\t\tcallbacks = {\n\t\t\t\t\t\t\tresolve: resolve,\n\t\t\t\t\t\t\treject: reject\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\n\t\t\t\t\tfunction fail(err) {\n\t\t\t\t\t\tcallbacks.reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction next(value) {\n\t\t\t\t\t\tif (!Twig.isPromise(value)) return iterate();\n\n\t\t\t\t\t\tvalue.then(next, fail);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction iterate() {\n\t\t\t\t\t\tvar index = arg_index++;\n\n\t\t\t\t\t\tif (index == arr.length) {\n\t\t\t\t\t\t\tcallbacks.resolve();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext(callback(arr[index], index));\n\t\t\t\t\t}\n\n\t\t\t\t\titerate();\n\n\t\t\t\t\treturn promise;\n\t\t\t\t};\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t},\n\t\t/* 27 */\n\t\t/***/function (module, exports) {\n\n\t\t\t// ## twig.exports.js\n\t\t\t//\n\t\t\t// This file provides extension points and other hooks into the twig functionality.\n\n\t\t\tmodule.exports = function (Twig) {\n\t\t\t\t\"use strict\";\n\n\t\t\t\tTwig.exports = {\n\t\t\t\t\tVERSION: Twig.VERSION\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Create and compile a twig.js template.\n     *\n     * @param {Object} param Paramteres for creating a Twig template.\n     *\n     * @return {Twig.Template} A Twig template ready for rendering.\n     */\n\t\t\t\tTwig.exports.twig = function twig(params) {\n\t\t\t\t\t'use strict';\n\n\t\t\t\t\tvar id = params.id,\n\t\t\t\t\t    options = {\n\t\t\t\t\t\tstrict_variables: params.strict_variables || false,\n\t\t\t\t\t\t// TODO: turn autoscape on in the next major version\n\t\t\t\t\t\tautoescape: params.autoescape != null && params.autoescape || false,\n\t\t\t\t\t\tallowInlineIncludes: params.allowInlineIncludes || false,\n\t\t\t\t\t\trethrow: params.rethrow || false,\n\t\t\t\t\t\tnamespaces: params.namespaces\n\t\t\t\t\t};\n\n\t\t\t\t\tif (Twig.cache && id) {\n\t\t\t\t\t\tTwig.validateId(id);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (params.debug !== undefined) {\n\t\t\t\t\t\tTwig.debug = params.debug;\n\t\t\t\t\t}\n\t\t\t\t\tif (params.trace !== undefined) {\n\t\t\t\t\t\tTwig.trace = params.trace;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (params.data !== undefined) {\n\t\t\t\t\t\treturn Twig.Templates.parsers.twig({\n\t\t\t\t\t\t\tdata: params.data,\n\t\t\t\t\t\t\tpath: params.hasOwnProperty('path') ? params.path : undefined,\n\t\t\t\t\t\t\tmodule: params.module,\n\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\toptions: options\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (params.ref !== undefined) {\n\t\t\t\t\t\tif (params.id !== undefined) {\n\t\t\t\t\t\t\tthrow new Twig.Error(\"Both ref and id cannot be set on a twig.js template.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Twig.Templates.load(params.ref);\n\t\t\t\t\t} else if (params.method !== undefined) {\n\t\t\t\t\t\tif (!Twig.Templates.isRegisteredLoader(params.method)) {\n\t\t\t\t\t\t\tthrow new Twig.Error('Loader for \"' + params.method + '\" is not defined.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Twig.Templates.loadRemote(params.name || params.href || params.path || id || undefined, {\n\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\tmethod: params.method,\n\t\t\t\t\t\t\tparser: params.parser || 'twig',\n\t\t\t\t\t\t\tbase: params.base,\n\t\t\t\t\t\t\tmodule: params.module,\n\t\t\t\t\t\t\tprecompiled: params.precompiled,\n\t\t\t\t\t\t\tasync: params.async,\n\t\t\t\t\t\t\toptions: options\n\n\t\t\t\t\t\t}, params.load, params.error);\n\t\t\t\t\t} else if (params.href !== undefined) {\n\t\t\t\t\t\treturn Twig.Templates.loadRemote(params.href, {\n\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\tmethod: 'ajax',\n\t\t\t\t\t\t\tparser: params.parser || 'twig',\n\t\t\t\t\t\t\tbase: params.base,\n\t\t\t\t\t\t\tmodule: params.module,\n\t\t\t\t\t\t\tprecompiled: params.precompiled,\n\t\t\t\t\t\t\tasync: params.async,\n\t\t\t\t\t\t\toptions: options\n\n\t\t\t\t\t\t}, params.load, params.error);\n\t\t\t\t\t} else if (params.path !== undefined) {\n\t\t\t\t\t\treturn Twig.Templates.loadRemote(params.path, {\n\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\tmethod: 'fs',\n\t\t\t\t\t\t\tparser: params.parser || 'twig',\n\t\t\t\t\t\t\tbase: params.base,\n\t\t\t\t\t\t\tmodule: params.module,\n\t\t\t\t\t\t\tprecompiled: params.precompiled,\n\t\t\t\t\t\t\tasync: params.async,\n\t\t\t\t\t\t\toptions: options\n\n\t\t\t\t\t\t}, params.load, params.error);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Extend Twig with a new filter.\n\t\t\t\tTwig.exports.extendFilter = function (filter, definition) {\n\t\t\t\t\tTwig.filter.extend(filter, definition);\n\t\t\t\t};\n\n\t\t\t\t// Extend Twig with a new function.\n\t\t\t\tTwig.exports.extendFunction = function (fn, definition) {\n\t\t\t\t\tTwig._function.extend(fn, definition);\n\t\t\t\t};\n\n\t\t\t\t// Extend Twig with a new test.\n\t\t\t\tTwig.exports.extendTest = function (test, definition) {\n\t\t\t\t\tTwig.test.extend(test, definition);\n\t\t\t\t};\n\n\t\t\t\t// Extend Twig with a new definition.\n\t\t\t\tTwig.exports.extendTag = function (definition) {\n\t\t\t\t\tTwig.logic.extend(definition);\n\t\t\t\t};\n\n\t\t\t\t// Provide an environment for extending Twig core.\n\t\t\t\t// Calls fn with the internal Twig object.\n\t\t\t\tTwig.exports.extend = function (fn) {\n\t\t\t\t\tfn(Twig);\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Provide an extension for use with express 2.\n     *\n     * @param {string} markup The template markup.\n     * @param {array} options The express options.\n     *\n     * @return {string} The rendered template.\n     */\n\t\t\t\tTwig.exports.compile = function (markup, options) {\n\t\t\t\t\tvar id = options.filename,\n\t\t\t\t\t    path = options.filename,\n\t\t\t\t\t    template;\n\n\t\t\t\t\t// Try to load the template from the cache\n\t\t\t\t\ttemplate = new Twig.Template({\n\t\t\t\t\t\tdata: markup,\n\t\t\t\t\t\tpath: path,\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\toptions: options.settings['twig options']\n\t\t\t\t\t}); // Twig.Templates.load(id) ||\n\n\t\t\t\t\treturn function (context) {\n\t\t\t\t\t\treturn template.render(context);\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Provide an extension for use with express 3.\n     *\n     * @param {string} path The location of the template file on disk.\n     * @param {Object|Function} The options or callback.\n     * @param {Function} fn callback.\n     * \n     * @throws Twig.Error\n     */\n\t\t\t\tTwig.exports.renderFile = function (path, options, fn) {\n\t\t\t\t\t// handle callback in options\n\t\t\t\t\tif (typeof options === 'function') {\n\t\t\t\t\t\tfn = options;\n\t\t\t\t\t\toptions = {};\n\t\t\t\t\t}\n\n\t\t\t\t\toptions = options || {};\n\n\t\t\t\t\tvar settings = options.settings || {};\n\n\t\t\t\t\tvar params = {\n\t\t\t\t\t\tpath: path,\n\t\t\t\t\t\tbase: settings.views,\n\t\t\t\t\t\tload: function (template) {\n\t\t\t\t\t\t\t// render and return template as a simple string, see https://github.com/twigjs/twig.js/pull/348 for more information\n\t\t\t\t\t\t\tfn(null, '' + template.render(options));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// mixin any options provided to the express app.\n\t\t\t\t\tvar view_options = settings['twig options'];\n\n\t\t\t\t\tif (view_options) {\n\t\t\t\t\t\tfor (var option in view_options) {\n\t\t\t\t\t\t\tif (view_options.hasOwnProperty(option)) {\n\t\t\t\t\t\t\t\tparams[option] = view_options[option];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTwig.exports.twig(params);\n\t\t\t\t};\n\n\t\t\t\t// Express 3 handler\n\t\t\t\tTwig.exports.__express = Twig.exports.renderFile;\n\n\t\t\t\t/**\n     * Shoud Twig.js cache templates.\n     * Disable during development to see changes to templates without\n     * reloading, and disable in production to improve performance.\n     *\n     * @param {boolean} cache\n     */\n\t\t\t\tTwig.exports.cache = function (cache) {\n\t\t\t\t\tTwig.cache = cache;\n\t\t\t\t};\n\n\t\t\t\t//We need to export the path module so we can effectively test it\n\t\t\t\tTwig.exports.path = Twig.path;\n\n\t\t\t\t//Export our filters.\n\t\t\t\t//Resolves #307\n\t\t\t\tTwig.exports.filters = Twig.filters;\n\n\t\t\t\treturn Twig;\n\t\t\t};\n\n\t\t\t/***/\n\t\t}\n\t\t/******/])\n\t);\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/twig/twig.js\n// module id = 15\n// module chunks = 0","'use strict';\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 16\n// module chunks = 0","'use strict';\n\n/*!\n * Modal for the Viewer Layer\n * For both annotations and code/info\n *\n * Copyright (c) 2016 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * @requires url-handler.js\n * @requires data-saver.js\n *\n */\n\nconst urlHandler = require('url-handler').urlHandler;\nconst DataSaver = require('data-saver').DataSaver;\nconst panelsViewer = require('panels-viewer');\n\nvar modalViewer = {\n\n  // set up some defaults\n  active: false,\n  switchText: true,\n  template: 'info',\n  patternData: {},\n  targetOrigin: window.location.protocol === 'file:' ? '*' : window.location.protocol + '//' + window.location.host,\n\n  /**\n  * initialize the modal window\n  */\n  onReady: function () {\n\n    // make sure the listener for checkpanels is set-up\n    Dispatcher.addListener('insertPanels', modalViewer.insert);\n\n    // watch for resizes and hide the modal container as appropriate when the modal is already hidden\n    $(window).on('resize', function () {\n      if (DataSaver.findValue('modalActive') === 'false') {\n        modalViewer.slide($('#sg-modal-container').outerHeight());\n      }\n    });\n\n    // add the info/code panel onclick handler\n    $('#sg-t-patterninfo').click(function (e) {\n      e.preventDefault();\n      $('#sg-tools-toggle').removeClass('active');\n      $(this).parents('ul').removeClass('active');\n      modalViewer.toggle();\n    });\n\n    // make sure the close button handles the click\n    $('#sg-modal-close-btn').on('click', function (e) {\n\n      e.preventDefault();\n\n      // hide any open annotations\n      var obj = JSON.stringify({ 'event': 'patternLab.annotationsHighlightHide' });\n      document.getElementById('sg-viewport').contentWindow.postMessage(obj, modalViewer.targetOrigin);\n\n      // hide the viewer\n      modalViewer.close();\n    });\n\n    // see if the modal is already active, if so update attributes as appropriate\n    if (DataSaver.findValue('modalActive') === 'true') {\n      modalViewer.active = true;\n      $('#sg-t-patterninfo').html(\"Hide Pattern Info\");\n    }\n\n    // make sure the modal viewer is not viewable, it's alway hidden by default. the pageLoad event determines when it actually opens\n    modalViewer.hide();\n\n    // review the query strings in case there is something the modal viewer is supposed to handle by default\n    var queryStringVars = urlHandler.getRequestVars();\n\n    // show the modal if code view is called via query string\n    if (queryStringVars.view !== undefined && (queryStringVars.view === 'code' || queryStringVars.view === 'c')) {\n      modalViewer.queryPattern();\n    }\n\n    // show the modal if the old annotations view is called via query string\n    if (queryStringVars.view !== undefined && (queryStringVars.view === 'annotations' || queryStringVars.view === 'a')) {\n      modalViewer.queryPattern();\n    }\n  },\n\n  /**\n  * toggle the modal window open and closed\n  */\n  toggle: function () {\n    if (modalViewer.active === false) {\n      modalViewer.queryPattern();\n    } else {\n      obj = JSON.stringify({ 'event': 'patternLab.annotationsHighlightHide' });\n      document.getElementById('sg-viewport').contentWindow.postMessage(obj, modalViewer.targetOrigin);\n      modalViewer.close();\n    }\n  },\n\n  /**\n  * open the modal window\n  */\n  open: function () {\n\n    // make sure the modal viewer and other options are off just in case\n    modalViewer.close();\n\n    // note it's turned on in the viewer\n    DataSaver.updateValue('modalActive', 'true');\n    modalViewer.active = true;\n\n    // add an active class to the button that matches this template\n    $('#sg-t-' + modalViewer.template + ' .sg-checkbox').addClass('active');\n\n    //Add active class to modal\n    $('#sg-modal-container').addClass('active');\n\n    // show the modal\n    modalViewer.show();\n  },\n\n  /**\n  * close the modal window\n  */\n  close: function () {\n\n    var obj;\n\n    // not that the modal viewer is no longer active\n    DataSaver.updateValue('modalActive', 'false');\n    modalViewer.active = false;\n\n    //Add active class to modal\n    $('#sg-modal-container').removeClass('active');\n\n    // remove the active class from all of the checkbox items\n    $('.sg-checkbox').removeClass('active');\n\n    // hide the modal\n    modalViewer.hide();\n\n    // update the wording\n    $('#sg-t-patterninfo').html(\"Show Pattern Info\");\n\n    // tell the styleguide to close\n    obj = JSON.stringify({ 'event': 'patternLab.patternModalClose' });\n    document.getElementById('sg-viewport').contentWindow.postMessage(obj, modalViewer.targetOrigin);\n  },\n\n  /**\n  * hide the modal window, add 30px to account for the X box\n  */\n  hide: function () {\n    modalViewer.slide($('#sg-modal-container').outerHeight() + 30);\n  },\n\n  /**\n  * insert the copy for the modal window. if it's meant to be sent back to the iframe do do\n  * @param  {String}       the rendered template that should be inserted\n  * @param  {String}       the patternPartial that the rendered template is related to\n  * @param  {Boolean}      if the refresh is of a view-all view and the content should be sent back\n  * @param  {Boolean}      if the text in the dropdown should be switched\n  */\n  insert: function (templateRendered, patternPartial, iframePassback, switchText) {\n\n    if (iframePassback) {\n\n      // send a message to the pattern\n      var obj = JSON.stringify({ 'event': 'patternLab.patternModalInsert', 'patternPartial': patternPartial, 'modalContent': templateRendered.outerHTML });\n      document.getElementById('sg-viewport').contentWindow.postMessage(obj, modalViewer.targetOrigin);\n    } else {\n\n      // insert the panels and open the viewer\n      $('#sg-modal-content').html(templateRendered);\n      modalViewer.open();\n    }\n\n    // update the wording unless this is a default viewall opening\n    if (switchText === true) {\n      $('#sg-t-patterninfo').html(\"Hide Pattern Info\");\n    }\n  },\n\n  /**\n  * refresh the modal if a new pattern is loaded and the modal is active\n  * @param  {Object}       the patternData sent back from the query\n  * @param  {Boolean}      if the refresh is of a view-all view and the content should be sent back\n  * @param  {Boolean}      if the text in the dropdown should be switched\n  */\n  refresh: function (patternData, iframePassback, switchText) {\n\n    // if this is a styleguide view close the modal\n    if (iframePassback) {\n      modalViewer.hide();\n    }\n\n    // gather the data that will fill the modal window\n    panelsViewer.gatherPanels(patternData, iframePassback, switchText);\n  },\n\n  /**\n  * slides the modal window into or out of view\n  * @param  {Integer}      where the modal window should be slide to\n  */\n  slide: function (pos) {\n    pos = pos === 0 ? 0 : -pos;\n    $('#sg-modal-container').css('bottom', pos);\n  },\n\n  /**\n  * slides the modal window to a particular annotation\n  * @param  {Integer}      the number for the element that should be highlighted\n  */\n  slideToAnnotation: function (pos) {\n\n    // remove active class\n    els = document.querySelectorAll('#sg-annotations > .sg-annotations-list > li');\n    for (i = 0; i < els.length; ++i) {\n      els[i].classList.remove('active');\n    }\n\n    // add active class to called element and scroll to it\n    for (i = 0; i < els.length; ++i) {\n      if (i + 1 == pos) {\n        els[i].classList.add('active');\n        $('.sg-pattern-extra-info').animate({ scrollTop: els[i].offsetTop - 10 }, 600);\n      }\n    }\n  },\n\n  /**\n  * alias for slide\n  */\n  show: function () {\n    modalViewer.slide(0);\n  },\n\n  /**\n  * ask the pattern for info so we can open the modal window and populate it\n  * @param  {Boolean}      if the dropdown text should be changed\n  */\n  queryPattern: function (switchText) {\n\n    // note that the modal is active and set switchText\n    if (switchText === undefined || switchText) {\n      switchText = true;\n      DataSaver.updateValue('modalActive', 'true');\n      modalViewer.active = true;\n    }\n\n    // send a message to the pattern\n    var obj = JSON.stringify({ 'event': 'patternLab.patternQuery', 'switchText': switchText });\n    document.getElementById('sg-viewport').contentWindow.postMessage(obj, modalViewer.targetOrigin);\n  },\n\n  /**\n  * toggle the comment pop-up based on a user clicking on the pattern\n  * based on the great MDN docs at https://developer.mozilla.org/en-US/docs/Web/API/window.postMessage\n  * @param  {Object}      event info\n  */\n  receiveIframeMessage: function (event) {\n\n    var els, i;\n\n    // does the origin sending the message match the current host? if not dev/null the request\n    if (window.location.protocol !== 'file:' && event.origin !== window.location.protocol + '//' + window.location.host) {\n      return;\n    }\n\n    var data = {};\n    try {\n      data = typeof event.data !== 'string' ? event.data : JSON.parse(event.data);\n    } catch (e) {}\n\n    if (data.event !== undefined && data.event == \"patternLab.pageLoad\") {\n\n      if (modalViewer.active === false && data.patternpartial !== undefined && data.patternpartial.indexOf('viewall-') === 0 && config.defaultShowPatternInfo !== undefined && config.defaultShowPatternInfo) {\n        modalViewer.queryPattern(false);\n      } else if (modalViewer.active === true) {\n        modalViewer.queryPattern();\n      }\n    } else if (data.event !== undefined && data.event == 'patternLab.patternQueryInfo') {\n\n      // refresh the modal if a new pattern is loaded and the modal is active\n      modalViewer.refresh(data.patternData, data.iframePassback, data.switchText);\n    } else if (data.event !== undefined && data.event == 'patternLab.annotationNumberClicked') {\n\n      // slide to a given annoation\n      modalViewer.slideToAnnotation(data.displayNumber);\n    }\n  }\n\n};\n\n// when the document is ready make sure the modal is ready\n$(document).ready(function () {\n  modalViewer.onReady();\n});\nwindow.addEventListener(\"message\", modalViewer.receiveIframeMessage, false);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/modal-viewer/index.js\n// module id = 17\n// module chunks = 0","'use strict';\n\n/*!\n * Plugin Loader\n *\n * Copyright (c) 2015 Dave Olsen, http://dmolsen.com\n * Licensed under the MIT license\n *\n * Takes the assets they can be loaded for plugins and adds them to the DOM\n *\n * @requires styleguide.js\n *\n */\n\nrequire('styleguide');\n\nvar pluginLoader = {\n\n  init: function () {\n\n    var s, t, l, c, n;\n\n    for (var i = 0; i < plugins.length; ++i) {\n\n      var plugin = plugins[i];\n\n      // load the templates\n      for (var key in plugin.templates) {\n        if (plugin.templates.hasOwnProperty(key)) {\n          t = document.getElementsByTagName('script');\n          l = t.length - 1;\n          s = t[l];\n          n = document.createElement('script');\n          n.type = 'text/mustache';\n          n.id = plugin.name.replace(\"\\/\", \"-\") + \"-\" + key + \"-template\";\n          n.innerHTML = plugin.templates[key];\n          s.parentNode.insertBefore(n, s.nextSibling);\n        }\n      }\n\n      // load the stylesheets\n      for (var k = 0; k < plugin.stylesheets.length; ++k) {\n        s = plugin.stylesheets[k];\n        t = document.getElementsByTagName('link');\n        l = t.length - 1;\n        c = t[l];\n        n = document.createElement('link');\n        n.type = 'text/css';\n        n.rel = 'stylesheet';\n        n.href = 'patternlab-components/' + plugin.name + '/' + s;\n        n.media = 'screen';\n        c.parentNode.insertBefore(n, c.nextSibling);\n      }\n\n      // load the javascript\n      // $script.path('patternlab-components/'+plugin.name+'/');\n      $script(plugin.javascripts, plugin.name, eval('(function() { ' + plugin.callback + ' })'));\n      $script.ready([plugin.name], eval('(function() { ' + plugin.onready + ' })'));\n    }\n  }\n\n};\n\npluginLoader.init();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/plugin-loader/index.js\n// module id = 18\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACn1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A","sourceRoot":""}